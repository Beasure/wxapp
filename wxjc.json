{"title": "微信小程序开发，如何优雅地兼容 ", "author": "Rolan", "pub_time": "2018-9-19 00:02", "content": "关于单个 API 如何兼容，微信官方提供了兼容文档，因此我们这里不再赘述。下面主要讨论在整个项目如何优雅地处理兼容问题。问题如果在每处需要兼容的地方都写上一堆兼容相关的代码，随着代码量增加，会出现以下问题：代码难以阅读兼容方案有变动时，需要改动多处随着时间推移，你的代码才是最需要并且是最难兼容的思考最理想的情况是不需要任何兼容处理，因此可以反推出兼容性处理的代码并不是代码正常流程中的一部分，基于此：兼容的细节不必暴露兼容的方案应该统一兼容的方案可方便地变动解决方案1.将兼容方案隐藏，对外提供接口即可比如 wx.showLoading 是在 1.1.0 版本之后才提供的，对于之前的版本需要兼容。我们选择将其放在 show-loading.js 中，内部进行兼容性相关处理，并对外提供 showLoading 方法。这样调用者只需调用 showLoading 方法即可，不用考虑兼容性的问题，而且如果兼容的方式有变动，只需改动 show-loading.js 一处即可。2.兼容的处理还有共性可以抽象兼容处理多了之后我们会发现，对兼容所做的处理无非两方面：支持该方法时，直接使用对应方法不支持该方法时，做一些兼容处理因此这种模式我们又可以抽离出来，这样做当然有一些好处：减少重复代码做一些共性的处理时，我们又只用改动一处（比如当不兼容官方 API 时加上对应统计，用于分析当前应用跨版本的情况）比如我们抽离出这样一个简单的 compatible.js 用于处理兼容时的共性问题：之前的 showLoading.js 我们可以这样写：简单吧 :)，这种写法的意思是兼容时正常展示 loading 即可，不兼容时则不展示。当然可能有完美主义者会觉得『怎么能不展示呢？我就是要展示！』 那么我们可以这样写：用 wx.showToast 伪造了一个 showLoading。3.文件组织兼容性的文件可能会越来越多，对于我这种有收拾的人，看到所有东西散乱地扔在一个抽屉里肯定是不能忍的...因此我们可以多用几个小盒子把它们分门别类地装起来。小盒子怎么选呢？其实官方已经给出了答案，官方 API 是按照不同的功用分组的，因此我们拿分组当『盒子』即可。最终的文件组织像这样："}
{"title": "hooks 在微信小程序中的试验 ", "author": "Rolan", "pub_time": "2018-11-27 00:04", "content": "前段时间 react hooks 特性刷得沸沸扬扬的，看起来挺有意思的，估计不少其他框架也会逐步跟进，所以也来尝试一下能不能用在小程序上。react hooks 允许你在函数式组件中使用 state，用一段官方的简单例子概括如下：import { useState } from 'react';\r\n\r\nfunction Example() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    <div>\r\n      <p>You clicked {count} times</p>\r\n      <button onClick={() => setCount(count + 1)}>\r\n        Click me\r\n      </button>\r\n    </div>\r\n  );\r\n}\r\n复制代码函数式组件本身非常简洁，不维护生命周期和状态，是一个可以让性能得以优化的使用方式。但是在之前这种方式只能用于纯展示组件或者高阶组件等，它很难实现一些交互行为。但是在 hooks 出现之后，你就可以为所欲为了。这里有一份官方的文档，不明围观群众有兴趣的可以点进去了解一下： reactjs.org/docs/hooks-… 。hooks 的使用目前有两个限制：只能在函数式组件内或其他自定义 hooks 内使用，不允许在循环、条件或普通 js 函数中调用 hooks。只能在顶层调用 hooks 。这个限制和 hooks 的实现方式有关，下面小程序 hooks 也会有同样限制，原因应该也是类似的。为了能让开发者更好的使用 hooks，react 官方也提供了一套 eslint 插件来协助我们开发： reactjs.org/docs/hooks-… 。下面就来介绍下在小程序中的尝试~函数式组件小程序没有提供函数式组件，这倒是很好理解，小程序的架构是双线程运行模式，逻辑层执行 js 代码，视图层负责渲染。那么声明在逻辑层的自定义组件要渲染在视图层必须保证来两个线程都存在自定义组件实例并一一对应，这样的架构已经成熟，目前对函数式组件并没有强烈的需求。在基础库不大改的情况下，就算提供了函数式组件也只是提供了另一种新写法而已，本质上的实现没有区别也不能提升什么性能。不过也不排除以后小程序会提供一种只负责渲染不维护生命周期不做任何逻辑的特殊组件来优化渲染性能，这种的话本质上就和函数式组件类似了，不过函数式组件较为极端的是在理论上是有办法做到无实例的，这个在小程序中怕是有点困难。言归正传，小程序没有提供函数式组件，那么就强行封装出一个写法好了，假设我们有一个自定义组件，它的 js 和 wxml 内容分别是这样的：// component.js\r\nconst {useState, useEffect, FunctionalComponent} = require('miniprogram-hooks') \r\n\r\nFunctionalComponent(function() {\r\n  const [count, setCount] = useState(1)\r\n\r\n  useEffect(() => {\r\n    console.log('count update: ', count)\r\n  }, [count])\r\n\r\n  const [title, setTitle] = useState('click')\r\n\r\n  return {\r\n    count,\r\n    title,\r\n    setCount,\r\n    setTitle,\r\n  }\r\n})\r\n复制代码<!-- component.wxml -->\r\n<view>{{count}}</view>\r\n<button bindtap=\"setCount\" data-arg=\"{{count + 1}}\">{{title}}</button>\r\n<button bindtap=\"setTitle\" data-arg=\"{{title + '(' + count + ')'}}\">update btn text</button>\r\n复制代码一个很奇葩的例子，但是能看明白就行。小程序里视图和逻辑分离，不像 react 可以将视图和逻辑写到一起，那么小程序里的函数式组件里想返回一串渲染逻辑就不太科学了，这里就改成返回要用于渲染的 state 和方法。PS：wxml 里不支持 bindtap=\"setCount(count + 1)\" 这种写法，所以参数就走 dataset 的方式传入了。FunctionComponent 函数其实就相当于封装了小程序原有的 Component 构造器，它的实现类似这样：function FunctionalComponent(func) {\r\n  func = typeof func === 'function' ? func : function () {}\r\n\r\n  // 定义自定义组件\r\n  return Component({\r\n    attached() {\r\n      this._$state = {}\r\n      this._$effect = {}\r\n      this._$func = () => {\r\n        currentCompInst = this // 记录当前的自定义组件实例\r\n        callIndex = 0 // 初始化调用序号\r\n        const newDef = func.call(null) || {}\r\n        currentCompInst = null\r\n\r\n        const {data, methods} = splitDef(newDef) // 拆分 state 和方法\r\n\r\n        // 设置 methods\r\n        Object.keys(methods).forEach(key => {\r\n          this[key] = methods[key]\r\n        })\r\n\r\n        // 设置 data\r\n        this.setData(data)\r\n      }\r\n\r\n      this._$func()\r\n    },\r\n    detached() {\r\n      this._$state = null\r\n      this._$effect = null\r\n      this._$func = null\r\n    }\r\n  })\r\n}\r\n复制代码实现很简单，就是在 attached 的时候跑一下传入的函数，拿到 state 和方法后设置到自定义组件实例上就行。其中 currentCompInst 和 callIndex 在 useState 和 useEffect 的实现上会用到，下面来介绍。useState 和 useEffect这里的一个难点是，useState 是没有指定变量名的。初次渲染还好，二次渲染的话要找回这个变量就要费一段代码了。PS：后续的实现除了参考了 react 的 hooks 外，也参考了 vue-hooks 的尝试，有兴趣的同学也可以去观摩一下。这里上面提到的 currentCompInst 和 callIndex，将上一次的变量存储在 currentCompInst 中，用 callIndex 记录调用 useState 和 useEffect 的顺序，这样就可以在二次渲染的时候通过顺序找回上一次使用的变量：function useState(initValue) {\r\n  if (!currentCompInst) throw new Error('component instance not found!')\r\n\r\n  const index = callIndex++\r\n  const compInst = currentCompInst\r\n\r\n  if (compInst._$state[index] === undefined) compInst._$state[index] = initValue\r\n\r\n  const updater = function (evt) {\r\n    let value = evt\r\n\r\n    // wxml 事件回调\r\n    if (typeof evt === 'object' && evt.target && evt.currentTarget) {\r\n      const dataset = evt.currentTarget.dataset\r\n      value = dataset && dataset.arg\r\n    }\r\n\r\n    // 存入缓存\r\n    compInst._$state[index] = value\r\n    compInst._$func()\r\n  }\r\n  updater._isUpdater = true\r\n\r\n  return [compInst._$state[index], updater]\r\n}\r\n复制代码useEffect 的实现逻辑也类似，这里就不再贴代码了。小程序本身没有提供 render 函数，调 FunctionalComponent 声明函数式组件传入的函数就作为 render 函数来用。每次调 setXXX 方法——也就是上面代码中返回的 updater 的时候，找到原本存储这个 state 的地方存储进去，然后再次执行 render 函数，进行组件的渲染。到这里应该就明白了，对于 hooks 使用为什么会有一开始的那两条限制。如果在一些条件、循环等语句内使用 hooks，就无法确保 state 的顺序，再二次渲染时就不一定能找回对应的 state。尾声完整的代码在 github.com/wechat-mini… ，不过这终究只是个试验性质的尝试，并不推荐拿来实战，写在这里是为与大家共享~"}
{"title": "微信小程序使用touch事件实现左滑删除 ", "author": "Rolan", "pub_time": "2018-11-27 00:13", "content": "前言之前写过一篇微信小程序使用movable-view实现左滑删除功能，有同学使用了这种方案并提出我之前没有发现的bug（现在bug已进行了修复），感谢。有同学问了如果不使用movable-view的话如何来实现左滑删除？那这次就写一下如何只使用touch事件来实现左滑删除。源码Talk is cheap. Show me the code.实现原理此次组件需要处理touchstart、touchmove和touchend三个touch事件touchstart事件时需要先禁用掉transition动画，同时记录下触摸点的pageX和pageY的值，以及此时滑动的起始点，即删除按钮的状态，隐藏还是显示。touchmove事件处理手指的滑动，此时需要进行以下不同情况的判断：手指上下移动的距离超过左右滑动的距离，此时我们可以把用户的操作理解为上下滑动而不是左右滑动，此时我们对组件不进行移动判断如果是以下两种情况时不进行组件的移动：在最右边时向右滑动;在最左边时向左滑动如果手指滑动超出了删除按钮的宽度时（包括左滑和右滑两个方向），取按钮宽度作为移动距离其他情况：手指滑动了多少就对组件位移多少touchend事件则是处理手指离开屏幕之后组件的一些后续动作:先根据touchmove中记录的手指位移方向进行判断，非左右滑动时则对组件不进行移动左右移动超出右滑最大位移时，设置位移终点为0左右移动超出左滑最大位移时，设置位移终点为负的删除按钮宽度以下两种情况组件都滑动到右边起点（即删除按钮隐藏的状态）：从右边起点左滑但未超过最大位移的一半，回退到右边起点从左边起点右滑且超过最大位移的一半，继续滑到到右边起点其他情况组件都滑到左边起点（即删除按钮显示的状态）设置位移值，并打开组件的transition动画效果图"}
{"title": "你可能不知道的小程序（上篇） ", "author": "Rolan", "pub_time": "2018-11-27 00:21", "content": "为了让大家更好的理解小程序的一些限制和做一些优化，下面从小程序的基础架构讲起，如有不对的地方，望指正，请轻喷 :smile:一. 页面栈限制最多10层首先，我们看看下图，小程序的架构如下：我们可以看到，一个页面使用一个 WebView 线程进行渲染。 如果于页面栈有 10 层，则会开启 10 个 WebView 线程，占多一点内存，所以对页面栈进行了限制。那如果在10层页面栈的限制内，由于页面的内容过于复杂，内存爆了怎么办？ 小程序内部有一个回收机制，如果内存紧张时，会回收掉一部分 WebView 。很多人可能会觉得， 10 层页面栈基本已经够用了，无须关注这方面的限制了。但是如果出现循环引用的话，用户反复点击，则很容易出现爆栈的情况。 如下图：所以，在开发之前，提前梳理好页面之间的跳转，合理使用 navigator ，redirectTo, navigateBack …… 是非常重要的。当然，作为一个程序员，我并不想在跳转的时候去时时刻刻的关注我有没有正确引用，有没有超出10层页面栈。 完全可以对小程序的跳转做一个封装。因为只有 wx.navigateTo 才会使页面栈 + 1 ，那我们只要对这个方法做一层兜底处理即可。 如下代码：const PAGE_LIMIT = 10\r\nconst pages = getCurrentPages()\r\nif(pages.length >= PAGE_LIMIT) {\r\n  // 使用 wx.redirectTo 方法\r\n}\r\n复制代码这样就可以随心所欲的跳来跳去了。二. JsCore小程序的逻辑层是在 JsCore 中运行的。限制如下：没有 Window、Document 对象，也就无法使用 基于 DOM 的一些库. 暂无解决方法。还是从一张图说起：不同于页面的渲染，所有的脚本逻辑都是跑在同一个 JsCode 线程里面，类似于路由中改变 Hash 值。 因此也会引起下面一些常见的坑需要自己清理页面的 setTimeout 或者 setInterval 定时器如果要求页面每次出现都是最新的数据，则要把拉取数据的逻辑放在 onShow 中执行，别放在 onload 中。若追求“极致化体验”，在用户切到下一个页面的时候，可以在 onHide 中 abort 掉没有请求成功的接口，把即将处理的 setData 去掉，可以减轻最新页面的逻辑，让最新页面最快渲染展示。三. 原生组件层级最高像 canvas , video ，input ，map ，picker …… 组件，官方直接使用原生组件，渲染方式如下图：从上图很容易就可以看出，Navtive 组件的层级是最高的，那么仅仅去改变 z-index 也无法让其他组件覆盖原生组件。还好，官方给出了一个解决方案：使用 cover-view cover-image 将希望层级变高的组件也包裹成“原生组件”四. 独特的网络请求，本地存储独特的 Storage 存储以用户纬度隔离，同一个设备，A 无法访问 B 用户的数据。持久缓存，只有在用户关掉小程序才会删除，如果空间不足，会进行 LRU ，也就是不经常使用的小程序的数据缓存区域会被全部清空。在体验版、开发版、和线上版都共用一套，并不会隔离。没有 CookieRequest uploadFile downloadFile 并发最多10个请求只支持 HTTPS WSS如果以往在移动端, PC 的接口会使用 Cookie 进行一些处理，那在小程序中使用该接口就比较尴尬了。因此，我们可以在小程序中也模拟出 Cookie ，如下图：在 Storage 中隔离一个字段，用来做 Cookie ，下面用了一个小技巧，把 Cookie 的内容存放于内存中，而非每次都从 storage 中读取。let cookie = (function(){\r\n    return wx.getStorageSync('cookies');\r\n}())\r\nconst Cooke = {\r\n  getCookie(){}, //从内存中获取cookie\r\n  setCookie(){}, // 设置cookie\r\n  setCookieInHeader(){}, //根据response的Header设置cookie\r\n  removeCookie() {},  //删除cookie\r\n  isExpired() {} //判断是否过期\r\n}\r\n复制代码然后，我们在每次 Request 成功后，解析 Header 中 SET-COOKIE 属性设置 Cookie ，在每一次请求的时候，手动在 Header 中设置 Cookie 。这样就完美地模拟浏览器的 Cookie 概念了。并发请求处理设置一个队列，如果请求处理完毕，则移出队列，如果当前数组超过10个请求，则进入等待状态。大概代码如下：class Request {\r\n    constructor() {\r\n        this.maxLimit = 10;\r\n        this.requestQueue = []; // 请求队列\r\n        this.requestIng = 0; //当前并发数\r\n    }\r\n    request () {\r\n        // 判断是否超出并发数\r\n        if(this.requestIng >= this.maxLimit) {\r\n            // 推入请求队列\r\n        }else {\r\n            this.requestIng ++;\r\n            // 执行成功后 - 1 ,从 requestQueue 中取出重新请求\r\n        }\r\n    }\r\n}\r\n复制代码五. setData好吧，还是从一张图说起，显然，我们可以看出，每一次 setData 都是一次线程通信。线程通信成本很高，非常耗时间，因此官方明确的给出了建议：将多次 setData 合并成一次进行调用只 setData 对象改变的某个值data: {\r\n    array: {\r\n        changeData: '我改变了',\r\n        noChangeData: '我没有改变'\r\n    },\r\n},\r\nthis.setData({\r\n    'array.changeData':'changed data'\r\n})\r\n复制代码与界面渲染无关的字段不要放在 data 中data: {\r\n    view: '与界面相关的数据'\r\n},\r\nnoRelaView: '与界面无关'\r\n复制代码@Author：beidan"}
{"title": "微信小程序从入坑到放弃之坑八：textarea在苹果手机中的大Bug ", "author": "Rolan", "pub_time": "2018-11-27 00:42", "content": "首次在这里写点东西，还请各位大佬担待点。摘要：昨天的placeholder-class只是希望各位看官注意，而今天的textarea就绝对是一个超级大坑！而且如果看官手中没有苹果手机测试的话，这个可就真的是个坑了！为啥？难道要等到用户向你反馈你们产品有bug？？？......上一篇的《微信小程序从入坑到放弃之坑七：input组件的占位符placeholder》，没啥大坑，而这篇的textarea可就不一样了！这绝对是一个超大的Bug！！！在上一节的设计稿中，详细地址那块儿就是一个textarea组件。如图：其他无关的就不说了，我们直接进入正题。一、textarea在模拟器、安卓和苹果中的效果为了便于观察textarea组件的尺寸范围，我们给textarea设置一个背景色。如图：（一个带背景色的textarea组件示例代码一个带背景色的textarea组件示例代码）然后保存后看下模拟器、安卓手机和苹果手机中的效果吧。如图：（textarea在模拟器和安卓及苹果手机上的效果textarea在模拟器和安卓及苹果手机上的效果）看到区别了吗？如果没有，再来张大图。如图：（textarea在苹果手机上距离顶部有空隙textarea在苹果手机上距离顶部有空隙）二、不就是个padding吗？！对于有前端基础的看官来说，一眼就知道这是什么原因。是的，按照正常逻辑，这个空隙就是由padding引起的。2.1、wxml代码<textarea style=\"background:#666;padding:0\" value=\"加padding就有用了吗？\"></textarea>代码写完了，我们再用苹果手机看下效果。如图：（微信小程序里的textarea设置padding为0时在苹果手机中没有生效）微信小程序里的textarea设置padding为0时在苹果手机中没有生效可以看到，此时这个padding:0在苹果手机上并没有生效！奇了怪了，难道textarea不支持padding吗？于是，我又将padding的值修改成40px，此时在安卓手机上的效果如下：（设置padding为40时在安卓手机中有效设置padding为40时在安卓手机中有效）我们可以看到，此时安卓手机上是有效的，再来看看苹果手机吧，如图：（设置padding为40时在苹果手机中也有效）咦，怎么又有效果了？！那这个苹果手机到底支持不支持微信小程序里的textarea组件的padding属性呢？要说不支持吧，修改成40时也有效，要说支持吧，改成0又无效！这就有点坑爹了！三、微信小程序里的textarea确实有bug为了便于测试，这回我们直接测一组吧。效果如图：（测试发现在微信小程序中，苹果手机对padding的值有临界点）看到了吗？当值小于或等于0时，在苹果手机中压根就没有任何反应！虽然正常的网页中padding的值是不能为负的！但此时连0!important都无能为力！！！四、此坑有什么影响可能有些看官还不知道这坑有什么影响，拿我们的设计稿来说。我们写的页面总得与设计稿一致吧！那些现在问题就来了，这个textarea组件在安卓和苹果上的表现都不一样，要想在两种手机上展现效果一样，必须得对苹果单独处理才行！否则，我们在安卓上布局是好的，到了苹果手机上面，就已经错位了！所以，这就是个超级大坑！要不是因为艺灵我用二手的iphone 6s测试，这个bug估计还不知道什么时候才能知道呢！如果是等到用户反馈才知道，这可是件多么坑爹的事情！！！五、微信小程序中textarea内边距的坑通吃iphone各版本看官可能会说：“都什么年代了，艺灵你还用个破6s来测试！”行，为了验证此bug并非只是iphone 6s才有，于是我又召唤了我的小伙伴们。聊天如图：（微信小程序中textarea的内边距bug在iphone各版本上都存在）这回就问你服不服，iphone X，壕不？X都阵亡了！！！六、如何解决？搞过微信小程序的看官都知道，在小程序里面不像正常网页那样可以随便写js，在这里一切都要受限制！微信小程序官方也有对应的文档，文档地址：developers.weixin.qq.com/miniprogram/dev/api/system/system-info/wx.getSystemInfo.html?search-key=wx.getSystemInfo 。官方的文档向来都这样，要么不给案例，要么就简短的写下。现在的机型那么多，鬼知道怎么判断啊！于是我又在网上搜索后找到了现成的判断小程序是用安卓还是IOS打开的方法，原文地址：blog.csdn.net/niesiyuan000/article/details/80325988。顺便补充一句，微信官方提供的判断依旧不全面，最新出来的苹果手机还没有完全支持！相关的坑可以在官方社区的问答中找到。坑！坑！坑！坑！坑！坑！坑！"}
{"title": "API接口手工防御被恶意调用和接口被攻击 ", "author": "Rolan", "pub_time": "2018-11-28 00:16", "content": "通常情况下的api接口防护有如下几种：使用HTTPS防止抓包，使用https至少会给破解者在抓包的时候提高一些难度接口参数的加解密，通过md5加密数据+时间戳+随机字符串(salt)，然后将MD5加密的数据和时间戳、原数据均传到后台，后台规定一个有效时长，如果在该时长内，且解密后的数据与原数据一致，则认为是正常请求;也可以采用aes/des之类的加密算法，还可以加入客户端的本地信息作为判断依据本地加密混淆，以上提到的加解密数据和算法，不要直接放在本地代码，因为很容易被反编译和破解，建议放到独立模块中去，并且函数名称越混淆越难读越安全。User-Agent 和 Referer 限制api防护的登录验证，包括设备验证和用户验证，可以通过检查session等方式来判断用户是否登录api的访问次数限制，限制其每分钟的api调用次数，可以通过session或者ip来做限制定期监测，检查日志，侦查异常的接口访问在开发web端程序时，如果你的服务是放在外网的，你是无法完全阻止别人模拟客户端来调用你的web api的。因为你的所有前端代码用户都能直接或间接的看到。而在开发小程序项目时，前端的小程序代码是上传到微信服务器的，其他人想要直接看到或拿到源代码的难度较大，因此小程序端相对安全些;为什么要做接口防护和权限校验?有时候，黑客通过抓包或者其他方式即可获得到后台接口信息，如果不做权限校验，黑客就可以随意调用后台接口，进行数据的篡改和服务器的攻击。因此，为了防止恶意调用，后台接口的防护和权限校验非常重要。小程序如何进行接口防护?要进行小程序的接口防护，首先需要了解小程序的登录过程，如下图所示整个的流程如下：小程序端通过wx.login()获取到code后发送给后台服务器后台服务器使用小程序的appid、appsecret和code，调用微信接口服务换取session_key和openid(openid可以理解为是每个用户在该小程序的唯一识别号)后台服务器自定义生成一个3rd_session，用作openid和session_key的key值，后者作为value值，保存一份在后台服务器或者redis或者mysql，同时向小程序端传递3rd_session小程序端收到3rd_session后将其保存到本地缓存，如wx.setStorageSync(KEY,DATA)后续小程序端发送请求至后台服务器时均携带3rd_session，可将其放在header头部或者body里后台服务器以3rd_session为key，在保证3rd_session未过期的情况下读取出value值(即openid和session_key的组合值)，通过openid判断是哪个用户发送的请求，再和发送过来的body值做对比(如有)，无误后调用后台逻辑处理返回业务数据至小程序端ps：会话密钥session_key 是对用户数据进行加密签名的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥。session_key主要用于wx.getUserInfo接口数据的加解密，如下图所示什么是sessionId?在微信小程序开发中，由wx.request()发起的每次请求对于服务端来说都是不同的一次会话。啥意思呢?就是说区别于浏览器，小程序每一次请求都相当于用不同的浏览器发的。即不同的请求之间的sessionId不一样(实际上小程序cookie没有携带sessionId)。如下图所示：实际上小程序的每次wx.request()请求中没有包含cookie信息，即没有sessionId信息。那么我们能否实现类似浏览器访问，可以将session保存到后台服务器呢?答案是肯定的。我们可以在每次wx.request()中的header里增加## java的写法，Jsessionid只是tomcat的对sessionId的叫法，其实就是sessionId \r\n \r\nheader:{'Cookie': 'JSESSIONID=' + sessionId} \r\n \r\n## thinkjs3.0 的写法 \r\n \r\nheader:{'Cookie': 'thinkjs=' + sessionId} \r\n效果如下图所示：在thinkjs3.0的后台代码中，sessionId被保存到了cookie里，可以通过const session_id = this.cookie('thinkjs') \r\n提取到sessionId的值具体ThinkJS的实现代码首先创建sever端的代码，如下图所示(cd到根目录，运行：thinkjs new server \r\n创建后台代码"}
{"title": "文字超出显示区域后隐藏并显示省略号 ", "author": "Rolan", "pub_time": "2018-11-28 00:29", "content": "单行文字超出后隐藏首先容器需要有固定的宽高，其次加入以下代码即可。view {\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  white-space: nowrap;\r\n}多行文字超出后隐藏容器不需要有固定的宽高，只需加入以下代码即可。无需指定高度，只需指定最多显示几行，属性 -webkit-line-clamp。本示例中最多显示3行，超出3行后，在第三行末尾用省略号代替显示。view {\r\n  display: -webkit-box;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  word-break: break-all;\r\n  -webkit-box-orient: vertical;\r\n  -webkit-line-clamp: 3;\r\n}"}
{"title": "小程序生命周期分析与注册流程回调 ", "author": "Rolan", "pub_time": "2018-11-19 00:21", "content": "从小程序发布到现在，官方api 变动了好几个版本\r\n首先我们先看一下小程序的生命周期\r\napp.js 为小程序的启动入口文件\r\nonLauch: 小程序初始化回掉，生命周期内只执行一次\r\nonShow: 小程序打开或者从后台唤起时的回调\r\nonHide: 小程序从前台进入后台时\r\nonError: 小程序发生脚本错误，或者 api 调用失败时触发，会带上错误信息\r\n页面生命周期：\r\nonLoad:注册页面的时候执行，只执行一次\r\nonShow: 页面在前台展示时执行，显示一次执行一次\r\nonReady: 页面初次渲染完成时执行，冷启动时不执行\r\nonHide: 页面从前台进入后台\r\nonUnload: 页面注销时执行\r\n个人觉得 小程序app中应该增加一个onUnload周期，页面的销毁现实场景个人还没有使用到\r\n===========================================\r\n下面我们来看一下 小程序的注册流程\r\n\r\n针对小程序开发者看下图\r\n\r\n1. 检查是否是登陆接口\r\n2. 判断session\r\n3. wx.login--》获取token\r\n4. 执行原有回掉\r\n好处：让后续开发者 忽略登陆流程逻辑\r\nfunction doLogin(callback, obj) {\r\n    if (obj.isLogin) {\r\n        // 登录接口，直接放过\r\n        // 直接放过，让其走下去\r\n        typeof callback === \"function\" && callback();\r\n    } else if(session) {\r\n        // 缓存中有session\r\n        if(sessionExpireTime && new Date().getTime() > sessionExpire) {\r\n            // 如果有设置本地session缓存时间，且缓存时间已到\r\n            session = '';\r\n            doLogin(callback, obj);\r\n        } else {\r\n            typeof callback === \"function\" && callback();\r\n        }\r\n    } else if (logining) {\r\n        // 正在登录中，请求轮询稍后，避免重复调用登录接口\r\n        flow.wait('doLoginFinished', function () {\r\n            doLogin(callback, obj);\r\n        })\r\n    } else {\r\n        // 缓存中无session\r\n        logining = true;\r\n        obj.count++;\r\n        // 记录调用wx.login前的时间戳\r\n        // 执行login 获取code\r\n        obj._loginStartTime = new Date().getTime();\r\n        console.log('wx.login');\r\n        wx.login({\r\n            complete: function () {\r\n                obj.count--;\r\n                // 记录wx.login返回数据后的时间戳，用于上报\r\n                obj._loginEndTime = new Date().getTime();\r\n                if (typeof reportCGI === \"function\") {\r\n                    reportCGI('wx_login', obj._loginStartTime, obj._loginEndTime, request);\r\n                }\r\n                typeof obj.complete === \"function\" && obj.count == 0 && obj.complete();\r\n            },\r\n            success: function (res) {\r\n                if (res.code) {\r\n                    var data;\r\n                    // codeToSession.data支持函数\r\n                    // 上传服务器操作\r\n                    if (typeof codeToSession.data === \"function\") {\r\n                        data = codeToSession.data();\r\n                    } else {\r\n                        data = codeToSession.data || {};\r\n                    }\r\n                    data[codeToSession.codeName] = res.code;\r\n\r\n                    obj.count++;\r\n                    requestWrapper({\r\n                        url: codeToSession.url,\r\n                        data: data,\r\n                        method: codeToSession.method,\r\n                        isLogin: true,\r\n                        report: codeToSession.report || codeToSession.url,\r\n                        success: function (s) {\r\n                            session        = s;\r\n                            sessionIsFresh = true;\r\n                            // 如果有设置本地session过期时间\r\n                            if(sessionExpireTime) {\r\n                                sessionExpire = new Date().getTime() + sessionExpireTime;\r\n                                wx.setStorage({\r\n                                    key: sessionExpireKey,\r\n                                    data: sessionExpire\r\n                                })\r\n                            }\r\n                            // 执行回掉\r\n                            typeof callback === \"function\" && callback();\r\n                            wx.setStorage({\r\n                                key: sessionName,\r\n                                data: session\r\n                            })\r\n                        },\r\n                        complete: function () {\r\n                            obj.count--;\r\n                            typeof obj.complete === \"function\" && obj.count == 0 && obj.complete();\r\n                            logining = false;\r\n                            flow.emit('doLoginFinished');\r\n                        },\r\n                        fail: codeToSession.fail || null\r\n                    });\r\n                } else {\r\n                    fail(obj, res);\r\n                    console.error(res);\r\n                    // 登录失败，解除锁，防止死锁\r\n                    logining = false;\r\n                    flow.emit('doLoginFinished');\r\n                }\r\n            },\r\n            fail: function (res) {\r\n                fail(obj, res);\r\n                console.error(res);\r\n                // 登录失败，解除锁，防止死锁\r\n                logining = false;\r\n                flow.emit('doLoginFinished');\r\n            }\r\n        })\r\n    }\r\n}\r\n复制代码处理页面登陆交互的两种方式\r\n1. app.js 注册回掉函数，进入page 注册这个回掉函数，登陆完成执行app.logincallback\r\npage.js\r\nconst app = new getApp()\r\nonLoad(){\r\n    app.loginCallback = () => {\r\n        this.init()\r\n    }\r\n}\r\n\r\n复制代码这种方式可以，而且具有页面控制的灵活性，但灵活性带来的就是出错的几率会增大很多\r\n2. 在login页面获取登陆的前一个页面，然后登陆完成后刷新前一个页面状态\r\nlogin.js\r\n\r\nwerequest.login().then(function(){\r\n    let pages = getCurrentPages();\r\n    let Page = pages[pages.length - 1];//当前页\r\n    let prevPage = pages[pages.length - 2];  //上一个页面\r\n    prevPage.onLoad()\r\n})\r\n复制代码个人比较提交这种方式，因为其他页面只需要处理自己的页面逻辑就可以作者：liuzimu链接：https://juejin.im/post/5be53958e51d450b3647e7ae"}
{"title": "微信小程序之店铺评分组件及vue中用svg实现的评分显示组件 ", "author": "Rolan", "pub_time": "2018-11-19 00:32", "content": "1.效果图微信中的可以点击及显示，但是，显示的话，在4.2分，4点多分的时候，显示的是半颗星vue中用的是svg实现，所以用的是占比的形式,可以有一点点的星星星图片2.微信实现店铺评分显示及商品评价星星展示子组件index.wxml，可以动态的控制星星的大小<!-- (size * stars.length + (size/2) * 4 + 20 )这里的话，是在可以点击的时候，加上了好评的字体的长度 -->\r\n<view class='starsBox' style='width:{{isClick?(size * stars.length + (size/2) * 4 + 20 ):(size * stars.length)}}rpx;height:{{size}}rpx;'>\r\n  <view class='stars' style='width:{{size * stars.length}}rpx;height:{{size}}rpx;'>\r\n    <block wx:for=\"{{stars}}\" wx:key=\"{{index}}\">\r\n      <image src=\"/images/{{item == 0 ? 'grayStar':item}}.png\" style='width:{{size}}rpx;height:{{size}}rpx;' data-index=\"{{index}}\" catchtap=\"computeScore\"></image>\r\n    </block>\r\n  </view>\r\n  <view wx:if=\"{{isClick}}\" class='text' style='font-size:{{size/2}}rpx;'>\r\n    <text wx:if=\"{{value=='0'}}\" class='pointText'>暂无评分</text>\r\n    <text wx:elif=\"{{value=='1'}}\" class='pointText'>差评</text>\r\n    <text wx:elif=\"{{value<'4'}}\" class='pointText'>中评</text>\r\n    <text wx:else class='pointText'>好评</text>\r\n  </view>\r\n</view>子组件index.wxss.starsBox{\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: flex-start;\r\n}\r\n.stars{\r\n  width: 150rpx;\r\n  height: 50rpx;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: flex-start;\r\n}\r\n.stars image{\r\n  width: 30rpx;\r\n  height: 30rpx;\r\n}\r\n.text{\r\n  color: #ccc;\r\n  margin-left: 20rpx;\r\n}子组件index.jsComponent({\r\n  properties: {\r\n    /* 显示有色星星的个数 */\r\n    value: {\r\n      type: Number,\r\n      value: 0,\r\n      /* 监听value值的变化 */\r\n      observer: function (newVal, oldVal, changedPath) {\r\n        this.init()\r\n      }\r\n    },\r\n    /* 设置星星大小 */\r\n    size: {\r\n      type: Number,\r\n      value: 30\r\n    },\r\n    /* 是否可点击，type为null表示值可以是任意类型 */\r\n    isClick: {\r\n      type: null,\r\n      value: false\r\n    }\r\n  },\r\n  attached() {\r\n    /* 组件生命周期函数，在组件实例进入页面节点树时执行 */\r\n    this.init();\r\n  },\r\n  data: {\r\n    stars: [0, 0, 0, 0, 0]\r\n  },\r\n  methods: {\r\n    init() {\r\n      let star = this.properties.value;\r\n      let stars = [0, 0, 0, 0, 0];\r\n      /* 图片名称，通过设置图片名称来动态的改变图片显示 */\r\n      for (let i = 0; i < Math.floor(star); i++) {\r\n        stars[i] = 'star';\r\n      }\r\n      if (star > Math.floor(star)) {\r\n        stars[Math.floor(star)] = 'halfStar';\r\n      }\r\n      for (let i = 0; i < stars.length; i++) {\r\n        if (stars[i] == 0) {\r\n          stars[i] = 'grayStar';\r\n        }\r\n      }\r\n      this.setData({\r\n        stars\r\n      })\r\n    },\r\n    /* 可点击时，用于计算分数 */\r\n    computeScore(e) {\r\n      let index = e.currentTarget.dataset.index;\r\n      let isClick = this.data.isClick;\r\n      if (isClick) {\r\n        let score = index + 1;\r\n        this.triggerEvent('compute', {\r\n          score\r\n        });\r\n      }\r\n    }\r\n  }\r\n})3.父组件中引用父组件index.wxml<view class=\"score\">\r\n    <view class=\"scoreItem\">\r\n        <score value=\"{{shopGrade}}\" size=\"46\" isClick=\"true\" bindcompute=\"computeGrade\" />\r\n    </view>\r\n    <view class=\"scoreItem\">\r\n        <score value=\"{{shopGrade1}}\" size=\"46\" />    \r\n    </view>\r\n</view>父组件index.json{\r\n    \"usingComponents\": {\r\n        \"score\": \"/component/score/index\"\r\n    }\r\n}父组件index.jsdata: {\r\n    shopGrade: 0,\r\n    shopGrade1: 4.6,\r\n},\r\n/* 评分处理事件 */\r\ncomputeGrade(e) {\r\n    let score = e.detail.score;\r\n    this.setData({\r\n        shopGrade: score\r\n    })\r\n},4.vue中使用svg实现评分首先在vue使用的index.html的模板文件中添加一个rem转换算法，因为我后面用的单位是rem/* 在头部添加 */\r\n<script type=\"text/javascript\">\r\n      document.getElementsByTagName(\"html\")[0].style.fontSize = 100 / 750 * window.screen.width + \"px\";\r\n    </script>然后添加svg.vue文件，这个svg文件可以自己找图片生成，并设置对应的id<template>\r\n    <svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" style=\"position:absolute;width:0;height:0;visibility:hidden\">\r\n        <defs>\r\n            <symbol id=\"star\" viewBox=\"0 0 32 32\">\r\n                <path class=\"path1\" d=\"M16 26.382l-8.16 4.992c-1.5 0.918-2.382 0.264-1.975-1.435l2.226-9.303-7.269-6.218c-1.337-1.143-0.987-2.184 0.755-2.322l9.536-0.758 3.667-8.835c0.674-1.624 1.772-1.613 2.442 0l3.667 8.835 9.536 0.758c1.753 0.139 2.082 1.187 0.755 2.322l-7.269 6.218 2.226 9.303c0.409 1.71-0.485 2.347-1.975 1.435l-8.16-4.992z\">\r\n                </path>\r\n            </symbol>\r\n        </defs>\r\n    </svg>\r\n</template>\r\n<script></script>\r\n<style></style>rating.vue文件引用svg.vue<template>\r\n    <div class=\"ratingstar\">\r\n        <section class=\"star_container\">\r\n            <svg class=\"grey_fill\" v-for=\"(num,index) in 5\" :key=\"index\">\r\n                <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#star\"></use>\r\n            </svg>\r\n        </section>\r\n        <div class=\"star_overflow\" :style=\"'width:'+rating*2/10+'rem'\">\r\n            <section class=\"star_container\">\r\n                <svg class=\"orange_fill\" v-for=\"(num,index) in 5\" :key=\"index\">\r\n                    <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#star\"></use>\r\n                </svg>\r\n            </section>\r\n        </div>\r\n        <svgIcon></svgIcon>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n  import svgIcon from '@/components/svg'\r\n  export default {\r\n    components: {\r\n      svgIcon\r\n    },\r\n    data() {\r\n        return {\r\n            rating: 4.2\r\n        }\r\n    },\r\n  }\r\n</script>\r\n<style lang=\"less\" rel=\"stylesheet/less\" scoped>\r\n    .ratingstar {\r\n        position: relative;\r\n        width: 100%;\r\n        .star_overflow {\r\n            overflow: hidden;\r\n            position: relative;\r\n            height: 0.65rem;\r\n        }\r\n        .star_container {\r\n            position: absolute;\r\n            top: 0.05rem;\r\n            width: 1rem;\r\n            display: flex;\r\n            justify-content: flex-start;\r\n            align-items: center;\r\n            .grey_fill {\r\n                width: 0.94rem;\r\n                height: 0.2rem;\r\n                fill: #d1d1d1;\r\n            }\r\n            .orange_fill {\r\n                width: 0.94rem;\r\n                height: 0.2rem;\r\n                fill: #ff9a0d;\r\n            }\r\n        }\r\n    }\r\n</style>都有用到组件，可以查看下方的推荐文章中的购物车中的父子组件传值正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）往期好文推荐：判断iOS和Android及PC端实现单行文字及多行文字的省略号微信小程序之购物车和父子组件传值及calc的注意事项纯css实现瀑布流（multi-column多列及flex布局）"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "近两万字小程序攻略发布了 ", "author": "Rolan", "pub_time": "2018-9-6 00:21", "content": "该内容由银科控股融汇研发部曹俊及其团队授权提供。该团队拥有 10 多名小程序开发，深耕小程序领域，总结出了本篇优质长文。同时本篇内容也已经合并入我的 开源项目 中，目前项目内容包含了 JS、网络、浏览器相关、性能优化、安全、框架、Git、数据结构、算法等内容，无论是基础还是进阶，亦或是源码解读，你都能在本图谱中得到满意的答案，希望这个面试图谱能够帮助到大家更好的准备面试。小程序-登录unionid和openid了解小程序登陆之前，我们写了解下小程序/公众号登录涉及到两个最关键的用户标识：OpenId\r\nUnionId\r\n关键Apiwx.login 官方提供的登录能力wx.checkSession 校验用户当前的session_key是否有效wx.authorize 提前向用户发起授权请求wx.getUserInfo 获取用户基本信息登录流程设计以下从笔者接触过的几种登录流程来做阐述:利用现有登录体系直接复用现有系统的登录体系，只需要在小程序端设计用户名，密码/验证码输入页面，便可以简便的实现登录，只需要保持良好的用户体验即可。利用OpenId 创建用户体系:point_up_2:提过， OpenId 是一个小程序对于一个用户的标识，利用这一点我们可以轻松的实现一套基于小程序的用户体系，值得一提的是这种用户体系对用户的打扰最低，可以实现静默登录。具体步骤如下：小程序客户端通过 wx.login 获取 code传递 code 向服务端，服务端拿到 code 调用微信登录凭证校验接口，微信服务器返回 openid和会话密钥 session_key ，此时开发者服务端便可以利用 openid 生成用户入库，再向小程序客户端返回自定义登录态小程序客户端缓存 （通过 storage ）自定义登录态（token），后续调用接口时携带该登录态作为用户身份标识即可利用 Unionid 创建用户体系如果想实现多个小程序，公众号，已有登录系统的数据互通，可以通过获取到用户 unionid 的方式建立用户体系。因为 unionid 在同一开放平台下的所所有应用都是相同的，通过 unionid 建立的用户体系即可实现全平台数据的互通，更方便的接入原有的功能，那如何获取 unionid 呢，有以下两种方式：如果户关注了某个相同主体公众号，或曾经在某个相同主体App、公众号上进行过微信登录授权，通过 wx.login 可以直接获取 到 unionid结合 wx.getUserInfo 和 <button open-type=\"getUserInfo\"><button/> 这两种方式引导用户主动授权，主动授权后通过返回的信息和服务端交互 (这里有一步需要服务端解密数据的过程，很简单，微信提供了示例代码) 即可拿到 unionid 建立用户体系， 然后由服务端返回登录态，本地记录即可实现登录，附上微信提供的最佳实践：调用 wx.login 获取 code，然后从微信后端换取到 session_key，用于解密 getUserInfo返回的敏感数据。使用 wx.getSetting 获取用户的授权情况如果用户已经授权，直接调用 API wx.getUserInfo 获取用户最新的信息；用户未授权，在界面中显示一个按钮提示用户登入，当用户点击并授权后就获取到用户的最新信息。获取到用户数据后可以进行展示或者发送给自己的后端。注意事项需要获取 unionid 形式的登录体系，在以前（18年4月之前）是通过以下这种方式来实现，但后续微信做了调整（因为一进入小程序，主动弹起各种授权弹窗的这种形式，比较容易导致用户流失），调整为必须使用按钮引导用户主动授权的方式，这次调整对开发者影响较大，开发者需要注意遵守微信的规则，并及时和业务方沟通业务形式，不要存在侥幸心理，以防造成小程序不过审等情况。wx.login(获取code) ===> wx.getUserInfo(用户授权) ===> 获取 unionid\r\n复制代码因为小程序不存在 cookie 的概念， 登录态必须缓存在本地，因此强烈建议为登录态设置过期时间值得一提的是如果需要支持风控安全校验，多平台登录等功能，可能需要加入一些公共参数，例如platform，channel，deviceParam等参数。在和服务端确定方案时，作为前端同学应该及时提出这些合理的建议，设计合理的系统。openid ， unionid 不要在接口中明文传输，这是一种危险的行为，同时也很不专业。小程序-图片导出经常开发和使用小程序的同学对这个功能一定不陌生，这是一种常见的引流方式，一般同时会在图片中附加一个小程序二维码。基本原理借助 canvas 元素，将需要导出的样式首先在 canvas 画布上绘制出来 （api基本和h5保持一致，但有轻微差异，使用时注意即可）借助微信提供的 canvasToTempFilePath 导出图片，最后再使用 saveImageToPhotosAlbum（需要授权）保存图片到本地如何优雅实现根据上述的原理来看，实现是很简单的，只不过就是设计稿的提取，绘制即可，但是作为一个常用功能，每次都这样写一坨代码岂不是非常的难受。那小程序如何设计一个通用的方法来帮助我们导出图片呢？思路如下：绘制出需要的样式这一步是省略不掉的。但是我们可以封装一个绘制库，包含常见图形的绘制，例如矩形，圆角矩形，圆， 扇形， 三角形， 文字，图片减少绘制代码，只需要提炼出样式信息，便可以轻松的绘制，最后导出图片存入相册。笔者觉得以下这种方式绘制更为优雅清晰一些，其实也可以使用加入一个type参数来指定绘制类型，传入的一个是样式数组，实现绘制。结合上一步的实现，如果对于同一类型的卡片有多次导出需求的场景，也可以使用自定义组件的方式，封装同一类型的卡片为一个通用组件，在需要导出图片功能的地方，引入该组件即可。class CanvasKit {\r\n    constructor() {\r\n    }\r\n    drawImg(option = {}) {\r\n      ...\r\n      return this\r\n    }\r\n    drawRect(option = {}) {\r\n      return this\r\n    }\r\n    drawText(option = {}) {\r\n      ...\r\n      return this\r\n    }\r\n    static exportImg(option = {}) {\r\n      ...\r\n    }\r\n  }\r\n\r\n  let drawer = new CanvasKit('canvasId').drawImg(styleObj1).drawText(styleObj2)\r\n  drawer.exportImg()\r\n\r\n复制代码注意事项小程序中无法绘制网络图片到canvas上，需要通过downLoadFile 先下载图片到本地临时文件才可以绘制通常需要绘制二维码到导出的图片上，有一种方式导出二维码时，需要携带的参数必须做编码，而且有具体的长度（32可见字符）限制，可以借助服务端生成 短链接 的方式来解决小程序-数据统计数据统计作为目前一种常用的分析用户行为的方式，小程序端也是必不可少的。小程序采取的曝光，点击数据埋点其实和h5原理是一样的。但是埋点作为一个和业务逻辑不相关的需求，我们如果在每一个点击事件，每一个生命周期加入各种埋点代码，则会干扰正常的业务逻辑，和使代码变的臃肿，笔者提供以下几种思路来解决数据埋点：设计一个埋点sdk小程序的代码结构是，每一个 Page 中都有一个 Page 方法，接受一个包含生命周期函数，数据的 业务逻辑对象 包装这层数据，借助小程序的底层逻辑实现页面的业务逻辑。通过这个我们可以想到思路，对Page进行一次包装，篡改它的生命周期和点击事件，混入埋点代码，不干扰业务逻辑，只要做一些简单的配置即可埋点，简单的代码实现如下：代码仅供理解思路\r\n  page = function(params) {\r\n    let keys = params.keys()\r\n    keys.forEach(v => {\r\n        if (v === 'onLoad') {\r\n          params[v] = function(options) {\r\n            stat()   //曝光埋点代码\r\n            params[v].call(this, options)\r\n          }\r\n        }\r\n        else if (v.includes('click')) {\r\n          params[v] = funciton(event) { \r\n            let data = event.dataset.config\r\n            stat(data)  // 点击埋点\r\n            param[v].call(this)\r\n          }\r\n        }\r\n    })\r\n  }\r\n复制代码这种思路不光适用于埋点，也可以用来作全局异常处理，请求的统一处理等场景。分析接口对于特殊的一些业务，我们可以采取 接口埋点 ，什么叫接口埋点呢？很多情况下，我们有的api并不是多处调用的，只会在某一个特定的页面调用，通过这个思路我们可以分析出，该接口被请求，则这个行为被触发了，则完全可以通过服务端日志得出埋点数据，但是这种方式局限性较大，而且属于分析结果得出过程，可能存在误差，但可以作为一种思路了解一下。微信本身提供的数据分析能力，微信本身提供了常规分析和自定义分析两种数据分析方式，在小程序后台配置即可。借助 小程序数据助手 这款小程序可以很方便的查看。小程序-工程化工程化做什么目前的前端开发过程，工程化是必不可少的一环，那小程序工程化都需要做些什么呢，先看下目前小程序开发当中存在哪些问题需要解决：不支持 css预编译器,作为一种主流的 css解决方案，不论是 less,sass,stylus 都可以提升css效率不支持引入npm包 （这一条，从微信公开课中听闻，微信准备支持）不支持ES7等后续的js特性，好用的async await等特性都无法使用不支持引入外部字体文件，只支持base64没有 eslint 等代码检查工具方案选型对于目前常用的工程化方案，webpack，rollup，parcel等来看，都常用与单页应用的打包和处理，而小程序天生是 “多页应用” 并且存在一些特定的配置。根据要解决的问题来看，无非是文件的编译，修改，拷贝这些处理，对于这些需求，我们想到基于流的 gulp 非常的适合处理，并且相对于webpack配置多页应用更加简单。所以小程序工程化方案推荐使用 gulp具体开发思路通过 gulp 的 task 实现：实时编译 less 文件至相应目录引入支持async，await的运行时文件编译字体文件为base64 并生成相应css文件，方便使用依赖分析哪些地方引用了npm包，将npm包打成一个文件，拷贝至相应目录检查代码规范上述实现起来其实并不是很难，但是这样的话就是一份纯粹的 gulp 构建脚本和 约定好的目录而已，每次都有一个新的小程序都来拷贝这份脚本来处理吗？显然不合适，那如何真正的实现 小程序工程化 呢？ 我们可能需要一个简单的脚手架，脚手架需要支持的功能：支持新建项目，创建Page，创建Component支持内置构建脚本支持发布小程序，也可以想办法接入Jenkins等工具做持续集成 (小程序持续集成后面会提) ...小程序架构微信小程序的框架包含两部分 View 视图层、App Service逻辑层。View 层用来渲染页面结构，AppService 层用来逻辑处理、数据请求、接口调用。它们在 两个线程里 运行。它们在 两个线程里 运行。它们在 两个线程里 运行。视图层和逻辑层通过系统层的 JSBridage 进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。补充视图层使用 WebView 渲染，iOS 中使用自带 WKWebView，在 Android 使用腾讯的 x5 内核（基于 Blink）运行。逻辑层使用在 iOS 中使用自带的 JSCore 运行，在 Android 中使用腾讯的 x5 内核（基于 Blink）运行。开发工具使用 nw.js 同时提供了视图层和逻辑层的运行环境。在 Mac下 使用 js-beautify 对微信开发工具 @v1.02.1808080代码批量格式化：cd /Applications/wechatwebdevtools.app/Contents/Resources/package.nw\r\nfind . -type f -name '*.js' -not -path \"./node_modules/*\" -not -path -exec js-beautify -r -s 2 -p -f '{}' \\;\r\n复制代码在 js/extensions/appservice/index.js 中找到：267: function(a, b, c) {\r\n    const d = c(8),\r\n      e = c(227),\r\n      f = c(226),\r\n      g = c(228),\r\n      h = c(229),\r\n      i = c(230);\r\n    var j = window.__global.navigator.userAgent,\r\n      k = -1 !== j.indexOf('game');\r\n    k || i(), window.__global.getNewWeixinJSBridge = (a) => {\r\n      const {\r\n        invoke: b\r\n      } = f(a), {\r\n        publish: c\r\n      } = g(a), {\r\n        subscribe: d,\r\n        triggerSubscribeEvent: i\r\n      } = h(a), {\r\n        on: j,\r\n        triggerOnEvent: k\r\n      } = e(a);\r\n      return {\r\n        invoke: b,\r\n        publish: c,\r\n        subscribe: d,\r\n        on: j,\r\n        get __triggerOnEvent() {\r\n          return k\r\n        },\r\n        get __triggerSubscribeEvent() {\r\n          return i\r\n        }\r\n      }\r\n    }, window.WeixinJSBridge = window.__global.WeixinJSBridge = window.__global.getNewWeixinJSBridge('global'), window.__global.WeixinJSBridgeMap = {\r\n      __globalBridge: window.WeixinJSBridge\r\n    }, __devtoolsConfig.online && __devtoolsConfig.autoTest && setInterval(() => {\r\n      console.clear()\r\n    }, 1e4);\r\n    try {\r\n      var l = new window.__global.XMLHttpRequest;\r\n      l.responseType = 'text', l.open('GET', `http://${window.location.host}/calibration/${Date.now()}`, !0), l.send()\r\n    } catch (a) {}\r\n  }\r\n复制代码在 js/extensions/gamenaitveview/index.js 中找到：299: function(a, b, c) {\r\n    'use strict';\r\n    Object.defineProperty(b, '__esModule', {\r\n      value: !0\r\n    });\r\n    var d = c(242),\r\n      e = c(241),\r\n      f = c(243),\r\n      g = c(244);\r\n    window.WeixinJSBridge = {\r\n      on: d.a,\r\n      invoke: e.a,\r\n      publish: f.a,\r\n      subscribe: g.a\r\n    }\r\n  },\r\n复制代码在 js/extensions/pageframe/index.js 中找到：317: function(a, b, c) {\r\n    'use strict';\r\n\r\n    function d() {\r\n      window.WeixinJSBridge = {\r\n        on: e.a,\r\n        invoke: f.a,\r\n        publish: g.a,\r\n        subscribe: h.a\r\n      }, k.a.init();\r\n      let a = document.createEvent('UIEvent');\r\n      a.initEvent('WeixinJSBridgeReady', !1, !1), document.dispatchEvent(a), i.a.init()\r\n    }\r\n    Object.defineProperty(b, '__esModule', {\r\n      value: !0\r\n    });\r\n    var e = c(254),\r\n      f = c(253),\r\n      g = c(255),\r\n      h = c(256),\r\n      i = c(86),\r\n      j = c(257),\r\n      k = c.n(j);\r\n    'complete' === document.readyState ? d() : window.addEventListener('load', function() {\r\n      d()\r\n    })\r\n  },\r\n复制代码我们都看到了 WeixinJSBridge 的定义。分别都有 on 、 invoke 、 publish 、 subscribe 这个几个关键方法。拿 invoke 举例，在 js/extensions/appservice/index.js 中发现这段代码：f (!r) p[b] = s, f.send({\r\n    command: 'APPSERVICE_INVOKE',\r\n    data: {\r\n        api: c,\r\n        args: e,\r\n        callbackID: b\r\n    }\r\n});\r\n复制代码在 js/extensions/pageframe/index.js 中发现这段代码：g[d] = c, e.a.send({\r\n    command: 'WEBVIEW_INVOKE',\r\n    data: {\r\n        api: a,\r\n        args: b,\r\n        callbackID: d\r\n    }\r\n})\r\n\r\n复制代码简单的分析得知：字段 command 用来区分行为， invoke 用来调用 Native 的 Api。在不同的来源要使用不同的前缀。 data 里面包含 Api 名，参数。另外 callbackID 指定接受回调的方法句柄。Appservice 和 Webview 使用的通信协议是一致的。我们不能在代码里使用 BOM 和 DOM 是因为根本没有，另一方面也不希望 JS 代码直接操作视图。在开发工具中 remote-helper.js 中找到了这样的代码：const vm = require(\"vm\");\r\n\r\nconst vmGlobal = {\r\n    require: undefined,\r\n    eval: undefined,\r\n    process: undefined,\r\n    setTimeout(...args) {\r\n        //...省略代码\r\n        return timerCount;\r\n    },\r\n    clearTimeout(id) {\r\n        const timer = timers[id];\r\n        if (timer) {\r\n            clearTimeout(timer);\r\n            delete timers[id];\r\n        }\r\n    },\r\n    setInterval(...args) {\r\n        //...省略代码\r\n        return timerCount;\r\n    },\r\n    clearInterval(id) {\r\n        const timer = timers[id];\r\n        if (timer) {\r\n            clearInterval(timer);\r\n            delete timers[id];\r\n        }\r\n    },\r\n    console: (() => {\r\n        //...省略代码\r\n        return consoleClone;\r\n    })()\r\n};\r\nconst jsVm = vm.createContext(vmGlobal);\r\n// 省略大量代码...\r\nfunction loadCode(filePath, sourceURL, content) {\r\n    let ret;\r\n    try {\r\n        const script = typeof content === 'string' ? content : fs.readFileSync(filePath, 'utf-8').toString();\r\n        ret = vm.runInContext(script, jsVm, {\r\n            filename: sourceURL,\r\n        });\r\n    }\r\n    catch (e) {\r\n        // something went wrong in user code\r\n        console.error(e);\r\n    }\r\n    return ret;\r\n}\r\n复制代码这样的分层设计显然是有意为之的，它的中间层完全控制了程序对于界面进行的操作， 同时对于传递的数据和响应时间也能做到监控。一方面程序的行为受到了极大限制， 另一方面微信可以确保他们对于小程序内容和体验有绝对的控制。这样的结构也说明了小程序的动画和绘图 API 被设计成生成一个最终对象而不是一步一步执行的样子， 原因就是 Json 格式的数据传递和解析相比与原生 API 都是损耗不菲的，如果频繁调用很可能损耗过多性能，进而影响用户体验。下载小程序完整包App Service - Life Cylce面试题1.动画需要绑定在 data 上，而绘图却不用。你觉得是为什么呢？var context = wx.createCanvasContext('firstCanvas')\r\n    \r\ncontext.setStrokeStyle(\"#00ff00\")\r\ncontext.setLineWidth(5)\r\ncontext.rect(0, 0, 200, 200)\r\ncontext.stroke()\r\ncontext.setStrokeStyle(\"#ff0000\")\r\ncontext.setLineWidth(2)\r\ncontext.moveTo(160, 100)\r\ncontext.arc(100, 100, 60, 0, 2 * Math.PI, true)\r\ncontext.moveTo(140, 100)\r\ncontext.arc(100, 100, 40, 0, Math.PI, false)\r\ncontext.moveTo(85, 80)\r\ncontext.arc(80, 80, 5, 0, 2 * Math.PI, true)\r\ncontext.moveTo(125, 80)\r\ncontext.arc(120, 80, 5, 0, 2 * Math.PI, true)\r\ncontext.stroke()\r\ncontext.draw()\r\n复制代码Page({\r\n  data: {\r\n    animationData: {}\r\n  },\r\n  onShow: function(){\r\n    var animation = wx.createAnimation({\r\n      duration: 1000,\r\n  \t  timingFunction: 'ease',\r\n    })\r\n\r\n    this.animation = animation\r\n    \r\n    animation.scale(2,2).rotate(45).step()\r\n    \r\n    this.setData({\r\n      animationData:animation.export()\r\n    })\r\n  }\r\n})\r\n复制代码2.小程序的 Http Rquest 请求是不是用的浏览器 Fetch API?知识点考察知道 Request 是由 Native 实现的JSCore 是不带 Http Request、Websocket、Storage等功能的，那是 Webkit 带的小程序的 wx.request 是不是遵循 fetch API 规范实现的呢？答案，显然不是。因为没有 PromiseView - WXMLWXML（WeiXin Markup Language）支持数据绑定支持逻辑算术、运算支持模板、引用支持添加事件（bindtap）Wxml编译器：Wcc 把 Wxml文件 转为 JS执行方式：Wcc index.wxml使用 Virtual DOM，进行局部更新View - WXSSWXSS(WeiXin Style Sheets)wxss编译器：wcsc 把wxss文件转化为 js执行方式： wcsc index.wxss支持大部分CSS特性亲测包含但不限于如下内容：TransitionAnimationKeyframesborder-radiuscalc()选择器，除了官方文档列出的，其实还支持element>elementelement+elementelement elementelement:first-letterelement:first-lineelement:first-childelement:last-childelement~elementelement:first-of-typeelement:last-of-typeelement:only-of-typeelement:only-childelement:nth-child(n)element:nth-last-child(n)element:nth-of-type(n)element:nth-last-of-type(n):rootelement:empty:not(element)iconfont建议 Css3 的特性都可以做一下尝试。尺寸单位 rpxrpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx。公式：const dsWidth = 750\r\n\r\nexport const screenHeightOfRpx = function () {\r\n  return 750 / env.screenWidth * env.screenHeight\r\n}\r\n\r\nexport const rpxToPx = function (rpx) {\r\n  return env.screenWidth / 750 * rpx\r\n}\r\n\r\nexport const pxToRpx = function (px) {\r\n  return 750 / env.screenWidth * px\r\n}\r\n\r\n复制代码可以了解一下 pr2rpx-loader 这个库。样式导入使用 @import 语句可以导入外联样式表， @import 后跟需要导入的外联样式表的相对路径，用 ; 表示语句结束。内联样式静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析， 请尽量避免将静态的样式写进 style 中，以免影响渲染速度 。全局样式与局部样式定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。iconfont截止20180810小程序未来有计划支持字体。参考微信公开课。小程序开发与平时 Web开发类似，也可以使用字体图标，但是 src:url() 无论本地还是远程地址都不行，base64 值则都是可以显示的。将 ttf 文件转换成 base64。打开这个平台 transfonter.org/。点击 Add fonts 按钮，加载ttf格式的那个文件。将下边的 base64 encode 改为 on。点击 Convert 按钮进行转换，转换后点击 download 下载。复制下载的压缩文件中的 stylesheet.css 的内容到 font.wxss ，并且将 icomoon 中的 style.css 除了 @font-face 所有的代码也复制到 font.wxss 并将i选择器换成 .iconfont，最后：<text class=\"iconfont icon-home\" style=\"font-size:50px;color:red\"></text>\r\n复制代码View - Component小程序提供了一系列组件用于开发业务功能，按照功能与HTML5的标签进行对比如下：小程序的组件基于Web Component标准使用Polymer框架实现Web ComponentView - Native Component目前Native实现的组件有cavnasvideomaptextareaNative组件层在 WebView 层之上。这目前带来了一些问题：Native 实现的组件会遮挡其他组件WebView 渲染出来的视图在滚动时，Native 实现的组件需要更新位置，这会带来性能问题，在安卓机器上比较明显小程序原生组件 cover-view 可以覆盖 cavnas video 等，但是也有一下弊端，比如在 cavnas 上覆盖 cover-view ，就会发现坐标系不统一处理麻烦目前小程序的问题或限制截止20180810包含但不限于：小程序仍然使用 WebView 渲染，并非原生渲染。（部分原生）服务端接口返回的头无法执行，比如：Set-Cookie。依赖浏览器环境的 JS 库不能使用。不能使用 npm，但是可以自搭构建工具或者使用 mpvue。（未来官方有计划支持）不能使用 ES7，可以自己用babel+webpack自搭或者使用 mpvue。不支持使用自己的字体（未来官方计划支持）。可以用 base64 的方式来使用 iconfont。小程序不能发朋友圈（可以通过保存图片到本地，发图片到朋友前。二维码可以使用B接口）。获取二维码/小程序接口的限制。B 接口 scene 最大32个可见字符。AC 接口总共生成的码数量限制为 100,000，请谨慎调用。真机扫描二维码只能跳转到线上版本，所以测试环境下只可通过开发者工具的通过二维码编译进行调试。没有发布到线上版本的小程序页面路径会导致生成二维码失败，需要先将添加了页面的小程序发布到线上版本。小程序推送只能使用“服务通知” 而且需要用户主动触发提交 formId，formId 只有7天有效期。（现在的做法是在每个页面都放入form并且隐藏以此获取更多的 formId。后端使用原则为：优先使用有效期最短的）小程序大小限制 2M，分包总计不超过 8M转发（分享）小程序不能拿到成功结果，原来可以。链接（小游戏造的孽）拿到相同的 unionId 必须绑在同一个开放平台下。开放平台绑定限制：50个移动应用10个网站50个同主体公众号5个不同主体公众号50个同主体小程序5个不同主体小程序公众号关联小程序，链接所有公众号都可以关联小程序。一个公众号可关联10个同主体的小程序，3个不同主体的小程序。一个小程序可关联500个公众号。公众号一个月可新增关联小程序13次，小程序一个月可新增关联500次。一个公众号关联的10个同主体小程序和3个非同主体小程序可以互相跳转品牌搜索不支持金融、医疗小程序授权需要用户主动点击小程序不提供测试 access_token安卓系统下，小程序授权获取用户信息之后，删除小程序再重新获取，并重新授权，得到旧签名，导致第一次授权失败开发者工具上，授权获取用户信息之后，如果清缓存选择全部清除，则即使使用了wx.checkSession，并且在session_key有效期内，授权获取用户信息也会得到新的session_key小程序HTTP2支持情况HTTP2支持情况：模拟器与真机均不支持为了验证小程序对HTTP的支持适配情况，我找了两个服务器做测试，一个是网上搜索到支持HTTP2的服务器，一个是我本地起的一个HTTP2服务器。测试中所有请求方法均使用 wx.request。网上支持HTTP2的服务器： HTTPs://www.snel.com:443在Chrome上查看该服务器为 HTTP2在模拟器上请求该接口， 请求头 的HTTP版本为HTTP1.1，模拟器不支持HTTP2由于小程序线上环境需要在项目管理里配置请求域名，而这个域名不是我们需要的请求域名，没必要浪费一个域名位置，所以打开不验证域名，TSL 等选项请求该接口，通过抓包工具表现与模拟器相同HTTP2服务器需要对小程序做兼容性适配由上可以看出，在真机与模拟器都不支持 HTTP2，但是都是成功请求的，并且 响应头 里的 HTTP 版本都变成了HTTP1.1 版本，说明服务器对 HTTP1.1 做了兼容性适配。本地新启一个 node 服务器，返回 JSON 为请求的 HTTP 版本如果服务器只支持 HTTP2，在模拟器请求时发生了一个 ALPN 协议的错误。并且提醒使用适配 HTTP1当把服务器的 allowHTTP1 ，设置为 true ，并在请求时处理相关相关请求参数后，模拟器能正常访问接口，并打印出对应的 HTTP 请求版本授权获取用户信息流程session_key 有有效期，有效期并没有被告知开发者，只知道用户越频繁使用小程序，session_key 有效期越长在调用 wx.login 时会直接更新 session_key，导致旧 session_key 失效小程序内先调用 wx.checkSession 检查登录态，并保证没有过期的 session_key 不会被更新，再调用 wx.login 获取 code。接着用户授权小程序获取用户信息，小程序拿到加密后的用户数据，把加密数据和 code 传给后端服务。后端通过 code 拿到 session_key 并解密数据，将解密后的用户信息返回给小程序面试题：先授权获取用户信息再 login 会发生什么？用户授权时，开放平台使用旧的 session_key 对用户信息进行加密。调用 wx.login 重新登录，会刷新 session_key，这时后端服务从开放平台获取到新 session_key，但是无法对老 session_key 加密过的数据解密，用户信息获取失败在用户信息授权之前先调用 wx.checkSession 呢？wx.checkSession 检查登录态，并且保证 wx.login 不会刷新 session_key，从而让后端服务正确解密数据。但是这里存在一个问题，如果小程序较长时间不用导致 session_key 过期，则 wx.login 必定会重新生成 session_key，从而再一次导致用户信息解密失败。性能优化我们知道view部分是运行在webview上的，所以前端领域的大多数优化方式都有用。我们知道view部分是运行在webview上的，所以前端领域的大多数优化方式都有用。我们知道view部分是运行在webview上的，所以前端领域的大多数优化方式都有用。加载优化代码包的大小是最直接影响小程序加载启动速度的因素。代码包越大不仅下载速度时间长，业务代码注入时间也会变长。所以最好的优化方式就是减少代码包的大小。小程序加载的三个阶段的表示。优化方式代码压缩。及时清理无用代码和资源文件。减少代码包中的图片等资源文件的大小和数量。分包加载。首屏加载的体验优化建议提前请求: 异步数据请求不需要等待页面渲染完成。利用缓存: 利用 storage API 对异步请求数据进行缓存，二次启动时先利用缓存数据渲染页面，在进行后台更新。避免白屏：先展示页面骨架页和基础内容。及时反馈：即时地对需要用户等待的交互操作给出反馈，避免用户以为小程序无响应。使用分包加载优化在构建小程序分包项目时，构建会输出一个或多个功能的分包，其中每个分包小程序必定含有一个主包，所谓的主包，即放置默认启动页面/TabBar 页面，以及一些所有分包都需用到公共资源/JS 脚本，而分包则是根据开发者的配置进行划分。在小程序启动时，默认会下载主包并启动主包内页面，如果用户需要打开分包内某个页面，客户端会把对应分包下载下来，下载完成后再进行展示。优点：对开发者而言，能使小程序有更大的代码体积，承载更多的功能与服务对用户而言，可以更快地打开小程序，同时在不影响启动速度前提下使用更多功能限制：整个小程序所有分包大小不超过 8M单个分包/主包大小不能超过 2M原生分包加载的配置假设支持分包的小程序目录结构如下：├── app.js\r\n├── app.json\r\n├── app.wxss\r\n├── packageA\r\n│   └── pages\r\n│       ├── cat\r\n│       └── dog\r\n├── packageB\r\n│   └── pages\r\n│       ├── apple\r\n│       └── banana\r\n├── pages\r\n│   ├── index\r\n│   └── logs\r\n└── utils\r\n\r\n复制代码开发者通过在 app.json subPackages 字段声明项目分包结构：{\r\n  \"pages\":[\r\n    \"pages/index\",\r\n    \"pages/logs\"\r\n  ],\r\n  \"subPackages\": [\r\n    {\r\n      \"root\": \"packageA\",\r\n      \"pages\": [\r\n        \"pages/cat\",\r\n        \"pages/dog\"\r\n      ]\r\n    }, {\r\n      \"root\": \"packageB\",\r\n      \"pages\": [\r\n        \"pages/apple\",\r\n        \"pages/banana\"\r\n      ]\r\n    }\r\n  ]\r\n}\r\n\r\n复制代码分包原则声明 subPackages 后，将按 subPackages 配置路径进行打包，subPackages 配置路径外的目录将被打包到 app（主包） 中app（主包）也可以有自己的 pages（即最外层的 pages 字段subPackage 的根目录不能是另外一个 subPackage 内的子目录首页的 TAB 页面必须在 app（主包）内引用原则packageA 无法 require packageB JS 文件，但可以 require app、自己 package 内的 JS 文件packageA 无法 import packageB 的 template，但可以 require app、自己 package 内的 templatepackageA 无法使用 packageB 的资源，但可以使用 app、自己 package 内的资源官方即将推出分包预加载独立分包渲染性能优化每次 setData 的调用都是一次进程间通信过程，通信开销与 setData 的数据量正相关。setData 会引发视图层页面内容的更新，这一耗时操作一定时间中会阻塞用户交互。setData 是小程序开发使用最频繁，也是最容易引发性能问题的。避免不当使用 setData使用 data 在方法间共享数据， 可能增加 setData 传输的数据量。 。data 应仅包括与页面渲染相关的数据。使用 setData 传输大量数据，**通讯耗时与数据正相关，页面更新延迟可能造成页面更新开销增加。**仅传输页面中发生变化的数据，使用 setData 的特殊 key 实现局部更新。短时间内频繁调用 setData，**操作卡顿，交互延迟，阻塞通信，页面渲染延迟。**避免不必要的 setData，对连续的setData调用进行合并。在后台页面进行 setData，**抢占前台页面的渲染资源。**页面切入后台后的 setData 调用，延迟到页面重新展示时执行。避免不当使用onPageScroll只在有必要的时候监听 pageScroll 事件。不监听，则不会派发。避免在 onPageScroll 中执行复杂逻辑避免在 onPageScroll 中频繁调用 setData避免滑动时频繁查询节点信息（SelectQuery）用以判断是否显示，部分场景建议使用节点布局橡胶状态监听（inersectionObserver）替代使用自定义组件在需要频繁更新的场景下，自定义组件的更新只在组件内部进行，不受页面其他部分内容复杂性影响。官方小程序技术能力规划自定义组件2.0小程序的几个页面间，存在一些相同或是类似的区域，这时候可以把这些区域逻辑封装成一个自定义组件，代码就可以重用，或者对于比较独立逻辑，也可以把它封装成一个自定义组件，也就是微信去年发布的自定义组件，它让代码得到复用、减少代码量，更方便模块化，优化代码架构组织，也使得模块清晰，后期更好地维护，从而保证更好的性能。但微信打算在原来的基础上推出的自定义组件 2.0，它将拥有更高级的性能：usingComponents 计划支持全局定义和通配符定义：这意味着不用在每个页面反复定义，可以批量导入目录下的所有自定义组件计划支持类似 Computed 和 watch 的功能，它能使代码逻辑更清晰计划支持 Component 构造器插件，在实例化一个自定义组件的时候，允许你在构造器的这个阶段，加入一些逻辑，方便进行一些扩展，甚至是可以扩展成 Vue 的语法npm支持目前小程序开发的痛点是：开源组件要手动复制到项目，后续更新组件也需要手动操作。不久的将来，小程序将支持npm包管理，有了这个之后，想要引入一些开源的项目就变得很简单了，只要在项目里面声明，然后用简单的命令安装，就可以使用了。官方自定义组件微信小程序团队表示，他们在考虑推出一些官方自定义组件，为什么不内置到基础库里呢？因为内置组件要提供给开发者，这个组件一定是开发者很难实现或者是无法实现的一个能力。所以他们更倾向于封装成自定义组件，想基于这些内置组件里，封装一些比较常见的、交互逻辑比较复杂的组件给大家使用，让大家更容易开发。类似弹幕组件，开发者就不用关注弹幕怎么飘，可以节省开发者的开发成本。同时，他们也想给开发者提供一些规范和一些模板，让开发者设计出好用的自定义组件，更好地被大家去使用。添加体验评分当小程序加载太慢时，可能会导致用户的流失，而小程序的开发者可能会面临着不知道如何定位问题或不知如何解决问题的困境。为此，小程序即将推出一个体验评分的功能，这是为了帮助开发者可以检查出小程序有一些什么体验不好的地方，也会同时给出一份优化的指引建议。原生组件同层渲染小程序在最初的技术选型时，引入了原生组件的概念，因为原生组件可以使小程序的能力更加丰富，比如地图、音视频的能力，但是原生组件是由客户端原生渲染的，导致了原生组件的层级是最高的，开发者很容易遇到打开调试的问题，发现视频组件挡在了 vConsole 上。为了解决这个问题，当时微信做了一个过渡的方案：cover-view。cover-view可以覆盖在原生组件之上，这一套方案解决了大部分的需求场景。比如说视频组件上很多的按钮、标题甚至还有动画的弹幕，这些都是用 cover-view 去实现的，但它还是没有完全解决原生组件的开发体验问题，因为 cover-view 有一些限制：无法与其他组件混在一起渲染没有完整的触摸事件cover-view 对样式的表现有差异cover-view 对样式的支持度不够高因此微信决定将用同层渲染取代 cover-view，它能像普通组件一样使用，原生组件的层级不再是最高，而是和其他的非原生组件在同一层级渲染，可完全由 z-index 控制，可完全支持触摸事件。微信表示，同层渲染在 iOS 平台小程序上已经开始内测，会很快开放给开发者，Android 平台已经取得突破性进展，目前正在做一轮封装的工作，开放指日可待。wepy vs mpvue数据流管理相比传统的小程序框架，这个一直是我们作为资深开发者比较期望去解决的，在 Web 开发中，随着 Flux、Redux、Vuex 等多个数据流工具出现，我们也期望在业务复杂的小程序中使用。WePY 默认支持 Redux，在脚手架生成项目的时候可以内置Mpvue 作为 Vue 的移植版本，当然支持 Vuex，同样在脚手架生成项目的时候可以内置组件化如果你和我们一样，经历了从无到有的小程序业务开发，建议阅读【小程序的组件化开发】章节，进行官方语法的组件库开发（从基础库 1.6.3 开始，官方提供了组件化解决方案）。WePY 类似 Vue 实现了单文件组件，最大的差别是文件后缀 .wpy，只是写法上会有差异，具体可以查看【主流框架使用案例 1：WePY】章节，学习起来有一定成本，不过也会很快适应：export default class Index extends wepy.page {}\r\n复制代码Mpvue 作为 Vue 的移植版本，支持单文件组件，template、script 和 style 都在一个 .vue 文件中，和 vue 的写法类似，所以对 Vue 开发熟悉的同学会比较适应。工程化所有的小程序开发依赖官方提供的开发者工具。开发者工具简单直观，对调试小程序很有帮助，现在也支持腾讯云（目前我们还没有使用，但是对新的一些开发者还是有帮助的），可以申请测试报告查看小程序在真实的移动设备上运行性能和运行效果，但是它本身没有类似前端工程化中的概念和工具。wepy 内置了构建，通过 wepy init 命令初始化项目，大致流程如下：wepy-cli 会判断模版是在远程仓库还是在本地，如果在本地则会立即跳到第 3 步，反之继续进行。会从远程仓库下载模版，并保存到本地。询问开发者 Project name 等问题，依据开发者的回答，创建项目。mpvue 沿用了 vue 中推崇的 webpack 作为构建工具，但同时提供了一些自己的插件以及配置文件的一些修改，比如：不再需要 html-webpack-plugin基于 webpack-dev-middleware 修改成 webpack-dev-middleware-hard-disk最大的变化是基于 webpack-loader 修改成 mpvue-loader但是配置方式还是类似，分环境配置文件，最终都会编译成小程序支持的目录结构和文件后缀。综合比较选型的个人看法先说结论：选择 mpvue。wepy vs mpvue。理由：工程化原生开发因为不带工程化，诸如NPM包（未来会引入）、ES7、图片压缩、PostCss、pug、ESLint等等不能用。如果自己要搭工程化，不如直接使用wepy或mpvue。mpvue和wepy都可以和小程序原生开发混写。， 参考wepy 。 而问题在于wepy没有引入webpack(wepy@2.0.x依然没有引入)，以上说的这些东西都要造轮子（作者造或自己造）。没有引入 Webpack 是一个重大的硬伤。社区维护的成熟 Webpack 显然更稳定，轮子更多。维护wepy 也是社区维护的，是官方的？其实 wepy 的主要开发者只有作者一人，附上一个 contrubutors 链接。另外被官方招安了也是后来的事，再说腾讯要有精力帮着一起维护好 wepy，为什么不花精力在小程序原生开发上呢？再来看看 mpvue，是美团一个前端小组维护的。学习成本Vue 的学习曲线比较平缓。mpvue 是 Vue的子集。所以 mpvue 的学习成本会低于 wepy。尤其是之前技术栈有学过用过 Vue 的。未来规划mpvue 已经支持 web 和小程序。因为 mpvue 基于AST，所以未来可以支持支付宝小程序和快应用。他们也是有这样的规划。请在需求池下面自己找坑两者都有各自的坑。但是我觉得有一些wepy的坑是没法容忍的。比如 repeat组建里面用computed得到的列表全是同一套数据 而且1.x是没法解决的。 wepy和mpvue我都开发过完整小程序的体验下，我觉得wepy的坑更多，而且wepy有些坑碍于架构设计没办法解决。mpvueVue.js 小程序版, fork 自 vuejs/vue@2.4.1，保留了 vue runtime 能力，添加了小程序平台的支持。 mpvue 是一个使用 Vue.js 开发小程序的前端框架。框架基于 Vue.js 核心， mpvue 修改了 Vue.js 的 runtime 和 compiler 实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套 Vue.js 开发体验。框架原理两个大方向mpvue\r\nmpvue-loader\r\n七个具体问题要了解 mpvue 原理必然要了解 Vue 原理，这是大前提。但是要讲清楚 Vue 原理需要花费大量的篇幅，不如参考 learnVue 。现在假设您对 Vue 原理有个大概的了解。由于 Vue 使用了 Virtual DOM，所以 Virtual DOM 可以在任何支持 JavaScript 语言的平台上操作，譬如说目前 Vue 支持浏览器平台或 weex，也可以是 mp(小程序)。那么最后 Virtual DOM 如何映射到真实的 DOM 节点上呢？vue为平台做了一层适配层，浏览器平台见 runtime/node-ops.js 、weex平台见 runtime/node-ops.js ，小程序见 runtime/node-ops.js 。不同平台之间通过适配层对外提供相同的接口，Virtual DOM进行操作Real DOM节点的时候，只需要调用这些适配层的接口即可，而内部实现则不需要关心，它会根据平台的改变而改变。所以思路肯定是往增加一个 mp 平台的 runtime 方向走。但问题是小程序不能操作 DOM，所以 mp 下的 node-ops.js 里面的实现都是直接 return obj 。新 Virtual DOM 和旧 Virtual DOM 之间需要做一个 patch，找出 diff。patch完了之后的 diff 怎么更新视图，也就是如何给这些 DOM 加入 attr、class、style 等 DOM 属性呢？ Vue 中有 nextTick 的概念用以更新视图，mpvue这块对于小程序的 setData 应该怎么处理呢？另外个问题在于小程序的 Virtual DOM 怎么生成？也就是怎么将 template 编译成 render function 。这当中还涉及到 运行时-编译器-vs-只包含运行时 ，显然如果要提高性能、减少包大小、输出 wxml、mpvue 也要提供预编译的能力。因为要预输出 wxml 且没法动态改变 DOM，所以动态组件，自定义 render，和 <script type=\"text/x-template\"> 字符串模版等都不支持(参考)。另外还有一些其他问题，最后总结一下render function\r\nplatform/mp的目录结构.\r\n├── compiler //解决问题1，mpvue-template-compiler源码部分\r\n├── runtime //解决问题3 4 5 6 7\r\n├── util //工具方法\r\n├── entry-compiler.js //mpvue-template-compiler的入口。package.json相关命令会自动生成mpvue-template-compiler这个package。\r\n├── entry-runtime.js //对外提供Vue对象，当然是mpvue\r\n└── join-code-in-build.js //编译出SDK时的修复\r\n复制代码后面的内容逐步解答这几个问题，也就弄明白了原理mpvue-loadermpvue-loader 是 vue-loader 的一个扩展延伸版，类似于超集的关系，除了 vue-loader 本身所具备的能力之外，它还会利用 mpvue-template-compiler 生成 render function 。entry它会从 webpack 的配置中的 entry 开始，分析依赖模块，并分别打包。在entry 中 app 属性及其内容会被打包为微信小程序所需要的 app.js／app.json／app.wxss，其余的会生成对应的页面page.js/page.json/page.wxml/page.wxss，如示例的 entry 将会生成如下这些文件，文件内容下文慢慢讲来：// webpack.config.js\r\n{\r\n    // ...\r\n    entry: {\r\n        app: resolve('./src/main.js'),               // app 字段被识别为 app 类型\r\n        index: resolve('./src/pages/index/main.js'),   // 其余字段被识别为 page 类型\r\n        'news/home': resolve('./src/pages/news/home/index.js')\r\n    }\r\n}\r\n\r\n// 产出文件的结构\r\n.\r\n├── app.js\r\n├── app.json\r\n├──· app.wxss\r\n├── components\r\n│   ├── card$74bfae61.wxml\r\n│   ├── index$023eef02.wxml\r\n│   └── news$0699930b.wxml\r\n├── news\r\n│   ├── home.js\r\n│   ├── home.wxml\r\n│   └── home.wxss\r\n├── pages\r\n│   └── index\r\n│       ├── index.js\r\n│       ├── index.wxml\r\n│       └── index.wxss\r\n└── static\r\n    ├── css\r\n    │   ├── app.wxss\r\n    │   ├── index.wxss\r\n    │   └── news\r\n    │       └── home.wxss\r\n    └── js\r\n        ├── app.js\r\n        ├── index.js\r\n        ├── manifest.js\r\n        ├── news\r\n        │   └── home.js\r\n        └── vendor.js\r\n复制代码wxml 每一个 .vue 的组件都会被生成为一个 wxml 规范的 template，然后通过 wxml 规范的 import 语法来达到一个复用，同时组件如果涉及到 props 的 data 数据，我们也会做相应的处理，举个实际的例子：<template>\r\n    <div class=\"my-component\" @click=\"test\">\r\n        <h1>{{msg}}</h1>\r\n        <other-component :msg=\"msg\"></other-component>\r\n    </div>\r\n</template>\r\n<script>\r\nimport otherComponent from './otherComponent.vue'\r\n\r\nexport default {\r\n  components: { otherComponent },\r\n  data () {\r\n    return { msg: 'Hello Vue.js!' }\r\n  },\r\n  methods: {\r\n    test() {}\r\n  }\r\n}\r\n</script>\r\n复制代码这样一个 Vue 的组件的模版部分会生成相应的 wxml<import src=\"components/other-component$hash.wxml\" />\r\n<template name=\"component$hash\">\r\n    <view class=\"my-component\" bindtap=\"handleProxy\">\r\n        <view class=\"_h1\">{{msg}}</view>\r\n        <template is=\"other-component$hash\" wx:if=\"{{ $c[0] }}\" data=\"{{ ...$c[0] }}\"></template>\r\n    </view>\r\n</template>\r\n复制代码可能已经注意到了 other-component(:msg=\"msg\") 被转化成了 。mpvue 在运行时会从根组件开始把所有的组件实例数据合并成一个树形的数据，然后通过 setData 到 appData, $c 是 $children 的缩写。至于那个 0 则是我们的 compiler 处理过后的一个标记，会为每一个子组件打一个特定的不重复的标记。 树形数据结构如下：// 这儿数据结构是一个数组，index 是动态的\r\n{\r\n  $child: {\r\n    '0'{\r\n      // ... root data\r\n      $child: {\r\n        '0': {\r\n          // ... data\r\n          msg: 'Hello Vue.js!',\r\n          $child: {\r\n            // ...data\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n复制代码wxss这个部分的处理同 web 的处理差异不大，唯一不同在于通过配置生成 .css 为 .wxss ，其中的对于 css 的若干处理，在 postcss-mpvue-wxss 和 px2rpx-loader 这两部分的文档中又详细的介绍。app.json／page.json 1.1.1 以上推荐和小程序一样，将 app.json／page.json 放到页面入口处，使用 copy-webpack-plugin copy 到对应的生成位置。1.1.1 以下这部分内容来源于 app 和 page 的 entry 文件，通常习惯是 main.js，你需要在你的入口文件中 export default { config: {} }，这才能被我们的 loader 识别为这是一个配置，需要写成 json 文件。import Vue from 'vue';\r\nimport App from './app';\r\n\r\nconst vueApp = new Vue(App);\r\nvueApp.$mount();\r\n\r\n// 这个是我们约定的额外的配置\r\nexport default {\r\n    // 这个字段下的数据会被填充到 app.json ／ page.json\r\n    config: {\r\n        pages: ['static/calendar/calendar', '^pages/list/list'], // Will be filled in webpack\r\n        window: {\r\n            backgroundTextStyle: 'light',\r\n            navigationBarBackgroundColor: '#455A73',\r\n            navigationBarTitleText: '美团汽车票',\r\n            navigationBarTextStyle: '#fff'\r\n        }\r\n    }\r\n};\r\n复制代码同时，这个时候，我们会根据 entry 的页面数据，自动填充到 app.json 中的 pages 字段。 pages 字段也是可以自定义的，约定带有 ^ 符号开头的页面，会放到数组的最前面。style scoped 在 vue-loader 中对 style scoped 的处理方式是给每个样式加一个 attr 来标记 module-id，然后在 css 中也给每条 rule 后添加 [module-id]，最终可以形成一个 css 的“作用域空间”。在微信小程序中目前是不支持 attr 选择器的，所以我们做了一点改动，把 attr 上的 [module-id] 直接写到了 class 里，如下：<!-- .vue -->\r\n<template>\r\n    <div class=\"container\">\r\n        // ...\r\n    </div>\r\n</template>\r\n<style scoped>\r\n    .container {\r\n        color: red;\r\n    }\r\n</style>\r\n\r\n<!-- vue-loader -->\r\n<template>\r\n    <div class=\"container\" data-v-23e58823>\r\n        // ...\r\n    </div>\r\n</template>\r\n<style scoped>\r\n    .container[data-v-23e58823] {\r\n        color: red;\r\n    }\r\n</style>\r\n\r\n<!-- mpvue-loader -->\r\n<template>\r\n    <div class=\"container data-v-23e58823\">\r\n        // ...\r\n    </div>\r\n</template>\r\n<style scoped>\r\n    .container.data-v-23e58823 {\r\n        color: red;\r\n    }\r\n</style>\r\n复制代码compiler生产出的内容是：(function(module, __webpack_exports__, __webpack_require__) {\r\n\r\n\"use strict\";\r\n// mpvue-template-compiler会利用AST预编译生成一个render function用以生成Virtual DOM。\r\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\r\n  // _c创建虚拟节点，参考https://github.com/Meituan-Dianping/mpvue/blob/master/packages/mpvue/index.js#L3606\r\n  // 以及https://github.com/Meituan-Dianping/mpvue/blob/master/packages/mpvue/index.js#L3680\r\n  return _c('div', {\r\n    staticClass: \"my-component\"\r\n  }, [_c('h1', [_vm._v(_vm._s(_vm.msg))]), _vm._v(\" \"), _c('other-component', {\r\n    attrs: {\r\n      \"msg\": _vm.msg,\r\n      \"mpcomid\": '0'\r\n    }\r\n  })], 1)\r\n}\r\n\r\n// staticRenderFns的作用是静态渲染，在更新时不会进行patch，优化性能。而staticRenderFns是个空数组。\r\nvar staticRenderFns = []\r\nrender._withStripped = true\r\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\r\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\r\nif (false) {\r\n  module.hot.accept()\r\n  if (module.hot.data) {\r\n     require(\"vue-hot-reload-api\").rerender(\"data-v-54ad9125\", esExports)\r\n  }\r\n}\r\n\r\n/***/ })\r\n复制代码compilercompiler相关，也就是template预编译这块，可以参考《 聊聊Vue的template编译 》来搞明白。原理是一样的。mpvue自己实现了 export { compile, compileToFunctions, compileToWxml } ( 链接 )其中 compileToWxml 是用来生成wxml，具体代码 在这 。另外mpvue是不需要提供运行时-编译器的，虽然理论上是能够做到的。因为小程序不能操作DOM，即便提供了运行时-编译器也产生不了界面。详细讲解compile过程：1.将vue文件解析成模板对象// mpvue-loader/lib/loader.js\r\nvar parts = parse(content, fileName, this.sourceMap)\r\n复制代码假如vue文件源码如下:<template>\r\n  <view class=\"container-bg\">\r\n    <view class=\"home-container\">\r\n      <home-quotation-view v-for=\"(item, index) in lists\" :key=\"index\" :reason=\"item.reason\" :stockList=\"item.list\" @itemViewClicked=\"itemViewClicked\" />\r\n    </view>\r\n  </view>\r\n</template>\r\n\r\n<script lang=\"js\">\r\nimport homeQuotationView from '@/components/homeQuotationView'\r\nimport topListApi from '@/api/topListApi'\r\n\r\nexport default {\r\n  data () {\r\n    return {\r\n      lists: []\r\n    }\r\n  },\r\n  components: {\r\n    homeQuotationView\r\n  },\r\n  methods: {\r\n    async loadRankList () {\r\n      let {data} = await topListApi.rankList()\r\n      if (data) {\r\n        this.dateTime = data.dt\r\n        this.lists = data.rankList.filter((item) => {\r\n          return !!item\r\n        })\r\n      }\r\n    },\r\n    itemViewClicked (quotationItem) {\r\n      wx.navigateTo({\r\n        url: `/pages/topListDetail/main?item=${JSON.stringify(quotationItem)}`\r\n      })\r\n    }\r\n  },\r\n  onShow () {\r\n    this.loadRankList()\r\n  }\r\n}\r\n</script>\r\n\r\n<style lang=\"stylus\" scoped>\r\n  .container-bg\r\n    width 100%\r\n    height 100%\r\n    background-color #F2F4FA\r\n\r\n  .home-container\r\n    width 100%\r\n    height 100%\r\n    overflow-x hidden\r\n\r\n</style>\r\n复制代码调用 parse(content, fileName, this.sourceMap) 函数得到的结果大致如下：{\r\n  template: {\r\n    type: 'template',\r\n    content: '\\n<view class=\"container-bg\">\\n  <view class=\"home-container\">\\n    <home-quotation-view v-for=\"(item, index) in lists\" :key=\"index\" :reason=\"item.reason\" :stockList=\"item.list\" @itemViewClicked=\"itemViewClicked\" />\\n  </view>\\n</view>\\n',\r\n    start: 10,\r\n    attrs: {},\r\n    end: 251\r\n  },\r\n  script: {\r\n    type: 'script',\r\n    content: '\\n\\n\\n\\n\\n\\n\\n\\n\\nimport homeQuotationView from \\'@/components/homeQuotationView\\'\\nimport topListApi from \\'@/api/topListApi\\'\\n\\nexport default {\\n  data () {\\n    return {\\n      lists: []\\n    }\\n  },\\n  components: {\\n    homeQuotationView\\n  },\\n  methods: {\\n    async loadRankList () {\\n      let {data} = await topListApi.rankList()\\n      if (data) {\\n        this.dateTime = data.dt\\n        this.lists = data.rankList.filter((item) => {\\n          return !!item\\n        })\\n      }\\n    },\\n    itemViewClicked (quotationItem) {\\n      wx.navigateTo({\\n        url: `/pages/topListDetail/main?item=${JSON.stringify(quotationItem)}`\\n      })\\n    }\\n  },\\n  onShow () {\\n    this.loadRankList()\\n  }\\n}\\n',\r\n    start: 282,\r\n    attrs: {\r\n      lang: 'js'\r\n    },\r\n    lang: 'js',\r\n    end: 946,\r\n    ...\r\n  },\r\n  styles: [{\r\n    type: 'style',\r\n    content: '\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n.container-bg\\n  width 100%\\n  height 100%\\n  background-color #F2F4FA\\n\\n.home-container\\n  width 100%\\n  height 100%\\n  overflow-x hidden\\n\\n',\r\n    start: 985,\r\n    attrs: [Object],\r\n    lang: 'stylus',\r\n    scoped: true,\r\n    end: 1135,\r\n    ...\r\n  }],\r\n  customBlocks: []\r\n}\r\n复制代码2.调用mpvue-loader/lib/template-compiler/index.js导出的接口并传入上面得到的html模板：var templateCompilerPath = normalize.lib('template-compiler/index')\r\n...\r\nvar defaultLoaders = {\r\n  html: templateCompilerPath + templateCompilerOptions,\r\n  css: options.extractCSS\r\n    ? getCSSExtractLoader()\r\n    : styleLoaderPath + '!' + 'css-loader' + cssLoaderOptions,\r\n  js: hasBuble ? ('buble-loader' + bubleOptions) : hasBabel ? babelLoaderOptions : ''\r\n}\r\n\r\n// check if there are custom loaders specified via\r\n// webpack config, otherwise use defaults\r\nvar loaders = Object.assign({}, defaultLoaders, options.loaders)\r\n复制代码调用mpvue/packages/mpvue-template-compiler/build.js的compile接口：// mpvue-loader/lib/template-compiler/index.js\r\nvar compiled = compile(html, compilerOptions)\r\n复制代码compile方法生产下面的ast(Abstract Syntax Tree)模板，render函数和staticRenderFns{\r\n  ast: {\r\n    type: 1,\r\n    tag: 'view',\r\n    attrsList: [],\r\n    attrsMap: {\r\n      class: 'container-bg'\r\n    },\r\n    parent: undefined,\r\n    children: [{\r\n      type: 1,\r\n      tag: 'view',\r\n      attrsList: [],\r\n      attrsMap: {\r\n        class: 'home-container'\r\n      },\r\n      parent: {\r\n        type: 1,\r\n        tag: 'view',\r\n        attrsList: [],\r\n        attrsMap: {\r\n          class: 'container-bg'\r\n        },\r\n        parent: undefined,\r\n        children: [\r\n          [Circular]\r\n        ],\r\n        plain: false,\r\n        staticClass: '\"container-bg\"',\r\n        static: false,\r\n        staticRoot: false\r\n      },\r\n      children: [{\r\n        type: 1,\r\n        tag: 'home-quotation-view',\r\n        attrsList: [{\r\n          name: ':reason',\r\n          value: 'item.reason'\r\n        }, {\r\n          name: ':stockList',\r\n          value: 'item.list'\r\n        }, {\r\n          name: '@itemViewClicked',\r\n          value: 'itemViewClicked'\r\n        }],\r\n        attrsMap: {\r\n          'v-for': '(item, index) in lists',\r\n          ':key': 'index',\r\n          ':reason': 'item.reason',\r\n          ':stockList': 'item.list',\r\n          '@itemViewClicked': 'itemViewClicked',\r\n          'data-eventid': '{{\\'0-\\'+index}}',\r\n          'data-comkey': '{{$k}}'\r\n        },\r\n        parent: [Circular],\r\n        children: [],\r\n        for: 'lists',\r\n        alias: 'item',\r\n        iterator1: 'index',\r\n        key: 'index',\r\n        plain: false,\r\n        hasBindings: true,\r\n        attrs: [{\r\n          name: 'reason',\r\n          value: 'item.reason'\r\n        }, {\r\n          name: 'stockList',\r\n          value: 'item.list'\r\n        }, {\r\n          name: 'eventid',\r\n          value: '\\'0-\\'+index'\r\n        }, {\r\n          name: 'mpcomid',\r\n          value: '\\'0-\\'+index'\r\n        }],\r\n        events: {\r\n          itemViewClicked: {\r\n            value: 'itemViewClicked',\r\n            modifiers: undefined\r\n          }\r\n        },\r\n        eventid: '\\'0-\\'+index',\r\n        mpcomid: '\\'0-\\'+index',\r\n        static: false,\r\n        staticRoot: false,\r\n        forProcessed: true\r\n      }],\r\n      plain: false,\r\n      staticClass: '\"home-container\"',\r\n      static: false,\r\n      staticRoot: false\r\n    }],\r\n    plain: false,\r\n    staticClass: '\"container-bg\"',\r\n    static: false,\r\n    staticRoot: false\r\n  },\r\n  render: 'with(this){return _c(\\'view\\',{staticClass:\"container-bg\"},[_c(\\'view\\',{staticClass:\"home-container\"},_l((lists),function(item,index){return _c(\\'home-quotation-view\\',{key:index,attrs:{\"reason\":item.reason,\"stockList\":item.list,\"eventid\":\\'0-\\'+index,\"mpcomid\":\\'0-\\'+index},on:{\"itemViewClicked\":itemViewClicked}})}))])}',\r\n  staticRenderFns: [],\r\n  errors: [],\r\n  tips: []\r\n}\r\n复制代码其中的render函数运行的结果是返回 VNode 对象，其实 render 函数应该长下面这样：(function() {\r\n  with(this){\r\n    return _c('div',{   //创建一个 div 元素\r\n      attrs:{\"id\":\"app\"}  //div 添加属性 id\r\n      },[\r\n        _m(0),  //静态节点 header，此处对应 staticRenderFns 数组索引为 0 的 render 函数\r\n        _v(\" \"), //空的文本节点\r\n        (message) //三元表达式，判断 message 是否存在\r\n         //如果存在，创建 p 元素，元素里面有文本，值为 toString(message)\r\n        ?_c('p',[_v(\"\\n    \"+_s(message)+\"\\n  \")])\r\n        //如果不存在，创建 p 元素，元素里面有文本，值为 No message. \r\n        :_c('p',[_v(\"\\n    No message.\\n  \")])\r\n      ]\r\n    )\r\n  }\r\n})\r\n复制代码其中的 _c 就是vue对象的 createElement 方法 (创建元素)， _m 是 renderStatic （渲染静态节点）， _v 是 createTextVNode （创建文本dom）， _s 是 toString （转换为字符串）// src/core/instance/render.js\r\nexport function initRender (vm: Component) {\r\n  ...\r\n  // bind the createElement fn to this instance\r\n  // so that we get proper render context inside it.\r\n  // args order: tag, data, children, normalizationType, alwaysNormalize\r\n  // internal version is used by render functions compiled from templates\r\n  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)\r\n  // normalization is always applied for the public version, used in\r\n  // user-written render functions.\r\n  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)\r\n  ...\r\n}\r\n\r\n...\r\nVue.prototype._s = toString\r\n...\r\nVue.prototype._m = renderStatic\r\n...\r\nVue.prototype._v = createTextVNode\r\n...\r\n复制代码调用compileWxml方法生产wxml模板，这个方法最终会调用 mpvue/packages/mpvue-template-compiler/build.js的compileToWxml方法将第一步compile出来的模板转成小程序的wxml模板// mpvue-loader/lib/template-compiler/index.js\r\ncompileToWxml.call(this, compiled, html)\r\n复制代码以上解答了问题1、2runtime目录结构.\r\n├── events.js //解答问题5\r\n├── index.js //入口提供Vue对象，以及$mount，和各种初始化\r\n├── liefcycle //解答问题6、7\r\n├── node-ops.js //操作真实DOM的相关实现，因为小程序不能操作DOM，所以这里都是直接返回\r\n├── patch.js //解答问题3\r\n└── render.js //解答问题4\r\n复制代码patch.js和vue使用的 createPatchFunction 保持一致，任然是旧树和新树进行patch产出diff，但是多了一行this.$updateDataToMP()用以更新。render.js两个核心的方法 initDataToMP 、 updateDataToMP 。initDataToMP 收集vm上的data，然后调用小程序Page示例的 setData 渲染。updateDataToMP 在每次patch，也就是依赖收集发现数据改变时更新(参考patch.js代码)，这部分一样会使用 nextTick 和队列。最终使用了节流阀 throttleSetData 。50毫秒用来控制频率以解决频繁修改Data，会造成大量传输Data数据而导致的性能问题。其中 collectVmData 最终也是用到了 formatVmData 。尤其要注意的是一句注释：getVmData 这儿获取当前组件内的所有数据，包含 props、computed 的数据我们又知道，service到view是两个线程间通信，如果Data含有大量数据，增加了传输数据量，加大了传输成本，将会造成性能下降。events.js正如官网所说的，这里使用 eventTypeMap 做了各事件的隐射import { getComKey, eventTypeMap } from '../util/index'\r\n复制代码// 用于小程序的 event type 到 web 的 event\r\nexport const eventTypeMap = {\r\n  tap: ['tap', 'click'],\r\n  touchstart: ['touchstart'],\r\n  touchmove: ['touchmove'],\r\n  touchcancel: ['touchcancel'],\r\n  touchend: ['touchend'],\r\n  longtap: ['longtap'],\r\n  input: ['input'],\r\n  blur: ['change', 'blur'],\r\n  submit: ['submit'],\r\n  focus: ['focus'],\r\n  scrolltoupper: ['scrolltoupper'],\r\n  scrolltolower: ['scrolltolower'],\r\n  scroll: ['scroll']\r\n}\r\n复制代码使用了 handleProxyWithVue 方法来代理小程序事件到vue事件。另外看下作者自己对这部分的思路事件代理机制：用户交互触发的数据更新通过事件代理机制完成。在 Vue.js 代码中，事件响应函数对应到组件的 method， Vue.js 自动维护了上下文环境。然而在小程序中并没有类似的机制，又因为 Vue.js 执行环境中维护着一份实时的虚拟 DOM，这与小程序的视图层完全对应，我们思考，在小程序组件节点上触发事件后，只要找到虚拟 DOM 上对应的节点，触发对应的事件不就完成了么；另一方面，Vue.js 事件响应如果触发了数据更新，其生命周期函数更新将自动触发，在此函数上同步更新小程序数据，数据同步也就实现了。getHandle 这个方法应该就是作者思路当中所说的：找到对应节点，然后找到handle。lifecycle.js在 initMP 方法中，自己创建小程序的App、Page。实现生命周期相关方法，使用 callHook代理兼容小程序App、Page的生命周期。官方文档生命周期中说到了：同 vue，不同的是我们会在小程序 onReady 后，再去触发 vue mounted 生命周期这部分查看， onReady 之后才会执行 next ，这个 next 回调最终是vue的 mountComponent。可以在 index.js 中看到。这部分代码也就是解决了\"小程序生命周期中触发vue生命周期\"。export function initMP (mpType, next) {\r\n  // ...\r\n    global.Page({\r\n      // 生命周期函数--监听页面初次渲染完成\r\n      onReady () {\r\n        mp.status = 'ready'\r\n\r\n        callHook(rootVueVM, 'onReady')\r\n        next()\r\n      },\r\n    })\r\n  // ...\r\n}\r\n复制代码在小程序onShow时，使用$nextTick去第一次渲染数据，参考上面提到的render.js。export function initMP (mpType, next) {\r\n  // ...\r\n  global.Page({\r\n    // 生命周期函数--监听页面显示\r\n    onShow () {\r\n      mp.page = this\r\n      mp.status = 'show'\r\n      callHook(rootVueVM, 'onShow')\r\n\r\n      // 只有页面需要 setData\r\n      rootVueVM.$nextTick(() => {\r\n        rootVueVM._initDataToMP()\r\n      })\r\n    },\r\n  })\r\n  // ...\r\n}\r\n复制代码在mpvue-loader生成template时，比如点击事件 @click 会变成 bindtap=\"handleProxy\" ，事件绑定全都会使用 handleProxy 这个方法。可以查看上面回顾一下。最终handleProxy调用的是event.js中的 handleProxyWithVue 。export function initMP (mpType, next) {\r\n  // ...\r\n    global.Page({\r\n      handleProxy (e) {\r\n        return rootVueVM.$handleProxyWithVue(e)\r\n      },\r\n    })\r\n  // ...\r\n}\r\n复制代码index.js最后index.js就负责各种初始化和mount。Class和Style为什么暂不支持组件原因：目前的组件是使用小程序的 template 标签实现的，给组件指定的class和style是挂载在template标签上，而template 标签不支持 class 及 style 属性。解决方案： 在自定义组件上绑定class或style到一个props属性上。// 组件ComponentA.vue\r\n <template>\r\n  <div class=\"container\" :class=\"pClass\">\r\n    ...\r\n  </div>\r\n</template>\r\n复制代码<script>\r\n    export default {\r\n    props: {\r\n      pClass: {\r\n        type: String,\r\n        default: ''\r\n      }\r\n    }\r\n  }\r\n</script>\r\n复制代码<!--PageB.vue-->\r\n<template>\r\n    <component-a :pClass=\"cusComponentAClass\"  />\r\n</template>\r\n复制代码<script>\r\ndata () {\r\n    return {\r\n      cusComponentAClass: 'a-class b-class'\r\n    }\r\n  }\r\n</script>\r\n复制代码<style lang=\"stylus\" scoped>\r\n  .a-class\r\n    border red solid 2rpx\r\n  .b-class\r\n    margin-right 20rpx\r\n</style>\r\n复制代码但是这样会有问题就是style加上scoped之后，编译模板生成的代码是下面这样的：.a-class.data-v-8f1d914e {\r\n   border: #f00 solid 2rpx;\r\n }\r\n .b-class.data-v-8f1d914e {\r\n   margin-right 20rpx\r\n }\r\n复制代码所以想要这些组件的class生效就不能使用scoped的style，改成下面这样，最好自己给a-class和b-class加前缀以防其他的文件引用这些样式：<style lang=\"stylus\">\r\n  .a-class\r\n    border red solid 2rpx\r\n  .b-class\r\n    margin-right 20rpx\r\n</style>\r\n\r\n<style lang=\"stylus\" scoped>\r\n  .other-class\r\n    border red solid 2rpx\r\n    \r\n   ...\r\n</style>\r\n复制代码在定义组件上绑定style属性到一个props属性上：<!--P组件ComponentA.vue-->\r\n <template>\r\n  <div class=\"container\" :style=\"pStyle\">\r\n    ...\r\n  </div>\r\n</template>\r\n复制代码<script>\r\n  export default {\r\n    props: {\r\n      pStyle: {\r\n        type: String,\r\n        default: ''\r\n      }\r\n    }\r\n  }\r\n</script>\r\n复制代码<!--PageB.vue-->\r\n<template>\r\n    <component-a :pStyle=\"cusComponentAStyle\"  />\r\n</template>\r\n复制代码<script>\r\nconst cusComponentAStyle = 'border:red solid 2rpx; margin-right:20rpx;'\r\ndata () {\r\n    return {\r\n      cusComponentAStyle\r\n    }\r\n  }\r\n</script>\r\n复制代码<style lang=\"stylus\" scoped>\r\n  ...\r\n</style>\r\n复制代码也可以通过定义styleObject，然后通过工具函数转化为styleString，如下所示：const bstyle = {\r\n  border: 'red solid 2rpx',\r\n  'margin-right': '20rpx'\r\n}\r\nlet arr = []\r\nfor (let [key, value] of Object.entries(bstyle)) {\r\n  arr.push(`${key}: ${value}`)\r\n}\r\n\r\nconst cusComponentAStyle = arr.join('; ')\r\n复制代码当然自定义组件确定只会改变某个css样式，通过pros传入单个样式的值，然后通过:style绑定肯定没问题：<!--组件ComponentA.vue-->\r\n <template>\r\n  <div class=\"container\" :style=\"{'background-color': backgroundColor}\">\r\n    ...\r\n  </div>\r\n</template>\r\n复制代码<script>\r\n    export default {\r\n    props: {\r\n      backgroundColor: {\r\n        type: String,\r\n        default: 'yellow'\r\n      }\r\n    }\r\n  }\r\n</script>\r\n复制代码<!-- PageB.vue -->\r\n<template>\r\n    <component-a backgroundColor=\"red\"  />\r\n</template>\r\n复制代码分包加载package.json修改升级： \"mpvue-loader\": \"^1.1.2-rc.4\" \"webpack-mpvue-asset-plugin\": \"^0.1.1\"新增： \"relative\": \"^3.0.2\"注意事项1.1.2-rc.5 修复 slot 文件路径生成错误的问题1.1.x 版本还不是很稳定，对稳定性要求较高的项目建议暂时使用 1.0.x 版本移动src/main.js中config相关内容到同级目录下main.json(新建)中export default {\r\n  // config: {...} 需要移动\r\n}\r\n\r\n复制代码to{\r\n \"pages\": [\r\n   \"pages/index/main\",\r\n   \"pages/logs/main\"\r\n  ],\r\n  \"subPackages\": [\r\n    {\r\n      \"root\": \"pages/packageA\",\r\n     \"pages\": [\r\n       \"counter/main\"\r\n     ]\r\n   }\r\n ],\r\n \"window\": {...}\r\n}\r\n复制代码webpack 配置配合升级指南本次升级意在调整生成文件目录结构，对依赖的文件由原来的写死绝对路径该改为相对路径mpvue-loader@1.1.2-rc.4 依赖 webpack-mpvue-asset-plugin@0.1.0 做依赖资源引用之前写在 main.js 中的 config 信息，需要在 main.js 同级目录下新建 main.json 文件，使用 webapck-copy-plugin copy 到 build 目录下app.json 中引用的图片不会自动 copy 到 dist 目录下 json 配置文件是由 webapck-copy-plugin copy 过去的，不会处理依赖，可以将图片放到根目录下 static 目录下，使用 webapck-copy-plugin copy 过去build/webpack.base.conf.js+var CopyWebpackPlugin = require('copy-webpack-plugin')\r\n+var relative = require('relative')\r\n\r\n function resolve (dir) {\r\n   return path.join(__dirname, '..', dir)\r\n }\r\n\r\n-function getEntry (rootSrc, pattern) {\r\n-  var files = glob.sync(path.resolve(rootSrc, pattern))\r\n-  return files.reduce((res, file) => {\r\n-    var info = path.parse(file)\r\n-    var key = info.dir.slice(rootSrc.length + 1) + '/' + info.name\r\n-    res[key] = path.resolve(file)\r\n-    return res\r\n-  }, {})\r\n+function getEntry (rootSrc) {\r\n+  var map = {};\r\n+  glob.sync(rootSrc + '/pages/**/main.js')\r\n+  .forEach(file => {\r\n+    var key = relative(rootSrc, file).replace('.js', '');\r\n+    map[key] = file;\r\n+  })\r\n+   return map;\r\n }\r\n\r\n   plugins: [\r\n-    new MpvuePlugin()\r\n+    new MpvuePlugin(),\r\n+    new CopyWebpackPlugin([{\r\n+      from: '**/*.json',\r\n+      to: 'app.json'\r\n+    }], {\r\n+      context: 'src/'\r\n+    }),\r\n+    new CopyWebpackPlugin([ // 处理 main.json 里面引用的图片，不要放代码中引用的图片\r\n+      {\r\n+        from: path.resolve(__dirname, '../static'),\r\n+        to: path.resolve(__dirname, '../dist/static'),\r\n+        ignore: ['.*']\r\n+      }\r\n+    ])\r\n   ]\r\n }\r\n复制代码build/webpack.dev.conf.jsmodule.exports = merge(baseWebpackConfig, {\r\n   devtool: '#source-map',\r\n   output: {\r\n     path: config.build.assetsRoot,\r\n-    filename: utils.assetsPath('js/[name].js'),\r\n-    chunkFilename: utils.assetsPath('js/[id].js')\r\n+    filename: utils.assetsPath('[name].js'),\r\n+    chunkFilename: utils.assetsPath('[id].js')\r\n   },\r\n   plugins: [\r\n     new webpack.DefinePlugin({\r\n    module.exports = merge(baseWebpackConfig, {\r\n     // copy from ./webpack.prod.conf.js\r\n     // extract css into its own file\r\n     new ExtractTextPlugin({\r\n-      filename: utils.assetsPath('css/[name].wxss')\r\n+      filename: utils.assetsPath('[name].wxss')\r\n     }),\r\n    module.exports = merge(baseWebpackConfig, {\r\n       }\r\n     }),\r\n     new webpack.optimize.CommonsChunkPlugin({\r\n-      name: 'vendor',\r\n+      name: 'common/vendor',\r\n       minChunks: function (module, count) {\r\n         // any required modules inside node_modules are extracted to vendor\r\n         return (\r\n        module.exports = merge(baseWebpackConfig, {\r\n       }\r\n     }),\r\n     new webpack.optimize.CommonsChunkPlugin({\r\n-      name: 'manifest',\r\n-      chunks: ['vendor']\r\n+      name: 'common/manifest',\r\n+      chunks: ['common/vendor']\r\n     }),\r\n-    // copy custom static assets\r\n-    new CopyWebpackPlugin([\r\n-      {\r\n-        from: path.resolve(__dirname, '../static'),\r\n-        to: config.build.assetsSubDirectory,\r\n-        ignore: ['.*']\r\n-      }\r\n-    ]),\r\n\r\n复制代码build/webpack.prod.conf.jsvar webpackConfig = merge(baseWebpackConfig, {\r\n   devtool: config.build.productionSourceMap ? '#source-map' : false,\r\n   output: {\r\n     path: config.build.assetsRoot,\r\n-    filename: utils.assetsPath('js/[name].js'),\r\n-    chunkFilename: utils.assetsPath('js/[id].js')\r\n+    filename: utils.assetsPath('[name].js'),\r\n+    chunkFilename: utils.assetsPath('[id].js')\r\n   },\r\n   plugins: [\r\n    var webpackConfig = merge(baseWebpackConfig, {\r\n     }),\r\n     // extract css into its own file\r\n     new ExtractTextPlugin({\r\n-      // filename: utils.assetsPath('css/[name].[contenthash].css')\r\n-      filename: utils.assetsPath('css/[name].wxss')\r\n+      // filename: utils.assetsPath('[name].[contenthash].css')\r\n+      filename: utils.assetsPath('[name].wxss')\r\n     }),\r\n     // Compress extracted CSS. We are using this plugin so that possible\r\n     // duplicated CSS from different components can be deduped.\r\n    var webpackConfig = merge(baseWebpackConfig, {\r\n     new webpack.HashedModuleIdsPlugin(),\r\n     // split vendor js into its own file\r\n     new webpack.optimize.CommonsChunkPlugin({\r\n-      name: 'vendor',\r\n+      name: 'common/vendor',\r\n       minChunks: function (module, count) {\r\n         // any required modules inside node_modules are extracted to vendor\r\n         return (\r\n     var webpackConfig = merge(baseWebpackConfig, {\r\n     // extract webpack runtime and module manifest to its own file in order to\r\n     // prevent vendor hash from being updated whenever app bundle is updated\r\n     new webpack.optimize.CommonsChunkPlugin({\r\n-      name: 'manifest',\r\n-      chunks: ['vendor']\r\n-    }),\r\n+      name: 'common/manifest',\r\n+      chunks: ['common/vendor']\r\n+    })\r\n-    // copy custom static assets\r\n-    new CopyWebpackPlugin([\r\n-      {\r\n-        from: path.resolve(__dirname, '../static'),\r\n-        to: config.build.assetsSubDirectory,\r\n-        ignore: ['.*']\r\n-      }\r\n-    ])\r\n   ]\r\n })\r\n复制代码config/index.jsmodule.exports = {\r\n     env: require('./prod.env'),\r\n     index: path.resolve(__dirname, '../dist/index.html'),\r\n     assetsRoot: path.resolve(__dirname, '../dist'),\r\n-    assetsSubDirectory: 'static', // 不将资源聚合放在 static 目录下\r\n+    assetsSubDirectory: '',\r\n     assetsPublicPath: '/',\r\n     productionSourceMap: false,\r\n     // Gzip off by default as many popular static hosts such as\r\n@@ -26,7 +26,7 @@ module.exports = {\r\n     port: 8080,\r\n     // 在小程序开发者工具中不需要自动打开浏览器\r\n     autoOpenBrowser: false,\r\n-    assetsSubDirectory: 'static', // 不将资源聚合放在 static 目录下\r\n+    assetsSubDirectory: '',\r\n     assetsPublicPath: '/',\r\n     proxyTable: {},\r\n     // CSS Sourcemaps off by default because relative paths are \"buggy\"\r\n\r\n复制代码"}
{"title": "小程序点赞收藏功能 ", "author": "Rolan", "pub_time": "2018-9-12 00:13", "content": "一.收藏focusFavoriteTab: function (e) {\r\n        var that = this;\r\n        var isFocus = that.data.isFocus;\r\n        console.log(\"isFocus\", isFocus)\r\n        var itemId = that.data.itemId;\r\n        if (isFocus) {\r\n          favoriteService.cancel(that, itemId).then((res) => {\r\n            wx.showToast({\r\n              title: \"取消收藏\",\r\n              icon: 'success',\r\n              duration: 1000\r\n            });\r\n            that.setData({\r\n              isFocus: false,\r\n            });\r\n          })\r\n        } else {\r\n          favoriteService.add(that, itemId).then((res) => {\r\n            wx.showToast({\r\n              title: res.data == 1 ? \"收藏成功\" : \"收藏失败\",\r\n              icon: 'success',\r\n              duration: 1000\r\n            });\r\n            that.setData({\r\n              isFocus: true,\r\n            });\r\n          });\r\n        }\r\n      },\r\n二.点赞focuslikeTab: function (e) {\r\n    var that = this;\r\n    var isLike = that.data.isLike;\r\n    let itemDetail = this.data.itemDetail \r\n    var itemId = that.data.itemId;\r\n    if (isLike) {\r\n      itemService.cancellike(that, itemId).then((res) => {\r\n        wx.showToast({\r\n          title: \"点赞取消\",\r\n          icon: 'success',\r\n          duration: 1000\r\n        });\r\n        itemDetail.liked--;\r\n        that.setData({\r\n          itemDetail:itemDetail,\r\n           isLike: false\r\n        });\r\n       })\r\n    } else {\r\n      itemService.addlike(that, itemId).then((res) => {\r\n        wx.showToast({\r\n          title: res.data == 1 ? \"点赞成功\" : \"点赞失败\",\r\n          icon: 'success',\r\n          duration: 1000\r\n        });\r\n        itemDetail.liked++;\r\n        that.setData({\r\n          itemDetail: itemDetail,\r\n          isLike: true\r\n        });\r\n       });\r\n    }\r\n  },"}
{"title": "小程序构建骨架屏的探索 ", "author": "Rolan", "pub_time": "2018-9-18 00:12", "content": "首屏一般情况下，在首屏数据未拿到之前，为了提升用户的体验，会在页面上展示一个loading的图层，类似下面这个其中除了菊花图以外网上还流传这各种各样的loading动画，在PC端上几乎要统一江湖了，不过最近在移动端上面看到不同于菊花图的加载方式，就是这篇文章需要分享的Skeleton Screen，中文称之为\"骨架屏\"概念A skeleton screen is essentially a blank version of a page into which information is gradually loaded.在H5中，骨架屏其实已经不是什么新奇的概念了，网上也有各种方案生成对应的骨架屏，包括我们经常使用的知乎、饿了么、美团等APP都有应用骨架屏这个概念图片来源网络，侵删方案先从H5生成骨架屏方案开始说起，总的来说H5生成骨架屏的方案有2种完全靠手写HTML和CSS方式给每个页面定制一套骨架屏利用预渲染的方式生成静态骨架屏第一套方案，毫无疑问是最简单最直白的方式，缺点也很明显，假如页面布局有修改的话，那么除了修改业务代码之外还需要额外修改骨架屏，增加了维护的成本。第二套方案，一定程度上改善了第一套方案带来的维护成本增加的缺点，主要还是使用工具预渲染页面，获取到DOM节点和样式，保留页面结构，覆盖样式，生成灰色块盖在原有文本、图片或者是canvas等节点上面，最后将生成的HTML和CSS打包出来，就是一个带有骨架屏的页面。最后再利用webpack工具将生成的骨架屏插入到HTML里面，详细的话可以看看饿了么的分享，这里就不多描述了。调研了下H5生成骨架屏的方案，对于小程序生成骨架屏的方案也有了一个大致的想法，主要有2个难点需要实现预渲染获取节点预渲染再说回饿了么提供的骨架屏的方案，使用 puppeteer 渲染页面（或者使用服务端渲染，vue或者react都有提供相应的方案），拿到DOM节点和样式，这里有一点需要注意的是，页面的渲染是需要初始化的数据，数据的来源可以是初始化的data（vue）或者mock数据，当然小程序是无法直接使用 puppeteer 来做预渲染（有另外的方案可以实现），需要利用小程序初始化的 data + template 渲染之后得到一个初始化结构作为骨架屏的结构//index.js\r\nPage({\r\n    data: {\r\n        motto: 'Hello World',\r\n        userInfo: {\r\n            avatarUrl: 'https://wx.qlogo.cn/mmopen/vi_32/SYiaiba5faeraYBoQCWdsBX4hSjFKiawzhIpnXjejDtjmiaFqMqhIlRBqR7IVdbKE51npeF6X1cXxtDQD2bzehgqMA/132',\r\n            nickName: 'jay'\r\n        },\r\n        lists: [\r\n            'aslkdnoakjbsnfkajbfk',\r\n            'qwrwfhbfdvndgndghndeghsdfh',\r\n            'qweqwtefhfhgmjfgjdfghaefdhsdfgdfh',\r\n        ],\r\n        showSkeleton: true\r\n    },\r\n    onLoad: function () {\r\n        const that = this;\r\n        setTimeout(() => {\r\n            that.setData({\r\n                showSkeleton: false\r\n            })\r\n        }, 3000)\r\n    }\r\n})\r\n\r\n//index.wxml\r\n<view class=\"container\">\r\n    <view class=\"userinfo\">\r\n        <block>\r\n            <image class=\"userinfo-avatar skeleton-radius\" src=\"{{userInfo.avatarUrl}}\"\r\n                   mode=\"cover\"></image>\r\n            <text class=\"userinfo-nickname skeleton-rect\">{{userInfo.nickName}}</text>\r\n        </block>\r\n    </view>\r\n    <view style=\"margin: 20px 0\">\r\n        <view wx:for=\"{{lists}}\" class=\"lists\">\r\n            <icon type=\"success\" size=\"20\" class=\"list skeleton-radius\"/>\r\n            <text class=\"skeleton-rect\">{{item}}</text>\r\n        </view>\r\n    </view>\r\n\r\n    <view class=\"usermotto\">\r\n        <text class=\"user-motto skeleton-rect\">{{motto}}</text>\r\n    </view>\r\n\r\n    <view style=\"margin-top: 200px;\">\r\n        aaaaaaaaaaa\r\n    </view>\r\n</view>有了上面的 data + template 之后，就有了一个初始化的页面结构，接下来就需要拿到节点信息节点小程序基础库1.4.0之后小程序基础库提供了一组新的API，可用于获取节点信息，具体API戳这里。跟H5方式一样，根据class或者id获取节点信息，不同的是只能获取到当前的节点信息，无法获取到其父或者子节点信息，所以只能手动给需要渲染骨架屏的节点添加相应的class或者id<view class=\"container\">\r\n    <view class=\"userinfo\">\r\n        <block>\r\n            <image class=\"userinfo-avatar skeleton-radius\" src=\"{{userInfo.avatarUrl}}\"\r\n                   mode=\"cover\"></image>\r\n            <text class=\"userinfo-nickname skeleton-rect\">{{userInfo.nickName}}</text>\r\n        </block>\r\n    </view>\r\n    <view style=\"margin: 20px 0\">\r\n        <view wx:for=\"{{lists}}\" class=\"lists\">\r\n            <icon type=\"success\" size=\"20\" class=\"list skeleton-radius\"/>\r\n            <text class=\"skeleton-rect\">{{item}}</text>\r\n        </view>\r\n    </view>\r\n\r\n    <view class=\"usermotto\">\r\n        <text class=\"user-motto skeleton-rect\">{{motto}}</text>\r\n    </view>\r\n\r\n    <view style=\"margin-top: 200px;\">\r\n        aaaaaaaaaaa\r\n    </view>\r\n</view>约定2个特殊的class作为获取节点信息的标记skeleton-rect和skeleton-radius，在页面中获取相应的top、left、width、height进行骨架屏的绘制结果具体的调用方式和源码，请看 github ，最后求start总结上文有说到小程序也可以使用 page-skeleton-webpack-plugin 方式一样生成骨架屏，最重要的一点就是需要将小程序跑在chrome上面，后面的流程就一样了，至于怎么将小程序跑在chrome上面呢？可以利用 wept ，缺点就是目前作者已经停止维护这个工具了，不支持新版小程序的API。说回来我这个生成骨架屏的方案，其实跟 page-skeleton-webpack-plugin 有点相似，不同的是，page-skeleton-webpack-plugin 采用离线渲染的方式生成静态骨架屏插入路由中，而我采用运行时先渲染页面默认结构，然后根据默认结构再绘制骨架屏。从性能角度出发确实不如 page-skeleton-webpack-plugin，但是也差不了多少了，主要还是小程序并没有提供类似服务端渲染的方案。目前从使用上来讲，还是有点小麻烦，需要默认数据撑开页面结构，需要给相应的节点添加class，后面有时间再研究下有没有更好的方案吧~~~"}
{"title": "微信小程序通过ip获取用户所在城市 ", "author": "Rolan", "pub_time": "2018-9-26 00:37", "content": "在微信小程序中, 获取用户的地理位置是需要权限的, 如果只是获取用户所在的城市信息, 那只需查看用户ip所在的城市就好了, 下面我们就完成获取用户ip的小程序逻辑~根据用户ip获取地理位置根据用户ip获取用户地理位置, 用爬虫实现! 博主所用的api:\"http://www.ip138.com/ips138.asp?ip=\"+ ip_addr查询ip的函数import requestsfrom lxml import etree# 查询ip归属地def query_ip_attribution(ip_addr):    # 设置用户代理头    headers = {        # 设置用户代理头(为狼披上羊皮)        \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36\",    }    target_url = \"http://www.ip138.com/ips138.asp?ip=\"+ ip_addr    response = requests.get(target_url, headers = headers).content    data_etree = etree.HTML(response)    ip_attr = data_etree.xpath('//tr[3]/td/ul/li[1]//text()')    ip_attr = ip_attr[0].strip(\"本站数据：\")    return {\"ip_attr\": ip_attr, \"ip\": ip_addr}nginx配置nginx负责将请求转发到django(django在9000端口开启了服务)proxy_set_header Host $http_host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_set_header X-Forwarded-Proto $scheme;Host包含客户端真实的域名和端口号； X-Real-IP表示客户端真实的IP； X-Forwarded-For这个Header和X-Real-IP类似，但它在多层代理时会包含真实客户端及中间每个代理服务器的IP。 X-Forwarded-Proto表示客户端真实的协议（http还是https）；Django读取用户ip, 查询并返回结果from django.http import JsonResponse# 获取用户ipdef get_ip(request):    if 'HTTP_X_FORWARDED_FOR' in request.META:        ip =  request.META['HTTP_X_FORWARDED_FOR']    else:        ip = request.META['REMOTE_ADDR']    return JsonResponse(query_ip_attribution(ip))微信小程序获取返回的数据可以作为开源接口调用 (支持http, https, 无需参数) 返回ip归属接口1: http://fangyuanxiaozhan.com/get_ip 返回ip归属接口2: https://fangyuanxiaozhan.com/get_ip小结:网页云音乐, 非常注重分析自己的用户, 并对用户的歌单进行个性化定制, 收获了大量好评, 对于个人开发者, 用复杂的算法分析用户, 不太现实,但通过分析用户所在城市, 对软件定位做一些优化, 还是很容易实现的。"}
{"title": "在小程序开发中使用 npm ", "author": "Rolan", "pub_time": "2018-10-12 00:37", "content": "本文介绍了如何在微信小程序开发中使用 npm 中包的功能，大大提高微信小程序的开发效率，同时也是微信小程序系列教程的视频版更新。微信小程序在发布之初没有对 npm 的支持功能，这也是目前很多前端开发人员在熟悉了 npm 生态环境后，对微信小程序诟病的地方。微信小程序在 2.2.1 版本后增加了对 npm 包加载的支持，使得小程序支持使用 npm 安装第三方包。微信小程序的功能更新最近更新的也非常给力，如之前给大家介绍的 微信小程序开发平台新功能「云开发」快速上手体验 。1. 在小程序中加载 npm 包微信小程序关于 npm 包的加载使用官方文档在 这里 ，此实战部分我们通过加载一个 npm 的第三方库 miniprogram-datepicker ，此类库用于实现公历与农历的日期选择功能，而微信小程序官方的组件只能简单地选择一个公历时间。在终端中定位到微信小程序的项目文件夹，通过 npm 的安装命令安装。此处请务必使用 –production 选项，可以减少安装一些业务无关的 npm 包，从而减少整个小程序包的大小。2. 构建 npm 包在微信小程序开发工具的「工具」菜单下点击「构建 npm」命令，进行 npm 包的构建，此构建可以将 npm 包构建成在小程序中可加载使用的包。为了帮助大家更好的理解发布 npm 包中提到的各种要求，这里简单介绍一下原理：首先 node_modules 目录不会参与编译、上传和打包中，所以小程序想要使用 npm 包必须走一遍“构建 npm”的过程，在最外层的 node_modules 的同级目录下会生成一个 miniprogram_npm 目录，里面会存放构建打包后的 npm 包，也就是小程序真正使用的 npm 包。构建打包分为两种：小程序 npm 包会直接拷贝构建文件生成目录下的所有文件到 miniprogram_npm 中；其他 npm 包则会从入口 js 文件开始走一遍依赖分析和打包过程（类似 webpack）。寻找 npm 包的过程和 npm 的实现类似，从依赖 npm 包的文件所在目录开始逐层往外找，直到找到可用的 npm 包或是小程序根目录为止。构建完成后还需要确认项目已勾选了「使用 npm 模块」。3. 在项目中使用第三方模块在我们之前实战项目中，在首页中测试下此 npm 模块的加载。<view class=\"doc-container\">\r\n  <view class=\"doc-title\">今日精选</view>\r\n\r\n  <datepicker value=\"\" bindchange=\"bindSolarChange\">\r\n    <button type=\"default\">公历</button>\r\n  </datepicker>\r\n  <datepicker value=\"\" chinese=\"true\" bindchange=\"bindLunarChange\">\r\n    <button type=\"default\">农历</button>\r\n  </datepicker>\r\n\r\n  <block wx:for=\"\" wx:key=\"\">\r\n    <view class=\"list\" data-para=\"\" bindtap=\"tapItem\">\r\n      <view class=\"view_preinfo\">\r\n        <text class=\"list_preinfo\"> / </text>\r\n      </view>\r\n      <text class=\"list_title\"></text>\r\n      <view>\r\n        <block wx:for=\"\" wx:key=\"\">\r\n          <text class=\"list_tag\" style=\"border: solid 1px ;\"></text>\r\n        </block>\r\n      </view>\r\n    </view>\r\n  </block>\r\n</view>在页面中布局完 datepicker 后，保存并完成项目的编译后，点击按钮即可看到组件的加载情况。"}
{"title": "微信小程序营销组件wxapp-market ", "author": "Rolan", "pub_time": "2018-10-19 00:08", "content": "wxapp-market 是基于微信小程序的营销组件，用于快速开发营销玩法类小程序项目页面，包含大转盘、刮刮乐、老虎机、水果机、九宫格翻纸牌、摇一摇、手势解锁等多种营销组件。使用1.拉取仓库git clone git@github.com:o2team/wxapp-market.git\r\n\r\n2.组件文件大转盘 (Big wheel) : /components/wheel/刮刮乐 (Scratch tickets) : /components/scratch/老虎机 (Slot machine) : /components/slotMachine/水果机 (Fruit machine) : /components/fruitMachine/九宫格翻纸牌 (Grid card) : /components/card/摇一摇 (Shake) : /components/shake/手势解锁 (Gesture lock) : /components/lock/3.调用以大转盘组件为例WXSS中引用样式：@import \"../../components/wheel/wheel.wxss\"\r\nWXML中引用结构：<import src=\"../../components/wheel/wheel.wxml\"/>\r\nJS中引用：import Wheel from \"../../components/wheel/wheel.js\"\r\nJS中实例调用：  new Wheel(this,{\r\n    areaNumber: 8,   //抽奖间隔\r\n    speed: 16,       //转动速度\r\n    awardNumer: 2,   //中奖区域从1开始\r\n    mode: 1,         //1是指针旋转，2为转盘旋转\r\n    callback: (idx, award) => {      //结束回调， 参数对应宫格索引，对应奖项    \r\n    }\r\n  })\r\n运行效果：大转盘其他wxapp-market项目地址：https://github.com/o2team/wxa..."}
{"title": "小程序的全栈开发新时代 ", "author": "Rolan", "pub_time": "2018-10-31 00:46", "content": "本文由heyli发表于云+社区专栏什么是小程序·云开发小程序·云开发是微信团队和腾讯云团队共同研发的一套小程序基础能力，简言之就是：云能力将会成为小程序的基础能力。整套功能是基于腾讯云全新推出的 云开发(Tencent Cloud Base)所研发出来的一套完备的小程序后台开发方案。小程序·云开发为开发者提供完整的云端流程，简化后端开发和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代。该解决方案目前提供三大基础能力支持：存储：在小程序前端直接上传/下载云端文件，在小程序云控制台可视化管理数据库：一个既可在小程序前端操作，也能在云函数中读写的文档型数据库云函数：在云端运行的代码，微信私有协议天然鉴权，开发者只需编写业务逻辑代码未来，我们还会集成更多的服务能力，为小程序提供更强有力的云端支持。如何使用小程序·云开发上面就是小程序·云开发简单的使用图谱：在小程序端，直接用官方提供的接口，在云函数端，直接用官方提供的 Node SDK，就可以操作你云的资源。以前开发小程序所担忧的数据库搭建、文件系统部署，通通没有。你只需要有在小程序开发 IDE 里面的 云开发 ，开通一下，填写环境 ID ，便可以拥有小程序的云能力！当然，其实用云开发，并不排斥原有的后台架构，通过下面的架构，你也可以无缝与原有的后台服务兼容，也简化了一些小程序鉴权的逻辑：接下来，我会分别从小程序端、服务端讲述如何使用这些云资源。使用云能力小程序端客户端，这里是指在小程序端中。如果要使用云开发能力，请做以下配置：在 app.json / game.json 中， 中增加字段 \"cloud\": trueproject.config.json 中增加了字段 cloudfunctionRoot 用于指定存放云函数的目录初始化云开发能力：//app.js\r\nApp({\r\n  onLaunch: function () {\r\n    wx.cloud.init({\r\n        traceUser: true // 用户信息会显示在云开发控制台的用户面板中\r\n    });\r\n  }\r\n});小程序端初始化能力文档在用户管理中会显示使用云能力的小程序的访问用户列表，默认以访问时间倒叙排列，访问时间的触发点是在小程序端调用 wx.cloud.init 方法，且其中的 traceUser 参数传值为 true 。服务端如果你想在云函数中，操作文件、数据库和云函数资源，你可以使用我们提供的服务端 SDK 进行操作。首先，进入到你的某个云函数中，安装以下依赖包：npm i --save tcb-admin-node在云函数中初始化// 初始化示例\r\nconst app = require('tcb-admin-node');\r\n\r\n// 初始化资源\r\n// 云函数下不需要secretId和secretKey。\r\n// env如果不指定将使用默认环境\r\napp.init({\r\n  secretId: 'xxxxx',\r\n  secretKey: 'xxxx', \r\n  env: 'xxx'\r\n});\r\n\r\n//云函数下使用默认环境\r\napp.init()\r\n\r\n//云函数下指定环境\r\napp.init({\r\n  env: 'xxx'\r\n});服务端初始化文档存储云开发提供存储空间、上传文件、下载文件、CDN加速文件访问等能力,开发者可以在小程序端与服务端通过 API 使用这些能力。小程序端// 选择图片\r\nwx.chooseImage({\r\n    success: dRes => {\r\n        // 上传图片\r\n        const uploadTask = wx.cloud.uploadFile({\r\n            cloudPath: `${Date.now()}-${Math.floor(Math.random(0, 1) * 10000000)}.png`, // 随机图片名\r\n            filePath: dRes.tempFilePaths[0], // 本地的图片路径\r\n            success: console.log,\r\n            fail: console.error\r\n        });\r\n    },\r\n    fail: console.error,\r\n});小程序端存储文档服务端const app = require('tcb-admin-node');\r\napp.init();\r\n\r\napp.uploadFile({\r\n    cloudPath: \"cover.png\",\r\n    fileContent: fs.createReadStream(`${__dirname}/cover.png`)\r\n}).then((res) => {\r\n    console.log(res);\r\n}).catch((err) => {\r\n    console.error(err);\r\n});;控制台上传好的文件，就会出现在控制台中，如下图。你可以在控制台里删除、下载或者查看图片的详情。你还可以控文件整体的权限，这里还有一些具体的介绍。服务端存储文档数据库小程序云提供文档型数据库 ( document-oriented database )，数据库包含多个集合（相当于关系型数据中的表），集合近似于一个 JSON 数组，数组中的每个对象就是一条记录，记录的格式是 JSON 文档。每条记录都有一个 _id 字段用以唯一标志这条记录、一个 _openid 字段用以标志记录的创建者，即小程序的用户。开发者可以自定义 _id ，但不可在小程序端自定义（在服务端可以） _openid 。 _openid 是在文档创建时由系统根据小程序用户默认创建的，开发者可使用其来标识和定位文档。数据库 API 分为小程序端和服务端两部分，小程序端 API 拥有严格的调用权限控制，开发者可在小程序内直接调用 API 进行非敏感数据的操作。对于有更高安全要求的数据，可在云函数内通过服务端 API 进行操作。云函数的环境是与客户端完全隔离的，在云函数上可以私密且安全的操作数据库。数据库 API 包含增删改查的能力，使用 API 操作数据库只需三步：获取数据库引用、构造查询/更新条件、发出请求。切记，在操作数据库前，请先在控制台中创建 collection 。小程序端const db = wx.cloud.database();\r\n\r\n// 插入数据\r\ndb.collection('photo').add({\r\n    data: {\r\n        photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg',\r\n        title: '风景'\r\n    }\r\n});\r\n\r\n// 提取数据\r\ndb.collection('photo').get().then((res) => {\r\n    let data = res.data;\r\n    console.log(data);\r\n});\r\n\r\n// 输出\r\n// 在小程序端， _openid 会自动插入到数据库中\r\n{\r\n    photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg',\r\n    title: '风景',\r\n    _openid: 'oLlMr5FICCQJV-QgVLVzKu1212341'\r\n}小程序端数据库文档服务端const app = require('tcb-admin-node');\r\napp.init();\r\nconst db = app.database();\r\n\r\ndb.collection('photo').limit(10).get().then((res) => {\r\n    console.log(res);\r\n}).catch((err) => {\r\n    console.error(err);\r\n});\r\n\r\n// 输出\r\n// 因为是在服务端，其它用户的也可以提取出来\r\n{\r\n    photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg',\r\n    title: '风景',\r\n    _openid: 'oLlMr5FICCQJV-QgVLVzKu1342121'\r\n}\r\n{\r\n    photo: 'cloud://tcb-xxx/0dc3e66fd6b53641e328e091ccb3b9c4e53874232e6bf-ZxSfee_fw658.jpg',\r\n    title: '美女',\r\n    _openid: 'DFDFEX343xxdf-QgVLVzKu12452121'\r\n}\r\n{\r\n    photo: 'cloud://tcb-xxx/104b27e339bdc93c0da15a47aa546b6e9c0e3359c315-L8Px2Y_fw658.jpg',\r\n    title: '动物',\r\n    _openid: 'DFDFEX343xxdf-QgVLVzKu1342121'\r\n}服务端数据库文档控制台可以在控制台里，看到用户操作的数据，你也可以自己在控制台上添加、更新或删除数据。如果数据量庞大，可以设置索引提供查询的效率。数据库也可以通过设置权限，管控每个 collection 。云函数云函数是一段运行在云端的代码，无需管理服务器，在开发工具内一键上传部署即可运行后端代码。开发者可以在云函数内获取到每次调用的上下文（ appid 、 openid 等），无需维护复杂的鉴权机制，即可获取天然可信任的用户登录态（ openid ）。小程序端wx.cloud.callFunction({\r\n    name: 'addblog', // 云函数名称\r\n    data: { // 传到云函数处理的参数\r\n        title: '云开发 TCB',\r\n        content: '存储、数据库存、云函数'\r\n    }\r\n}).then(res => {\r\n    console.log(res)\r\n}).catch((err) => {\r\n    console.error(err);\r\n});小程序端云函数文档服务端const app = require(\"tcb-admin-node\");\r\napp.init();\r\n\r\napp.callFunction({\r\n    name: 'addblog', // 云函数名称\r\n    data: { // 传到云函数处理的参数\r\n        title: '云开发 TCB',\r\n        content: '存储、数据库存、云函数'\r\n    }\r\n}).then((res) => {\r\n    console.log(res);\r\n}).catch((err) => {\r\n    console.error(err);\r\n});服务端云函数文档控制台上传好之后的云函数，都会在这里罗列出来。每次调用云函数，都可以在这里看到日志，还可以构造测试的参数，用于调试。语法糖大部份的接口，目前都支持两种写法，分别是Promise 和 Async/Await，本节以 callFunction作为例子，在 云函数 中介绍这两种写法。 Async/Awai t 本质上是基于 Promise 的一种语法糖，它只是把 Promise 转换成同步的写法而已。Promiseconst app = require(\"tcb-admin-node\");\r\napp.init();\r\n\r\nexports.main = (event, context, callback) => {\r\n    app.callFunction({\r\n        name: 'addblog', // 云函数名称\r\n        data: { // 传到云函数处理的参数\r\n            title: '云开发 TCB',\r\n            content: '存储、数据库存、云函数'\r\n        }\r\n    }).then((res) => {\r\n        console.log(res);\r\n        callback(null, res.data);\r\n    }).catch((err) => {\r\n        callback(err);\r\n    });\r\n};Async/Awaitconst app = require(\"tcb-admin-node\");\r\napp.init();\r\n\r\nexports.main = async (event, context) => {\r\n    let result = null;\r\n\r\n    try {\r\n        result = await app.callFunction({\r\n            name: 'addblog', // 云函数名称\r\n            data: { // 传到云函数处理的参数\r\n                title: '云开发 TCB',\r\n                content: '存储、数据库存、云函数'\r\n            }\r\n        });\r\n    }\r\n    catch (e) {\r\n        return e;\r\n    }\r\n\r\n    return result;\r\n};在云函数里使用，由于是 Node 8.9 或以上的环境，因此天然支持 Async/Await 诘法，但在小程端要使用的话，需要额外引入 Polyfill ，比如这个开源的项目： regenerator开发者资源由于小程序·云开发是基于腾讯云的云开发开发的功能，因此在腾讯云与小程序两边都有不少的开发者资源，这里供大家参阅读：腾讯云开发者资源及文档腾讯云云开发平台官方 Github微信小程序·云开发文档"}
{"title": "大风起兮云飞扬！ 小程序云开发实战奉上 ", "author": "Rolan", "pub_time": "2018-11-12 00:12", "content": "小程序云开发发布有一段时间了，最近着手做了一个基于云开发的小程序项目--仿《微博鲜知》，来自新浪的这款全新风格的小程序虽然界面非常简约清新，但是内部还是内藏了很多玄机，在实现的路上遇上了不少坎坷，在这里分享给大家。希望给大家提供一些思路。先展示一下最终结果： 更多图片资源在这里一、 组件化思想开发一个完整的小程序时，我们应该先分析其内部的结构。重复的结构抽离出来作为组件，组件非常的灵活，可以嵌入一个页面或多个页面。在上面的gif图中我们可以看到首页的内容是一个个的新闻块。 虽然这个新闻块只在首页中使用到，但是我还是把它抽离成了一个组件。这样做的好处是页面结构将会更加的清晰，并且耦合度降低，比如想换个主界面风格时，你可以直接换另一个组件添加进来。还有新闻内部页面中，有多个小标题，每个小标题里面嵌入了不等数量的新闻。如果不是采用组件化的话，到时候inner页面的wxml结构就会乱成一锅粥。所以这里的建议是尽量组件化分离开来。对于组件很陌生可以先看我的之前的这篇文章组件化开发tabbar下面是项目的页面与组件目录：二、数据库设计既然是“全栈”，后端肯定要搞搞。后端的核心就是数据。那么我们就先把数据库分析一下。这里我是这样分析的，从页面获得字段，然后再理解数据间的关联，如一对多，一对一。这里我构建了5个集合fresh-mainNews 主页新闻集合subNews字段是一个数列，存储着fresh-subNews Doc的_id，这样就将这两个集合绑定了起来，在后面我们会讲到在云函数中把这两个集合融合起来返回一个新的数据变得完整一些的集合。有人可能会问，云数据库不是noSQL吗，为什么不把所有数据全部整合到一个全部的JSON,那样就可以只调用一次JSON。我的理解是： 我们查询只是需要查询我们想要的数据，不需要的数据可以等需要的时候再根据关联去请求。 比如这个项目中的首页新闻块，每一个新闻块内部都关联着大量的子新闻，第一次加载就全部把这个小程序需要的所有数据都加载出来就有点疯狂了。fresh-subNews 内部页面新闻小标题集合fresh-comments 评论集合fresh-detailNews 详细新闻集合fresh-users 用户集合 这里查看更多的数据库信息三、页面构建讲到这里就该说页面的构建了。页面可以想象成一个架子，一个承载数据的容器。页面通上数据，就变得活起来。MVVM，数据驱动视图。交互靠数据，组件间的通信，组件与页面间的通信都是数据。{{}} -> 就像是流浪法师大招神奇的传送门。后面会将给出一个精彩的组件通信例子（点击目录如何实现标题栏置顶）。四、关于云开发。云开发三大核心：云函数：通俗的理解就是你写的函数在云端运行，可以把复杂的业务逻辑放在云函数里数据库：一个既可在小程序前端操作，也能在云函数中读写的 JSON 数据库存储：在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理，可以上传照片下载照片，或者一些其他文件。在这里详细介绍一下操作云函数提取数据库的流程, 这里我们以获取首页数据为例：先在云函数目录新建一个函数：mianNewsGet2. 打开该云函数的index.js 我这里用的是vsCode+node+yarn环境。 open in terminal(在终端中打开)，yarn一下，添加依赖。 或者参考云函数官方文档编写云函数查询数据// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n// 云函数初始化\r\ncloud.init()\r\n//获取数据库句柄\r\nconst db = cloud.database()\r\n\r\n// 云函数入口函数\r\nexports.main = async () => {\r\n    const mainNewsList = [];\r\n    //向fresh-mainNews集合中获得全部数据、因为数据库里面现在存的数据不多，\r\n    //如果多的话可以设置一个limit以及skip来获取特定数量的数据\r\n    const mainNews = await db.collection(\"fresh-mainNews\").get();  \r\n    for(let i = 0; i < mainNews.data.length; i++) {\r\n      const mainNew = mainNews.data[i];\r\n      let user_id = mainNew.setMan;\r\n      //条件查询 获取特定id的docments\r\n      const user = await db.collection('fresh-users').where({\r\n        _id: user_id\r\n      }).get();\r\n      //限定条件如果有多条，只添加一条进去\r\n      if (user.data.length > 0) {\r\n        mainNew.setMan = user.data[0]\r\n      }\r\n      //这个循环是集合的拼接\r\n      for (let i = 0; i < mainNew.subNews.length; i++) {\r\n        const subNews = await db.collection(\"fresh-subNews\").where({\r\n          _id: mainNew.subNews[i]\r\n        }).get();\r\n        if (subNews.data.length > 0) {\r\n          mainNew.subNews[i] = subNews.data[0]\r\n        }\r\n      }  \r\n      //把拼好的docments挨个放进mainNewsList里面也就是形成了一个全新的\r\n      //融合的数据更为完整的JSON数组   \r\n      mainNewsList.push(mainNew);\r\n    }\r\n    return mainNewsList;\r\n}\r\n复制代码在首页index.js里面onLoad函数里面调用云函数var that = this;\r\n    wx.cloud.callFunction({\r\n    // 声明调用的函数名\r\n      name: 'mainNewsGet',\r\n    // data里面存放的数据可以传递给云函数的event  效果：event.a = 1\r\n      data: {\r\n        a: 1\r\n      }\r\n    }).then(res => {\r\n    //res.result的值是云函数的return的值\r\n    //这里将查询的结果放入mainNewsList中，然后就可以在wxml中调用数据\r\n      that.setData({\r\n        mainNewsList: res.result\r\n      })\r\n    //打印一下结果看看有没有成功获取数据\r\n      console.log(this.data.mainNewsList)\r\n    }).catch(err => {\r\n      console.log(err)\r\n    })\r\n复制代码获取的数据：我们可以看到原本的subNews里面本来存放的是_id的数值，融合后变成_id对应的整个doc变化: [_id1.value,_id2.value~~] ---> [{_id1:value,key1:value1,key2:value2},~~~]云函数的调用，数据库的查询。就是这么简单的四步，云开发的门槛很低，功能也很强大,只要你去尝试，很轻松的就能够实现。五、关于时间格式化。写在utils文件夹里添加xx.jsconst formatTime = date => {\r\n    var dateNow = new Date();\r\n    var date = new Date(date);\r\n    const hour = date.getHours()\r\n    const minute = date.getMinutes()\r\n    var times = (dateNow - date) / 1000;\r\n    let tip = '';\r\n    if (times <= 0) {\r\n        tip = '刚刚'\r\n        return tip;\r\n    } else if (Math.floor(times / 60) <= 0) {\r\n        tip = '刚刚'\r\n        return tip;\r\n    } else if (times < 3600) {\r\n        tip = Math.floor(times / 60) + '分钟前'\r\n        return tip;\r\n    }\r\n    else if (times >= 3600 && (times <= 86400)) {\r\n        tip = Math.floor(times / 3600) + '小时前'\r\n        return tip;\r\n    } else if (times / 86400 <= 1) {\r\n        tip = Math.ceil(times / 86400) + '昨天'\r\n    }\r\n    else if (times / 86400 <= 31 && times / 86400 > 1) {\r\n        tip = Math.ceil(times / 86400) + '天前'\r\n    }\r\n    else if (times / 86400 >= 31) {\r\n        tip = '好几光年前~~'\r\n    }\r\n    else tip = null;\r\n    return tip + [hour, minute].map(formatNumber).join(':')\r\n}\r\n\r\nconst formatNumber = n => {\r\n    n = n.toString()\r\n    return n[1] ? n : '0' + n\r\n}\r\n\r\n//将这个接口暴露\r\nmodule.exports = {\r\n    formatTime: formatTime,\r\n}\r\n复制代码在需要的页面的xx.js里面引入import { formatTime } from '../../utils/api.js';格式化获取的时间数据let mainNewsList = that.data.mainNewsList\r\n      for(let i =0; i < mainNewsList.length;i++) {\r\n        let time = formatTime(mainNewsList[i].time)\r\n    //这是setData()的数组用法，会经常用到\r\n        var str = 'mainNewsList['+i+'].time' \r\n        that.setData({\r\n          [str]:time\r\n        }) \r\n    }\r\n复制代码六、 关于一些很有用但是你可能不知道的小程序技巧全屏显示图片，能够实现多张图片左右滑动并且还有数字索引现在在屏幕上，并且长按还能收藏以及下载(之前不知道这个API还特地做了一个组件来实现类似功能，简直吐血)wx.previewImage({\r\n        current: imgUrl, // 当前显示图片的http链接\r\n        urls: imagePack // 需要预览的图片http链接列表\r\n      })\r\n复制代码非常方便的一个API能够滑动到某个位置wx.pageScrollTo({\r\n    scrollTop: 一个数值（自带px单位）,   //滚动到数值所在的位置\r\n    duration: 50                          //执行滚动所花的时间\r\n    })\r\n复制代码查询节点query.selectAll('类名')及query.select('#id')官方文档var that = this\r\nlet catalogIndex = that.data.catalogIndex;\r\nquery.selectAll('类名').boundingClientRect(function (rects) {\r\n        rects.forEach(function (rect) {\r\n          rect.top     // 节点的上边界坐标st,\r\n//还有一些别的属性，这个查询节点是后面讲到的目录跳转关键API\r\n          })\r\n        })\r\n      }).exec()\r\n    },\r\n复制代码setData()一些技巧。//给数组设置值 还可以有var xx = 'xx['+idx+'].key'的形式\r\nvar doneList = 'doneList['+idx+']'\r\n      that.setData({\r\n        [doneList]: true,\r\n      })\r\n复制代码有时候我们还可以先改变某个数的值再去setData()它，这是setData()的一个很好用的技巧，不过需要去运用一下才好理解 如：dataPack.likeNum = (supLikeNum===-1 ? dataPack.likeNum: supLikeNum);\r\n    this.setData({\r\n      comment: dataPack,\r\n    })\r\n复制代码七、 项目最精彩的两个部分1.点击目录栏页面将相应新闻栏置顶，先看下效果这个效果在别的小程序里面都没有见过，应该是微博鲜知独创的，在这里先对原作者表达一下敬意。内部的构造也是非常巧妙，不同于我们常见的外卖的锚点定位。我们先来分析一波：mvvm，视图是由数据驱动的，我们要透过现象看本质，去思考底层的数据，这样我们很快就会有思路:点击目录栏的item项如果绑定了一个data-idx等于循环的索引，可以在e.currentTarget.dataset.idx拿到这个item的索引。我们把这个数据通过组件通信传递到inner页面,然后在由inner页面把数据转交给subNews并且在inner页面的js中绑定subNews的goTop事件，这样产生了一个catalog组件->inner页面->subNews的关联，数据为item的索引。触发catalog就能够控制subNews组件的移动，是不是还有点绕， ok show the code: 1.catalog/index.wxml<block wx:for=\"{{subNews}}\" wx:for-item=\"subNewsItem\" wx:for-index=\"idx\" wx:key=\"index\">\r\n            <view class=\"subTitle-item\" bind:tap=\"scrollFind\"\r\n    //关键1：绑定item索引\r\n            data-hi=\"{{idx}}\">\r\n <text>{{subNewsItem.title}}</text>\r\n                </view>\r\n        </block>\r\n复制代码获得索引，并绑定inner页面 catalog/index.jsscrollFind: function(e) {\r\n      //点击后 实现inner页面特定新闻小标题置顶\r\n      let curIndex = e.currentTarget.dataset.hi\r\n      // 关键2： 与inner页面取得联系\r\n      var myEventDetail = {index: curIndex} // detail对象，提供给事件监听函数\r\n      var myEventOption = {} // 触发事件的选项\r\n      this.triggerEvent('catalog', myEventDetail)\r\n    }\r\n复制代码inner/inner.js 取得与catalog的通信onCatalog: function(e) {\r\n    e.detail // 自定义组件触发事件时提供的detail对象\r\n    console.log(e.detail.index)\r\n    //关键:3 把索引存储到data\r\n    this.setData({\r\n      catalogIndex : e.detail.index\r\n    })\r\n    \r\n//关键4: 页面可以通过组件的id取得其页面引用组件的方法\r\n// this.subNews=this.selectComponent(\"#subNews\")\r\n    this.subNews.goTop();\r\n  },\r\n复制代码给subNews传catalogIndex，并且标上id<subNews ~省略~ catalogIndex=\"{{catalogIndex}}\" id=\"subNews\"></subNews>\r\n复制代码在subNews中先定义一个图片加载事件，这样在页面加载完成时会触发其绑定的事件，这是来自瀑布流的灵感。可以在图片加载出来的时候触发onImageLoad函数，而在这个函数里我们可以干一些准备的事情。//subNews/index.wxml\r\n//一个看不见的图片，来自瀑布流的灵感，能够产生主动触发的事件\r\n<view style=\"display:none\">\r\n  <image src=\"{{mainImg}}\" bindload=\"onImageLoad\"></image>\r\n</view>\r\n复制代码//subNews/index.js\r\nonImageLoad: function () {\r\n      var that = this\r\n      let offsetList = that.data.offsetList;\r\n      const query = wx.createSelectorQuery().in(this)\r\n//之前讲到过的API获取节点信息，我们把它存储到offsetList偏移量数组，他存储着每一个节点在屏幕的位置，\r\n//配合wx.pageScrollTo可以达到新闻栏置顶的效果\r\n      query.selectAll('.subNews-wrapper').boundingClientRect(function (rects) {\r\n        rects.forEach(function (rect) {\r\n          rect.top     // 节点的上边界坐标\r\n          offsetList.push(rect.top)\r\n          that.setData({\r\n            offsetList,\r\n          })\r\n        })\r\n      }).exec()\r\n    },\r\n复制代码给标题栏绑定上goTop事件goTop: function (e) {\r\n      var that = this\r\n      let catalogIndex = that.data.catalogIndex;\r\n      //这里offsetList是一个data里面的数据，来保存所有的节点的上边距坐标\r\n      let offsetList = that.data.offsetList;\r\n      wx.pageScrollTo({\r\n            scrollTop: offsetList[catalogIndex],   //滚动到具体数值所在的位置\r\n            duration: 50                          //执行滚动所花的时间\r\n          })\r\n    }\r\n复制代码至此，你就实现了这个看似简单却非常巧妙的功能，组件->页面->组件，秀得眼花缭乱。如果还是有些不理解的话，等下可以下载我的代码去看。至于为什么要弄一个图片的加载然后触发那个事件呢，这是因为如果你把获取offsetList偏移量数组的函数放在goTop里的话，进入页面第一次的点击会无效，这样产生的体验肯定是非常不舒服的。2. 点赞优化先展示一下效果：先说一下优化的是什么：点赞效果的延迟极大降低因为点赞的变化是由用户产生的一个交互，传统的观点就是用户点赞->后端更新数据->前端拉取数据->数据驱动视图的变化。真实的体验就是，非常的慢，慢到点击后2秒才能看到点赞的效果，这种差劲的交互简直就是一场灾难。先给传统的、局部刷新优化的，效果还是很差的一段代码：for(let i = 0; i< that.data.comments.length; i++)\r\n        {\r\n    //当点击该个评论时，只更新这一条数据\r\n          if (i == idx) {\r\n            var str = 'comments['+idx+'].likeNum'\r\n            that.setData({\r\n              [str]:res.result.data.likeNum,\r\n            })\r\n            console.log(likeNumList[idx])\r\n          }\r\n        } \r\n复制代码优化后：data: {\r\n    doneList: [],      //是否按下\r\n    likeNumList: [],  //模拟点赞数数组\r\n    likeAdd: 10,      //点赞每次增加数，根据你的设置来，你后端每次加1这里就写1\r\n  },\r\n  \r\nvar doneList = 'doneList['+idx+']'\r\nlikeNumList[idx] = (that.data.comments[idx].likeNum + that.data.likeAdd);\r\n      that.setData({\r\n        likeNumList,\r\n       [doneList]: true,\r\n        likeAdd: that.data.likeAdd+10\r\n      })\r\n复制代码<text class=\"dianzanNum\">{{likeNumList[idx]?likeNumList[idx]:item.likeNum}}</text>\r\n复制代码优化思路是怎么样的呢？用一个数组来存放/模拟更新的数据，如果数字的索引位置被赋值，则页面直接显示这个更新的数字，也是异曲同工之妙。因为用户关心的是数据的变化，我们可以先把数据的变化产生，至于数据后端的变化让他异步慢慢的去做。从这里发散思想，是不是评论功能也能够用这样的思路同样去达到极致的速度与交互体验呢。点赞的延迟几乎为无，体验到点赞的极致快感，让人几乎停不下来~~（暗示一波）篇幅所限，文章到这里就差不多了。项目地址: github-HappyBirdwe-weiboFresh 奉上精心写的项目，细节很不错哟，欢迎大家☆☆☆☆star☆☆☆☆结语：学习的道路上免不了坎坷，希望文章的分享能够为大家提供一些思路，学习的过程减少一点弯路，这就是这篇文章最大的价值，欢迎大家提问及指正。最后在这里感谢一下:腾讯云提供的技术支持☆ 新浪团队的微博鲜知作者☆ 掘金这个优秀的平台☆ 点赞动作超帅的你☆微博鲜知小程序官方传送门：体验真的很不错哦，界面非常简约，大家可以体验一波"}
{"title": "一周学会小程序-日播天气 ", "author": "Rolan", "pub_time": "2018-11-12 00:21", "content": "前言：欢迎收看一周学会小程序系列2-日播天气。看了苹果的自带天气软件，发现很简单使用。在小程序上看了一下天气的小程序，没有发现类似的，于是就模仿了一个。虽然模仿的不是很像，请大家不要见笑！主要功能：1. 通过定位或选取位置获取当天详细天气预报（1）天气情况，包括温度「当前温度、最低温度和最高温度」、天气、空气质量、湿度、风向和风速、日出和日落、气压、能见度等； （2）生活指数，包括舒适度、穿衣、感冒、运动、旅游、紫外线强度、洗车、污染扩散等。2. 24小时天气预报3. 7天天气预报细节：增加类似于App的启动页具体功能实现：1.接口部分：使用京东万象提供的免费天气接口（京东万象官网地址）2.页面部分：（1）布局构思：主页面使用小程序推荐flex列布局，使用4个模板（当前天气温度信息模板、24小时模板、7天天气模板、生活指数模板），2个scrollview（24小时、7天天气预报） （2）详细模板使用：以当前天气信息为例（单一样式）：.wxss\r\n<template name=\"nowTemplate\">\r\n  <view class='template-bgview'>\r\n    <view class='temperature-bg'>\r\n      <text class='temperature-text'>{{nowweather.tmp}}</text>\r\n      <text class='temperature-degree'>°</text>\r\n    </view>\r\n\r\n    <view class='weather-bg'>\r\n      <text>{{nowweather.cond.txt}}</text>\r\n      <view class='weather-line'>|</view>\r\n      <view class='aqi-bg'>\r\n        <text class='aqi-text'>{{aqi.aqi + \" \" + aqi.qlty}}</text>\r\n        <!-- <text>{{aqi.aqi}}</text> -->\r\n      </view>\r\n    </view>\r\n\r\n    <view class='winter-bg'>\r\n      <text class='hum-text'>{{\"湿度 \"+nowweather.hum+\"%\" + \"  \"}}</text>\r\n      <text class='wind-text'>{{\"  \" + nowweather.wind.dir+\" \"+nowweather.wind.sc+\"级\"}}</text>\r\n    </view>\r\n  </view>\r\n</template>\r\n\r\n.wxss\r\n.template-bgview {\r\n  width: 100%;\r\n  /* height: 175px; */\r\n  align-items: center;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n}\r\n\r\n.temperature-bg {\r\n  /* align-items: center; */\r\n  display: flex;\r\n  flex-direction: row;\r\n  justify-content: center;\r\n}\r\n\r\n.temperature-text {\r\n  font-size: 160rpx;\r\n  font-weight: lighter;\r\n}\r\n\r\n.temperature-degree {\r\n  font-size: 80rpx;\r\n  font-weight: lighter;\r\n}\r\n\r\n.weather-bg {\r\n  display: flex;\r\n  flex-direction: row;\r\n  justify-content: center;\r\n}\r\n\r\n.weather-line {\r\n  margin-left: 5px;\r\n  color: gray;\r\n}\r\n\r\n.aqi-bg {\r\n  margin-left: 5px;\r\n  background-color: yellow;\r\n  border-radius: 3px;\r\n}\r\n\r\n.aqi-text {\r\nmargin-left: 5px;\r\nmargin-right: 5px;\r\n}\r\n\r\n.winter-bg {\r\n  margin-top: 10px;\r\n  display: flex;\r\n  flex-direction: row;\r\n  justify-content: center;\r\n}\r\n\r\n.hum-text {\r\n  margin-right: 10px;\r\n}\r\n\r\n.wind-text {\r\n  margin-left: 10px;\r\n}\r\n复制代码模板使用： 1.模板页面导入 .wxml<import src=\"../template/now-template.wxml\" />\r\n复制代码.wxss@import \"../template/now-template.wxss\";\r\n复制代码2.外层嵌套view使用<view class='now-view'>\r\n      <template is=\"nowTemplate\" data=\"{{nowweather:weather.now, aqi:weather.aqi}}\" />\r\n    </view>\r\n复制代码以7天天气模板为例（列表样式）： 使用方法相同，具体wxml和wxss代码如下wxml\r\n<template name=\"sevenDays\">\r\n  <view class='template-sevendays'>\r\n    <view class='week' wx:if=\"{{index==0}}\">{{item.week.week+\"  (今天)\"}}</view>\r\n        <view class='week' wx:else>{{item.week.week+\" (\"+item.week.month+\"/\"+item.week.day+\")\"}}</view>\r\n\r\n    <view class='condition' wx:if=\"{{isnight}}\">{{item.cond.txt_n}}</view>\r\n    <view wx:else class='condition'>{{item.cond.txt_d}}</view>\r\n    <view class='hight-temperature'>{{item.tmp.max+\"°\"}}</view>\r\n    <view class='low-temperature'>{{item.tmp.min+\"°\"}}</view>\r\n  </view>\r\n</template>\r\n\r\n\r\nwxss\r\n.template-sevendays {\r\n  width: 100%;\r\n  height: 30px;\r\n  display: flex;\r\n  flex-direction: row;\r\n}\r\n\r\n.week {\r\n  margin-left: 10px;\r\n  flex: 4;\r\n}\r\n\r\n.condition {\r\n  text-align: center;\r\n  flex: 4;\r\n  /* width: 40%; */\r\n}\r\n\r\n.hight-temperature {\r\n  text-align: center;\r\n  flex: 1;\r\n}\r\n\r\n.low-temperature {\r\n  text-align: center;\r\n  flex: 1;\r\n}\r\n复制代码3.数据交互部分：原理：使用腾讯地图api获取当前位置经纬度，通过经纬度调用腾讯的逆地理编码函数获取当前位置信息，然后再通过当前位置获取当前的天气信息。解析天气信息数据，完成页面和数据的交互绑定。 （1）数据解析// 解析天气信息函数 构建数据赋值\r\n  analysisData: function(weather) {\r\n    var that = this;\r\n    var str = JSON.stringify(weather);\r\n    var hourly_forecast = [];\r\n    hourly_forecast.push({\r\n      date: \"现在\",\r\n      cond: weather.now.cond,\r\n      tmp: weather.now.tmp\r\n    });\r\n    // 24小时 数组\r\n    for (var i = 0; i < weather.hourly_forecast.length; i++) {\r\n      var hourDic = weather.hourly_forecast[i];\r\n      hourDic.date = hourDic.date.substr(11, 5);\r\n      hourly_forecast.push(hourDic);\r\n    }\r\n\r\n    // 7天天气 数组\r\n    var daily_forecast = [];\r\n    // 使用forEach遍历\r\n    weather.daily_forecast.forEach(function (dailyDic) {\r\n      dailyDic.week = util.dateLater(dailyDic.date, 0);\r\n      daily_forecast.push(dailyDic);\r\n    });\r\n \r\n    // 生活指数数组 按照指定顺序排列\r\n    var suggestion = [];\r\n    var comf = weather.suggestion.comf;\r\n    comf.title = \"舒适度\";\r\n    comf.id = 0;\r\n    suggestion.push(comf);\r\n\r\n    var drsg = weather.suggestion.drsg;\r\n    drsg.title = \"穿衣\";\r\n    drsg.id = 1;\r\n    suggestion.push(drsg);\r\n\r\n    var flu = weather.suggestion.flu;\r\n    flu.title = \"感冒\";\r\n    flu.id = 2;\r\n    suggestion.push(flu);\r\n\r\n    var sport = weather.suggestion.sport;\r\n    sport.title = \"运动\";\r\n    sport.id = 3;\r\n    suggestion.push(sport);\r\n\r\n    var trav = weather.suggestion.trav;\r\n    trav.title = \"旅游\";\r\n    trav.id = 4;\r\n    suggestion.push(trav);\r\n\r\n    var uv = weather.suggestion.uv;\r\n    uv.title = \"紫外线强度\";\r\n    uv.id = 5;\r\n    suggestion.push(uv);\r\n\r\n    var cw = weather.suggestion.cw;\r\n    cw.title = \"洗车\";\r\n    cw.id = 6;\r\n    suggestion.push(cw);\r\n\r\n    var air = weather.suggestion.air;\r\n    air.title = \"污染扩散\";\r\n    air.id = 7;\r\n    suggestion.push(air);\r\n    this.setData({\r\n      weather: {\r\n        hourly_forecast: hourly_forecast,\r\n        daily_forecast: daily_forecast,\r\n        aqi: weather.aqi.city,\r\n        now: weather.now,\r\n        astro: daily_forecast[0].astro,\r\n        suggestion: suggestion\r\n      },\r\n      updateTimeHidden: false,\r\n      updateTime: weather.basic.update.loc\r\n    });\r\n\r\n    // 2秒后隐藏更新时间\r\n    var timer = setTimeout(function() {\r\n      that.setData({\r\n        updateTimeHidden: true\r\n      });\r\n    }, 2000);\r\n  },\r\n复制代码（2）数据绑定，以7天天气为例<view class='sevendays-bg'>\r\n      <view class='sevendays-title'>7天天气预报</view>\r\n      <scroll-view>\r\n        <block wx:key=\"daily_forecast\" wx:for=\"{{weather.daily_forecast}}\" wx:for-item=\"item\" wx:for-index=\"index\">\r\n          <view class='sevendays-templatebg'>\r\n            <template is=\"sevenDays\" data=\"{{item: item, isnight: isNight, index: index}}\" />\r\n          </view>\r\n        </block>\r\n      </scroll-view>\r\n    </view>\r\n复制代码至此，日播天气就结束了。一周学会小程序，怎么不可能？学的很精通那是有难度的，入门还是可以的，我就是一周就写了这个小程序的。"}
{"title": "微信小程序·云开发初体验 ", "author": "Rolan", "pub_time": "2018-11-12 00:31", "content": "微信小程序·云开发初体验简介：2018年9月份微信正式推出云开发平台，一石激起千层浪，什么是云开发？是不是以后就可以和后端研发说拜拜了？是不是未来前端研发就可以一统微信小程序了？想想还有点小激动了呢！2018年9月份微信正式推出云开发平台，一石激起千层浪，什么是云开发？是不是以后就可以和后端研发说拜拜了？是不是未来前端研发就可以一统微信小程序了？啥？我膨胀了吗？我骄傲了吗？我嘴角流口水了吗？只是想想还有点小激动了呢！好了，好了，后端童鞋可以放下手里的刀了，这个微信小程序的云开发暂时还无法全面取代你们在微信端的地位，但是！不得不说给前端开发带来了很大的便利，值得前端童鞋们一探究竟。1.什么是云开发？云开发为开发者提供完整的云端支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。也就是说，对于一些小程序，我们无需后端搭建服务器，提供数据库，整个项目完全可以由前端开发者来完成。这意味着前端开发者无需考虑如何构建服务器之类的工作，即可完成整个微信小程序了。2.云开发功能简介好了，叨叨了这么多，想必你已经迫不及待的要揭开它神秘的面纱了。2.1 云开发基本步骤（1）俗话说“巧妇难为无米之炊”，首先要做的就是下载微信提供的最新开发工具，网址为您奉上：https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html?t=18101520 （2）在启动界面，选择”建立云开发快速启动模板”，就可以看到下面的开发平台了：其中，系统默认会建立两个文件夹，分别为：– cloudfunctions 默认存放云函数的文件夹– miniprogram 默认存放业务代码的文件夹如果你觉得，这是神马名字，能不能起个高大上的名字。只有私人订制版的名字，才能衬托我无与伦比的高贵气质~比如说：李狗蛋和王钢柱…敲黑板，注意了，当你修改名字后，一定要记得在 project.config.json 中对应修改云函数和程序的路径,否则小程序无法找到对应的入口文件而报错。2.2 云开发切换环境细心的童鞋可能发现，云函数的文件夹后面带有一个 cloud-demo 的小尾巴，这个是当前云函数使用的云环境。云环境有啥用处呢？由于云开发是实时上线更新的，假如你已经上线了一版小程序，在本地开发的时候，实时修改该环境下的数据库和云函数逻辑，那么使用同一环境的线上小程序也会变来变去，再想想用户一脸茫然的看着自已动来动去的小程序界面，很调皮是不是？好在，微信给每位开发者提供了两套环境：环境之大，一次用不下，一个上线，一个开发！每套环境的数据库/云函数都是相互独立的，只有在测试环境检查的没有问题了，再部署到线上。那么问题又来了，如何切换使用的云环境呢？右击云函数文件夹，如果之前切换过环境的话，会出现两个候选环境，如果之前没有切换过，则选择更多设置，如下图所示在新打开的界面中选择当前要使用的环境即可。好了，环境准备好后，让我们开始愉快的（踩坑）开发之旅吧！3.云开发的三大”拦路虎”曾经有位名人“沃·滋基硕德” 这样教导我们：“你在奔向成功的路上总是会遇到困难，不要伤心，慢慢就习惯了！”云开发包括三大主要内容：云函数，数据库，存储管理，相当于拦路虎一样，横跨在我们面前，在使用过程中需要注意哪些事项呢？让我娓娓道来：3.1 大虎：云函数何为云函数？云函数是一段运行在云端的代码，无需管理服务器，在开发工具内编写、一键上传部署即可运行后端代码。我们可以在代码区域的云函数文件夹，右击新建 node.js 函数，之后平台会提示我们是否安装依赖：如需在云函数中操作数据库、管理云文件、调用其他云函数等操作，可使用官方提供的 npm 包 wx-server-sdk 进行操作。值得注意的是，一旦忘记安装依赖，在 mac 系统下，则没有挽回的入口，不是说好了，浪子回头金不换吗？连个后悔机会也不给人家！！还好我们可以曲线救国，在本地文件中，找到该云函数的文件夹，打开 CMD 终端执行下面的命令：npm install --save wx-server-sdk@latest\r\n \r\n \r\n然后再上传部署该云函数，这样就可以引入依赖了。云函数的使用方式如下：exports.main = (event, context) => {\r\nlet { userInfo, a, b} = event\r\nlet { openId, appId} = userInfo // 这里获取到的 openId 和 appId 是可信的\r\nlet sum = a + b\r\nreturn {\r\nopenId,\r\nappId,\r\nsum\r\n}\r\n}\r\n \r\n其中 event 包含了小程序端调用该函数时传过来的参数，同时还包含了用户登录态 openId 和小程序 appId 信息；context 对象包含了此处调用的调用信息和运行状态，可以用它来了解服务运行的情况。这里比较重要的是 openId ，客户端的每个用户都会有自己的 openId ，服务端可以根据这些 openId 来区分用户。然而，当我们满心欢喜的想跑通上面获取 openId 的示例时，却发现报错了：看错误提示是没有获取到 login 这个云函数，但是打开云开发平台，该云函数明明存在的呀？而且这是官方给的的示例，怎么会出错呢？这时，停下来来思索一下，因为有两套开发环境，是不是还需要定义小程序端调用的云环境呢？想到这里茅塞顿开，于是在 app.js 文件下初始化云函数的时候，定义好要使用的云开发环境：wx.cloud.init({\r\nenv: '使用云开发环境的ID',\r\ntraceUser: true\r\n}\r\n \r\n类似的，云函数在初始化时，同样需要对云开发环境进行定义，// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\ncloud.init({\r\nenv: 'demo-id'\r\n})\r\nconst db = cloud.database();\r\nexports.main = async (event, context) => {\r\nreturn db.collection('todos').get()\r\n}\r\n \r\n这样，上面的云函数就是调用了 ‘demo-id’ 云环境下的 todos 集合的数据了。注意的是，该调用的环境可以和当前开发环境不是同一套环境。3.2 二虎：数据库数据库的界面如下图所示：改变数据库有四种方法：– 1.云开发平台添加记录；– 2.云开发平台导入数据；– 3.微信小程序端改变数据库；– 4.云函数端改变数据库；正所谓“尺有所短，寸有所长。物有所不足，智有所不明”。这四种方法，各有优点：（1）云开发平台添加记录，简单方便，不足之处在于，每条数据都要逐条输入，不方便；（2）云开发平台导入数据，可以同时导入大量的数据，快速。注意的是，导入的json数据和常规的 json 格式不同，按照对象分割，并且对象之间不存在逗号，如下所示：{\r\n\"_id\":\"todo-identifiant-aleatoire\",\r\n\"_openid\":\"user-open-id\",\r\n\"description\":\"learn cloud database\",\r\n\"done\":false\r\n}\r\n{\r\n\"_id\":\"todo-identifiant-aleatoire-2\",\r\n\"_openid\":\"user-open-id\",\r\n\"description\":\"write a novel\",\r\n\"done\":false\r\n}\r\n \r\n（3）小程序端改变数据库，往往携带业务逻辑，但是受到各种权限的限制。小程序端新增的数据，都会默认带有 _id（用以唯一标志一条记录） 和 openid（用以标志记录的创建者，即小程序的用户）。这样，根据数据库中保存的 openid ，可以区分不同的用户。反过来，某位用户也无法操作其他用户的数据，从而保证了数据的稳定性。（4）云函数端改变数据库，和小程序端类似的，云函数提供函数名称 name，供小程序调用。下面就是小程序端调用云函数的方法：wx.cloud.callFunction({\r\nname: ‘云函数名字',\r\ndata: {\r\n//传入云函数的参数\r\n},\r\nsuccess: res => {\r\n//调用成功后的函数\r\n},\r\nfail: err => {\r\n//调用失败后的函数\r\n}\r\n})\r\n \r\n可以看出，云函数也可以带有业务逻辑，不同于小程序端对数据库的操作，云函数是运行在服务端的，具有至高无上的权利—— 弃 openid 如敝履，置权限于不顾，随心所欲的对数据库进行增！删！改！查！综上所述，我们可以使用在云开发平台的导入功能，初始化 json 数据，利用云开发平台的添加修改功能，对数据进行细节的调整，之后使用微信小程序端操作数据库，向数据库中增加数据，可以自动引入 openid 来区分用户数据，最后如果想获得更大的权利，就使用云函数对数据库进行操作，再把调用的权限抛给小程序端。3.3 三虎：存储管理云开发平台上最后一位拦路虎是云存储管理，它不吵不闹，来者不拒的接收着要保存的数据。其界面如下图所示从上图看出，通过“上传文件”按钮，可以在云开发控制台上传文件。此外，可以通过微信小程序的 uploadFile 函数，上传文件。谨记，一定要使用新建文件夹来规范划分存储的数据，否则后期大量的存储文件将是你挥之不去的噩梦。图中 fileId 即是文件的存储地址，无论是从云开发平台还是从客户端上传的文件，系统都会自动分配给每个文件对应的 fileId。当然也可以通过微信小程序的 uploadFile 函数，上传文件。下面的云函数代码就使用了存储管理中保存的文件，返回给小程序端调用：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\ncloud.init()\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\nconst fileList = [\r\n'cloud://cloud-demo-c5b56e.636c-cloud-demo-c5b56e/swiperImg/img_1.jpg',\r\n'cloud://cloud-demo-c5b56e.636c-cloud-demo-c5b56e/swiperImg/img_2.jpg',\r\n'cloud://cloud-demo-c5b56e.636c-cloud-demo-c5b56e/swiperImg/img_3.jpg'\r\n]\r\nconst result = await cloud.getTempFileURL({\r\nfileList: fileList,\r\n})\r\nreturn result.fileList\r\n}\r\n \r\n上面解释了文件在云端保存的地址，那么在小程序端把文件上传到云存储中的地址又是什么呢？假如在小程序端，实现本地的图片上传到云服务器的功能，首先要获取本地文件的临时路径：wx.chooseImage({\r\n//选择手机图片\r\nchooseEvt(){\r\nlet that = this;\r\nwx.chooseImage({\r\ncount: 1,\r\nsizeType: ['original', 'compressed'],\r\nsourceType: ['album', 'camera'],\r\nsuccess(res) {\r\n// tempFilePath可以作为img标签的src属性显示图片\r\nconst tempFilePaths = res.tempFilePaths[0];\r\nthat.setData({\r\nchooseImg: tempFilePaths\r\n})\r\nthat.uploadImg(tempFilePaths);\r\n}\r\n})\r\n}\r\n \r\n下面是上传到服务器的代码：uploadImg(tempFilePaths){\r\nlet str = tempFilePaths;\r\nlet name = str.split('.').reverse()[1] +'.'+str.split('.').reverse()[0];\r\nlet names = name.split('//')[1];\r\nlet that = this;\r\nwx.cloud.uploadFile({\r\ncloudPath: 'swiperImg/'+names,\r\nfilePath: str, // 小程序临时文件路径\r\nsuccess: res => {\r\nthat.setData({\r\nimageId: res.fileID\r\n})\r\n},\r\nfail: err => {\r\nconsole.log(err)\r\n}\r\n})\r\n}\r\n \r\n其中 wx.cloud.uploadFile 带有的参数 cloudPath 就是上传到服务器的存储地址。既然上面示例中已经给出了结果，我也就不卖关子了，cloudPath 使用的是相对地址，而不是存储地址 “cloud://cloud-demo-c5b56e.636c-cloud-demo-c5b56e/swiperImg/”。另外上传文件的名字为了避免自己定义，使用了上传文件本身的名字。但是！要注意的是， 手机端和电脑端上传文件的路径是不一样的， 我们来看一下，在电脑端上传图片，得到的文件临时地址 tempFilePaths 是\"http://tmp/wx81c95cafc368ba2d.o6zAJsxvC5wiHIIVQOpRPFVOADDM.NLBDb9oLxX1D1f412643685c68c106d42e1757f77691.png\"\r\n \r\n而手机端得到的 tempFilePaths 则是：\"wxfile://tmp_wx81c95cafc368ba2do6zAJsxvC5wiHIIVQOpRPFVOADDMNLBDb9oLxX1D1f412643685c68c106d42e1757f77691.png\"\r\n \r\n可以看出，除了文件头不一样外，手机端得到的地址并没有中间的 “·”，假如像上面的代码一样，按照 “·” 进行分割地址，则手机端得到的 name 就会带有 wxfile:// ，这样保存到云端存储的时候就会一直提示 cloudPath 路径不对，但是在电脑端调试的时候，由于返回的图片临时路径带有多个 “·”， 就不会出现这问题，话说，第一次遇到这个问题的时候，一度怀疑是不是云函数还需要走什么上线流程，才能在手机端看到效果呢。4.说说心里话微信云开发功能，给前端带来独立开发微信小程序的能力。一经发布，便引起广大开发者的关注。由于推出的不久，在开发过程中还有些问题无法找到类似的解答，只能不断的翻阅官方文档和调试。当然还有官方提供的论坛[1]，只是如果着急想要得到解答，还是要靠自己。好了，说了这么多，其实官方文档中的 API，大多都没有介绍。文末给出了官方文档的链接[2]，里面说的很是详细了。 本文旨在使用云开发过程中，总结分享遇到的哪些问题，抛砖引玉，期待各位走过路过的童鞋留言，说一说你在使用微信小程序中的心得。最后，欢迎各位搜索“全站探索”公众号，我们是一群喜欢技术，钻研技术的人，每周都会推送精美的文章，期待您的关注！扩展阅读[1] 微信小程序官方论坛https://developers.weixin.qq.com/community/develop?idescene=2[2] 微信小程序云开发文档https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html文章来源于 全栈探索 微信公众号，"}
{"title": "两种方案开发小程序动画 ", "author": "Rolan", "pub_time": "2018-11-12 00:32", "content": "在普通的网页开发中，动画效果可以通过css3来实现大部分需求，在小程序开发中同样可以使用 css3 ，同时也可以通过 api 方式来实现。指路： 小程序animatiom动画APIAPI解读小程序中，通过调用 api 来创建动画，需要先创建一个实例对象。这个对象通过 wx.createAnimation 返回, animation 的一系列属性都基于这个实例对象。创建这个对象let animation = wx.createAnimation({\r\n        duration: 2000,\r\n        delay: 0,\r\n        timingFunction: \"linear\",\r\n    });\r\n复制代码这个 animation 就是通过 wx.createAnimation 之后返回的实例。在创建过程中，可以给这个实例添加一些属性，如以上代码所示，等同于 css3 中 animation:$name 2s linear 的写法。添加动效实例创建完成之后，基于该实例，添加需要的动态效果，动态类型可以查阅文档得知，以最常见的移动，旋转为例：animation.translate($width, 0).rotate($deg);\r\n复制代码结束动画.step() 表示一组动画的结束animation.step();\r\n复制代码导出动画动画效果添加完成了，如何给想要的dom添加动效呢。这里需要用到 .export() 导出动画队列，赋值给某个dom对象。this.setData({ moveOne: animation.export() })\r\n复制代码<view  animation=\"{{moveOne}}\"></view>\r\n复制代码例子以下将通过2组动画，来对比一下 css3 与 api 实现方式的不同。一、模块移动动画动画效果：下图有两组动画，分别为 api 方式（上）与 css3 方式（下）完成的效果，点击move按钮，动画启动。代码实现以下分别为 css3 与 api 的核心代码：css3：<!-- wxml -->\r\n    <view class='border'>\r\n        <view class='css-block {{isMove && \"one\"}}'></view>\r\n        <view class='css-block {{isMove && \"two\"}}'></view>\r\n        <view class='css-block {{isMove && \"three\"}}'></view>\r\n        <view class='css-block {{isMove && \"four\"}}'></view>\r\n    </view>\r\n复制代码// scss\r\n    @mixin movePublic($oldLeft,$oldTop,$left,$top) {\r\n        from {\r\n          transform:translate($oldLeft,$oldTop);\r\n        }\r\n        to {\r\n          transform:translate($left,$top);\r\n        }\r\n    }\r\n    \r\n    @mixin blockStyle($color,$name) {\r\n        background: $color;\r\n        animation:$name 2s linear infinite alternate;\r\n    }\r\n    .one {\r\n        @include blockStyle(lightsalmon,onemove);\r\n    }\r\n    \r\n    @keyframes onemove {\r\n        @include movePublic(50rpx,-25rpx,-150rpx,0rpx);\r\n    }\r\n    \r\n    .two {\r\n        @include blockStyle(lightblue,twomove);\r\n    }\r\n    \r\n    @keyframes twomove {\r\n        @include movePublic(0rpx,25rpx,-50rpx,0rpx);\r\n    }\r\n    \r\n    .three {\r\n        @include blockStyle(lightgray,threemove);\r\n    }\r\n    \r\n    @keyframes threemove {\r\n        @include movePublic(0rpx,25rpx,50rpx,0rpx);\r\n    }\r\n    \r\n    .four {\r\n        @include blockStyle(grey,fourmove);\r\n    }\r\n    \r\n    @keyframes fourmove {\r\n        @include movePublic(-50rpx,-25rpx,150rpx,0rpx);\r\n    }\r\n复制代码// js\r\n    moveFunction(){\r\n        this.setData({\r\n            isMove: true\r\n        })\r\n    }\r\n复制代码css3 中通过动态改变 class 类名来达到动画的效果，如上代码通过 one 、 two 、 three 、 four 来分别控制移动的距离，通过sass可以避免代码过于冗余的问题。 （纠结如何在小程序中使用 sass 的童鞋请看这里哦： wechat-mina-template ）api：moveClick(){\r\n        this.move(-75,-12.5,25,'moveOne');\r\n        this.move(-25,12.5, 0,'moveTwo');\r\n        this.move(25, 12.5,0,'moveThree');\r\n        this.move(75, -12.5,-25,'moveFour');\r\n        this.moveFunction(); // 该事件触发css3模块进行移动\r\n    },\r\n\r\n    // 模块移动方法\r\n    move: function (w,h,m,ele) {\r\n        let self = this;\r\n        let moveFunc = function () {\r\n        let animation = wx.createAnimation({\r\n            duration: 2000,\r\n            delay: 0,\r\n            timingFunction: \"linear\",\r\n        });\r\n    \r\n        animation.translate(w, 0).step()\r\n        self.setData({ [ele]: animation.export() })\r\n        let timeout = setTimeout(function () {\r\n            animation.translate(m, h).step();\r\n            self.setData({\r\n                // [ele] 代表需要绑定动画的数组对象\r\n                [ele]: animation.export()\r\n            })\r\n          }.bind(this), 2000)\r\n        }\r\n        moveFunc();\r\n        let interval = setInterval(moveFunc,4000)\r\n    }\r\n复制代码效果图可见，模块之间都是简单的移动，可以将他们的运动变化写成一个公共的事件，通过向事件传值，来移动到不同的位置。其中的参数 w,h,m,ele 分别表示发散水平方向移动的距离、聚拢时垂直方向、水平方向的距离以及需要修改 animationData 的对象。通过这种方法产生的动画，无法按照原有轨迹收回，所以在事件之后设置了定时器，定义在执行动画2s之后，执行另一个动画。同时 动画只能执行一次 ，如果需要循环的动效，要在外层包裹一个重复执行的定时器到。查看源码，发现 api 方式是通过 js 插入并改变内联样式来达到动画效果，下面这张动图可以清晰地看出样式变化。打印出赋值的 animationData ， animates 中存放了动画事件的类型及参数； options 中存放的是此次动画的配置选项， transition 中存放的是 wx.createAnimation 调用时的配置， transformOrigin 是默认配置，意为以对象的中心为起点开始执行动画，也可在 wx.createAnimation时进行配置。二、音乐播放动画上面的模块移动动画不涉及逻辑交互，因此新尝试了一个音乐播放动画，该动画需要实现暂停、继续的效果。动画效果：两组不同的动画效果对比，分别为 api （上）实现与 css3 实现（下）：代码实现以下分别是 css3 实现与 api 实现的核心代码：css3：<!-- wxml -->\r\n    <view class='music musicTwo musicRotate {{playTwo ? \" \": \"musicPaused\"}} ' bindtap='playTwo'>\r\n        <text class=\"iconfont has-music\" wx:if=\"{{playTwo}}\"></text>\r\n        <text class=\"iconfont no-music\" wx:if=\"{{!playTwo}}\"></text>\r\n    </view>\r\n复制代码// scss\r\n    .musicRotate{\r\n        animation: rotate 3s linear infinite;\r\n    }\r\n    \r\n    @keyframes rotate{\r\n        from{\r\n            transform: rotate(0deg)\r\n        }\r\n        to{\r\n            transform: rotate(359deg)\r\n        }\r\n    }\r\n    \r\n    .musicPaused{\r\n        animation-play-state: paused;\r\n    }\r\n复制代码// js\r\n    playTwo(){\r\n        this.setData({\r\n            playTwo: !this.data.playTwo\r\n        },()=>{\r\n            let back = this.data.backgroundAudioManager;\r\n            if(this.data.playTwo){\r\n                back.play();\r\n            } else {\r\n                back.pause();\r\n            }\r\n        })\r\n    }\r\n复制代码通过 playTwo 这个属性来判断是否暂停，并控制 css 类的添加与删除。当为 false 时，添加 .musicPaused 类，动画暂停。api:<!-- wxml -->\r\n    <view class='music' bindtap='play'  animation=\"{{play && musicRotate}}\">\r\n        <text class=\"iconfont has-music\" wx:if=\"{{play}}\"></text>\r\n        <text class=\"iconfont no-music\" wx:if=\"{{!play}}\"></text>\r\n    </view>\r\n复制代码// js\r\n    play(){\r\n        this.setData({\r\n            play: !this.data.play\r\n        },()=>{\r\n            let back = this.data.backgroundAudioManager;\r\n            if (!this.data.play) {\r\n                back.pause();\r\n               // 跨事件清除定时器\r\n               clearInterval(this.data.rotateInterval);\r\n            } else {\r\n                back.play();\r\n                // 继续旋转，this.data.i记录了旋转的程度\r\n                this.musicRotate(this.data.i);\r\n            }\r\n        })\r\n    },\r\n    musicRotate(i){\r\n        let self = this;\r\n        let rotateFuc = function(){\r\n            i++;\r\n            self.setData({\r\n                i:i++\r\n            });\r\n            let animation = wx.createAnimation({\r\n                duration: 1000,\r\n                delay: 0,\r\n                timingFunction: \"linear\",\r\n            });\r\n            animation.rotate(30*(i++)).step()\r\n            self.setData({ musicRotate: animation.export() });\r\n        }\r\n        rotateFuc();\r\n        let rotateInterval = setInterval(\r\n            rotateFuc,1000\r\n        );\r\n        // 全局定时事件\r\n        this.setData({\r\n            rotateInterval: rotateInterval\r\n        })\r\n    }\r\n复制代码通过 api 实现的方式是通过移除 animationData 来控制动画，同时暂停动画也需要清除定时器，由于清除定时器需要跨事件进行操作，所以定了一个全局方法 rotateInterval 。api 方式定义了旋转的角度，但旋转到该角度之后便会停止，如果需要实现重复旋转效果，需要通过定时器来完成。因此定义了变量i，定时器每执行一次便加1，相当于每1s旋转30°，对 animation.rotate() 中的度数动态赋值。暂停之后继续动画,需要从原有角度继续旋转，因此变量i需要为全局变量。代码变化下图可以看出， api 方式旋转是通过不断累加角度来完成，而非 css3 中循环执行。对比通过上述两个小例子对比，无论是便捷度还是代码量，通过 css3 来实现动画效果相对来说是更好的选择。 api 方式存在较多局限性：动画只能执行一次，循环效果需要通过定时器完成。无法按照原有轨迹返回，需要返回必须定义定时器。频繁借助定时器在性能上有硬伤。综合以上，推荐通过 css3 来完成动画效果。"}
{"title": "微信小程序组件封装 ", "author": "Rolan", "pub_time": "2018-11-13 00:36", "content": "概述自己封装的一个比较简单微信弹窗小组件，主要就是教会大家对微信小组件的用法和理解，因为微信小程序对组件介绍特别少，所以我就把自己的理解分享给大家。一前言相信大家在开发小程序时会遇到某个功能多次使用的情况，比如弹出框。这个时候大家首先想到的是组件化开发，就是把弹出框封装成一个组件，然后哪里使用哪里就调用，对，看来大家都是有思路的人，但是要怎样实现呢。可能你会去看官方文档，但是微信的官方文档也是说的不太清楚，所以写起来也是非常痛苦。今天就和大家一起开发微信组件，坐稳了，老司机要开车了。二具体实现我们先实现个简单的弹窗组件，详情图如下：1.新建component文件夹存放我们的组件，里边存放的就是我们所用的组件，我们今天要做的事弹出框，新建文件夹popup存放我们的组件模板，点击右键选择新建component，就会自动生成组件的模板wxss、wxml、json、js，如图2.我们可以写一些组件样式和布局，跟页面写法类似，我就不多说了，直接把代码贴出 :popup.wxml<view class=\"wx-popup\" hidden=\"{{flag}}\">  <view class='popup-container'>    <view class=\"wx-popup-title\">{{title}}</view>    <view class=\"wx-popup-con\">{{content}}</view>    <view class=\"wx-popup-btn\">      <text class=\"btn-no\" bindtap='_error'>{{btn_no}}</text>      <text class=\"btn-ok\" bindtap='_success'>{{btn_ok}}</text>    </view>  </view></view>复制代码popup.wxss/* component/popup.wxss */.wx-popup {  position: absolute;  left: 0;  top: 0;   width: 100%;  height: 100%;  background: rgba(0, 0, 0, .5);} .popup-container {  position: absolute;  left: 50%;  top: 50%;   width: 80%;  max-width: 600rpx;  border: 2rpx solid #ccc;  border-radius: 10rpx;  box-sizing: bordre-box;  transform: translate(-50%, -50%);   overflow: hidden;  background: #fff;} .wx-popup-title {  width: 100%;  padding: 20rpx;  text-align: center;  font-size: 40rpx;  border-bottom: 2rpx solid red;} .wx-popup-con {  margin: 60rpx 10rpx;  text-align: center;} .wx-popup-btn {  display: flex;  justify-content: space-around;  margin-bottom: 40rpx;} .wx-popup-btn text {  display: flex;  align-items: center;  justify-content: center;  width: 30%;  height: 88rpx;  border: 2rpx solid #ccc;  border-radius: 88rpx;}复制代码样式和布局和布局已经写好了接下来要介绍的就是Component构造器Component构造器可用于定义组件，调用Component构造器时可以指定组件的属性、数据、方法等。定义段类型是否必填描述propertiesObject Map否组件的对外属性，是属性名到属性设置的映射表，属性设置中可包含三个字段， type 表示属性类型、 value 表示属性初始值、 observer 表示属性值被更改时的响应函数dataObject否组件的内部数据，和 properties 一同用于组件的模版渲染methodsObject否组件的方法，包括事件响应函数和任意的自定义方法，关于事件响应函数的使用，参见组件事件behaviorsString Array否类似于mixins和traits的组件间代码复用机制，参见behaviorscreatedFunction否组件生命周期函数，在组件实例进入页面节点树时执行，注意此时不能调用 setDataattachedFunction否组件生命周期函数，在组件实例进入页面节点树时执行readyFunction否组件生命周期函数，在组件布局完成后执行，此时可以获取节点信息（使用SelectorQuery ）movedFunction否组件生命周期函数，在组件实例被移动到节点树另一个位置时执行detachedFunction否组件生命周期函数，在组件实例被从页面节点树移除时执行relationsObject否组件间关系定义，参见组件间关系externalClassesString Array否组件接受的外部样式类，参见外部样式类optionsObject Map否一些组件选项，请参见文档其他部分的说明Tips:Component 构造器构造的组件也可以作为页面使用。使用 this.data 可以获取内部数据和属性值，但不要直接修改它们，应使用 setData 修改。生命周期函数无法在组件方法中通过 this 访问到。属性名应避免以 data 开头，即不要命名成 dataXyz 这样的形式，因为在 WXML 中， data-xyz=\"\" 会被作为节点 dataset 来处理，而不是组件属性。在一个组件的定义和使用时，组件的属性名和data字段相互间都不能冲突（尽管它们位于不同的定义段中）。component介绍完后就是最为关键的js了popup.js:Component({  options: {    multipleSlots: true // 在组件定义时的选项中启用多slot支持  },  /**   * 组件的属性列表   */  properties: {    title: {            // 属性名      type: String,     // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型）      value: '标题'     // 属性初始值（可选），如果未指定则会根据类型选择一个    },    // 弹窗内容    content: {      type: String,      value: '内容'    },    // 弹窗取消按钮文字    btn_no: {      type: String,      value: '取消'    },    // 弹窗确认按钮文字    btn_ok: {      type: String,      value: '确定'    }   },   /**   * 组件的初始数据   */  data: {    flag: true,  },   /**   * 组件的方法列表   */  methods: {    //隐藏弹框    hidePopup: function () {      this.setData({        flag: !this.data.flag      })    },    //展示弹框    showPopup () {      this.setData({        flag: !this.data.flag      })    },    /*    * 内部私有方法建议以下划线开头    * triggerEvent 用于触发事件    */    _error () {      //触发取消回调      this.triggerEvent(\"error\")    },    _success () {      //触发成功回调      this.triggerEvent(\"success\");    }  }})复制代码上边会用到一个triggerEvent下面我们就来介绍下：自定义组件触发事件时，需要使用 triggerEvent 方法，指定事件名、detail对象和事件选项。触发事件的选项包括：选项名类型是否必填默认值描述bubblesBoolean否false事件是否冒泡composedBoolean否false事件是否可以穿越组件边界，为false时，事件将只能在引用组件的节点树上触发，不进入其他任何组件内部capturePhaseBoolean否false事件是否拥有捕获阶段现在一个弹窗的组件就封装好了接下来就是调用了。调用的时候需要在调用的页面新建一个json文件，json文件里需要配置usingComponents就是引用组件，看代码：index.json{  \"usingComponents\": {    \"popup\": \"/component/popup/popup\"  }}复制代码现在基本上完成了需要的就是在首页引用了。<!--index.wxml--><view class=\"container\">  <view class=\"userinfo\">    <button bindtap=\"showPopup\"> 点我 </button>  </view>  <popup id='popup'       title='小组件'       content='学会了吗'       btn_no='没有'       btn_ok='学会了'      bind:error=\"_error\"        bind:success=\"_success\">  </popup></view>复制代码配置index.js加上点击事件//index.js//获取应用实例const app = getApp() Page({  onReady: function () {    //获得popup组件    this.popup = this.selectComponent(\"#popup\");  },   showPopup() {    this.popup.showPopup();  },   //取消事件  _error() {    console.log('你点击了取消');    this.popup.hidePopup();  },  //确认事件  _success() {    console.log('你点击了确定');    this.popup.hidePopup();  }})复制代码一个弹窗组件就完成了，看下效果："}
{"title": "使用高德地图微信小程序SDK开发案例-输入提示（附源码） ", "author": "Rolan", "pub_time": "2018-11-13 00:40", "content": "闲来无事写一篇使用高德地图的微信小程序SDK开发应用的实例。接下来先看需求：我们要做的是，根据用户输入的关键词，给出相应的提示信息，列表中显示地方的名称，地方的详细地址以及对应的经纬度坐标。当然在UI上我们尽量做到理想的视觉与较好的用户体验。最终的效果我们希望是像这样的，如下图：有了目标，我们直接代码撸起来～我们先从高德开放平台获取微信小程序SDK以及开发需要的key。完成一些基础工作后我们先规划下页面布局。我们需要一个输入框可以让用户输入，和一个存放列表的容器来显示提示信息。<input type=\"text\" value='{{inputVal}}' bindinput='input' placeholder='请输入搜索关键字'></input>好了，我们为它添加1个监听事件，bindinput='input'，来监听用户的键盘输入。接着我们来做存放列表的容器。<view class=\"list\">\r\n    <view class=\"list-item\" wx:for=\"{{searchList}}\" >  \r\n        <view class='title'>{{item.name}}</view>\r\n        <view class='address'>{{item.district}}{{item.address}}</view>\r\n    </view>\r\n</view>在接下去调用高德接口的过程中，我们将会从接口中获得一个数组，我们将这个数组赋值给searchList，因此我们需要给容器内的列表项添加for循环。这样就能达到我们预期的效果。接着我们为输入框绑定的监听事件添加对应的方法  input: function (e) {\r\n      this.setData({\r\n        inputVal: e.detail.value\r\n      })\r\n  }同时将输入的关键字赋值给inputVal，这样我们就能在页面上看到我们输入的文字了。获取到输入的关键字，我们就可以将关键字作为参数传到高德提供的接口中，使其返回数据。我们写一个公共方法，将调用接口方法封装起来。//引入高德微信小程序SDK\r\nvar amapFile = require('amap-wx.js');\r\n\r\n//搜索关键字\r\nkeyword: function (){\r\n    var myAmapFun = new amapFile.AMapWX({key: '高德Key'}),that = this;\r\n    myAmapFun.getInputtips({\r\n        keywords:'关键字',\r\n        location: '',\r\n        success: function (data) {\r\n          if (data && data.tips) {\r\n            //将数据赋值到searchList\r\n            that.setData({searchList: data.tips});\r\n          }  \r\n        }\r\n    });\r\n }到此我们写好了接口逻辑，现在我们将整个流程打通；为了提升用户的使用体验，在用户输入关键字的同时触发搜索，实时返回结果。input: function (e) {\r\n      this.setData({\r\n        inputVal: e.detail.value\r\n      });\r\n      //在监听的方法中添加搜索关键字的方法\r\n     this.keyword(e.detail.value);\r\n  }这样，每当用户输入关键字时就能实时得到返回结果。我们从接口中提取想要的数据，在页面上展示。   <view class=\"list-item\" wx:for=\"{{searchList}}\" > \r\n       <image class=\"icon\" mode=\"widthFix\" src=\"../../images/icon.png\"></image> \r\n       <view class='title'>{{item.name}}</view>\r\n       <view class='address'>{{item.district}}{{item.address}}</view>\r\n   </view>为增强UI效果我们添加一些合理的样式和小图标作为美化。到这里我们基本已经完成了大致的需求。但是细节方面我们也需要注意；比如：当用户尚未输入关键，或者关键字长度为0的时候，列表容器应该处于不显示状态。当然我们还可以在输入框上添加清除输入内容的按钮来提升使用体验。或者在输入框的左侧添加城市选择，获取经纬度后传入封装的keyword()方法，就能根据不同的城市来做搜索。"}
{"title": "微信小程序之购物车和父子组件传值及calc的注意事项 ", "author": "Rolan", "pub_time": "2018-11-13 00:57", "content": "1.效果图2.子组件实现要实现图中删除的效果，使用组件的形式更好做点，我当时本想直接在pages里实现，不过结果就是，滑动时，所有的商品都显示了删除按钮，除非用数组将每个商品要移动的距离存储起来，不过这样的话就很麻烦，所以我也是用组件来实现的关于微信组件，可以直接点击链接访问官网查看自定义组件子组件index.wxml<view class=\"commodityItem\" bindtouchstart=\"handleTouchStart\" bindtouchmove=\"handleTouchMove\" style=\"transform:translateX({{-rightSpace}}px)\">\r\n  <view class=\"selectedBtn\" bindtap=\"handleSelect\" data-is-selected=\"{{commodity.isselected}}\">\r\n    <view class=\"noSelected\" wx:if=\"{{commodity.isselected==0}}\"></view>\r\n    <image class=\"selectedImg\" wx:else src=\"/images/selected.png\"></image>\r\n  </view>\r\n  <view class=\"commodityInfo\">\r\n    <view class=\"commodityImg\">\r\n      <image src=\"{{commodity.image}}\"></image>          \r\n    </view>\r\n    <view class=\"commodityTitle\">\r\n      <view class=\"title\">{{commodity.title}}</view>\r\n      <view class=\"standard\">规格：{{commodity.standard?commodity.standard:'无'}}</view>\r\n      <view class=\"count\">\r\n        <view class=\"price\">￥{{commodity.price}}</view>\r\n        <view class=\"commodityNum\">\r\n          <i-input-number value=\"{{selectedNum}}\" min=\"1\" max=\"{{commodity.stock}}\" bindchange=\"numChange\" />\r\n        </view>\r\n      </view>\r\n    </view>\r\n  </view>\r\n  <view class=\"deleteBtn\">\r\n    <image class=\"deleteImg\" src=\"/images/delete.png\"></image>\r\n    <text class=\"deleteText\">删除</text>\r\n  </view>\r\n</view>子组件index.wxss/* 商品 */\r\n.commodityItem{\r\n  display: flex;\r\n  position: relative;\r\n  padding: 10rpx 24rpx 20rpx 30rpx;\r\n  box-sizing: border-box;\r\n  background: #fff;\r\n  transition: all .5s;\r\n}\r\n/* 选择按钮 */\r\n.selectedBtn{\r\n  display: flex;\r\n  align-items: center;\r\n  width: 80rpx;\r\n}\r\n.noSelected{\r\n  width: 46rpx;\r\n  height: 46rpx;\r\n  border-radius: 50%;\r\n  border: 1px solid #ef5225;\r\n}\r\n.selectedBtn .selectedImg{\r\n  width: 50rpx;\r\n  height: 50rpx;\r\n}\r\n/* 商品信息 */\r\n.commodityInfo{\r\n  display: flex;\r\n  width: calc(100% - 80rpx);\r\n}\r\n.commodityImg{\r\n  margin-right: 18rpx;\r\n  width: 220rpx;\r\n  height: 220rpx;\r\n}\r\n.commodityImg image{\r\n  width: 100%;\r\n  height: 100%;\r\n  vertical-align: middle;  \r\n}\r\n/* 商品title */\r\n.commodityTitle{\r\n  width: calc(100% - 220rpx);\r\n}\r\n.title{\r\n  display: -webkit-box;\r\n  width: 100%;\r\n  height: 70rpx;\r\n  line-height:35rpx;\r\n  font-size: 24rpx;\r\n  font-weight:600;\r\n  overflow: hidden;\r\n  -webkit-line-clamp: 2;\r\n  -webkit-box-orient: vertical;\r\n}\r\n.standard{\r\n  padding-top: 16rpx;\r\n  width: 100%;\r\n  height: 90rpx;\r\n  box-sizing: border-box;\r\n}\r\n.count{\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  width: 100%;\r\n  height: 60rpx;\r\n}\r\n\r\n/* 删除按钮 */\r\n.deleteBtn{\r\n  display: flex;\r\n  position: absolute;\r\n  width: 70px;\r\n  height: 100%;\r\n  top: 0rpx;\r\n  right: -70px;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: center;\r\n  background: #ef5225;\r\n}\r\n.deleteImg{\r\n  margin-bottom: 10rpx;\r\n  width: 50rpx;\r\n  height: 50rpx;\r\n  vertical-align: middle;\r\n}\r\n.deleteText{\r\n  color: #fff;\r\n}子组件index.json，这里用了iview中的数字输入框{\r\n  \"component\": true,\r\n  \"usingComponents\": {\r\n    \"i-input-number\": \"/component/iview/input-number/index\"\r\n  }\r\n}子组件index.jsComponent({\r\n\r\n  properties: {\r\n    commodity: Object,\r\n  },\r\n\r\n  data: {\r\n    touchStart: null,\r\n    rightSpace: 0,\r\n    selectedNum: 1,\r\n  },\r\n\r\n  methods: {\r\n    /* 商品是否选中 */\r\n    handleSelect() {\r\n            let selectedNum = this.data.selectedNum;\r\n      let commodity = this.data.commodity;\r\n      if(commodity.isselected == 0) {\r\n        commodity.isselected = 1;\r\n      } else {\r\n        commodity.isselected = 0;\r\n      }\r\n            this.triggerEvent('handleselect', { commodity, selectedNum})\r\n    },\r\n    /* 处理触摸滑动开始 */\r\n    handleTouchStart(e) {\r\n      /* 记录触摸滑动初始位置 */\r\n      let touchStart = e.changedTouches[0].clientX;\r\n      this.setData({\r\n        touchStart\r\n      })\r\n    },\r\n    /* 处理触摸滑动 */\r\n    handleTouchMove(e) {\r\n      console.log(e)\r\n      let moveSpace = e.changedTouches[0].clientX;\r\n      let touchStart = this.data.touchStart;\r\n      if (touchStart != null) {\r\n        if (moveSpace - touchStart > 70) {\r\n          this.setData({\r\n            touchStart: null,\r\n            rightSpace: 0\r\n          })\r\n        }\r\n        else if (moveSpace - touchStart < -70) {\r\n          this.setData({\r\n            touchStart: null,\r\n            rightSpace: 70\r\n          })\r\n        }\r\n      }\r\n    },\r\n    numChange(e) {\r\n        let selectedNum = e.detail.value;\r\n        let commodity = this.data.commodity;\r\n        this.setData({\r\n            selectedNum\r\n        })\r\n        this.triggerEvent('handleselect', { commodity, selectedNum})\r\n    }\r\n  }\r\n})3.父组件实现父组件index.wxml，这里用的是假数据，所以操作上会有一些是联调时不必要的操作<view class=\"cart\">\r\n  <view class=\"item\" wx:for=\"{{cartList}}\" wx:key=\"{{items.shopid}}\" wx:for-item=\"items\">\r\n    <view class=\"storeInfo\">\r\n      <image class=\"avatar\" src=\"{{items.logo}}\"></image>\r\n      <view class=\"storeName\">{{items.shopname}}</view>\r\n    </view>\r\n    <view class=\"discount\">满￥100包邮，满10件包邮</view>\r\n    <view class=\"commodity\" wx:for=\"{{items.commodity}}\" wx:key=\"{{item.id}}\">\r\n      <cart-item commodity=\"{{item}}\" bind:handleselect=\"handleSelect\" />\r\n    </view>\r\n  </view>\r\n    <view class=\"count\">\r\n        <view class=\"selectAll\" bindtap=\"handleSelectAll\">\r\n            <view class=\"noSelected\" wx:if=\"{{!isSelectedAll}}\"></view>\r\n        <image class=\"selectedImg\" wx:else src=\"/images/selected.png\"></image>\r\n            <text class=\"selectAllText\">全选</text>\r\n        </view>\r\n        <view class=\"countPrice\">\r\n      <text>合计:</text>\r\n      <text>￥{{countPrice}}</text>\r\n    </view>\r\n        <view class=\"account\">\r\n      <text>结算</text>\r\n      <text>({{countSelectedNum}})</text>\r\n    </view>\r\n    </view>\r\n</view>父组件index.wxsspage{\r\n  background: #f8f8f8;\r\n}\r\n.cart{\r\n    padding-bottom: 100rpx;\r\n  font-size: 26rpx;\r\n}\r\n.item{\r\n  border-bottom: 1px solid #eee;\r\n}\r\n/* 头部店铺信息 */\r\n.storeInfo{\r\n  display: flex;\r\n  padding: 18rpx 0rpx 18rpx 30rpx;\r\n  background: #fff;\r\n  box-sizing: border-box;\r\n}\r\n.storeInfo .avatar{\r\n  width: 56rpx;\r\n  height: 56rpx;\r\n  border-radius: 50%;\r\n  vertical-align: middle;\r\n}\r\n.storeInfo .storeName{\r\n  margin-left: 16rpx;\r\n  line-height: 56rpx;\r\n}\r\n/* 包邮信息 */\r\n.discount{\r\n  padding-left: 30rpx;\r\n  height:50rpx;\r\n  line-height: 50rpx;\r\n  font-size:20rpx;\r\n  color: #666;\r\n  box-sizing: border-box;\r\n}\r\n/* 底部操作 */\r\n.count{\r\n    display: flex;\r\n    position: fixed;\r\n    padding-left: 30rpx;\r\n    bottom: 0;\r\n  left: 0;\r\n    width: 100%;\r\n    height: 100rpx;\r\n    line-height: 100rpx;\r\n  box-sizing: border-box;\r\n  color: #232323;\r\n    background: #eee;\r\n}\r\n/* 全选 */\r\n.selectAll{\r\n    display: flex;\r\n  padding-right: 20rpx;\r\n    align-items: center;\r\n    width: 25%;\r\n  font-size: 30rpx;\r\n}\r\n.selectAll .noSelected{\r\n  width: 46rpx;\r\n  height: 46rpx;\r\n  border-radius: 50%;\r\n  border: 1px solid #ef5225;\r\n}\r\n.selectAll .selectedImg{\r\n  width: 50rpx;\r\n  height: 50rpx;\r\n}\r\n.selectAllText{\r\n    margin-left: 18rpx;\r\n}\r\n\r\n.countPrice{\r\n    position: absolute;\r\n  top: 0;\r\n  right: 270rpx;\r\n  height: 100%;\r\n  line-height: 100rpx;\r\n  text-align: center;\r\n  font-size: 30rpx;\r\n}\r\n.countPrice text{\r\n  margin-right: 15rpx;\r\n}\r\n.account{\r\n  position: absolute;\r\n  top: 0;\r\n  right: 0;\r\n    width: 270rpx;\r\n  height: 100%;\r\n  line-height: 100rpx;\r\n  text-align: center;\r\n  font-size: 30rpx;\r\n  background: #ef5225;\r\n  color: #fff;\r\n}父组件index.json，引用子组件{\r\n  \"usingComponents\": {\r\n    \"cart-item\": \"/component/cart/index\"\r\n  }\r\n}父组件index.jsPage({\r\n\r\n  data: {\r\n    cartList: [\r\n      {\r\n        shopname: '猫咪小店',\r\n        logo: '/images/avatar.jpeg',\r\n        shopid: 11,\r\n        commodity: [\r\n          {\r\n            id: 1,\r\n            image:'/images/commodity.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            standard: '111 + 黑色',\r\n            price: '100',\r\n            stock: 10,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }, \r\n          {\r\n            id: 2,\r\n            image:'/images/avatar7.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            price: '10',\r\n            stock: 5,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }\r\n        ]\r\n      },\r\n      {\r\n        shopname: '猫咪小店',\r\n        logo: '/images/avatar5.jpg',\r\n        shopid: 450,\r\n        commodity: [\r\n          {\r\n            id: 3,\r\n            image:'/images/commodity.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            price: '90',\r\n            stock: 10,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          },\r\n          {\r\n            id: 4,\r\n            image:'/images/avatar7.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            price: '100',\r\n            stock: 5,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }, \r\n          {\r\n            id: 5,\r\n            image:'/images/commodity.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            standard: '111 + 黑色',\r\n            price: '100',\r\n            stock: 2,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }\r\n        ]\r\n      },\r\n      {\r\n        shopname: '猫咪小店',\r\n        logo: '/images/avatar.jpeg',\r\n        shopid: 550,\r\n        commodity: [\r\n          {\r\n            id: 6,\r\n            image:'/images/avatar8.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            standard: '111 + 黑色',\r\n            price: '100',\r\n            stock: 1,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }\r\n        ]\r\n      },\r\n    ],\r\n        /* 商品是否全选中 */\r\n        isSelectedAll: false,\r\n        /* 已选中商品的价格 */\r\n        countPrice: 0,\r\n    /* 统计所有选中的商品数量 */\r\n    countSelectedNum: 0,\r\n  },\r\n  /* 处理商品选中 */\r\n  handleSelect(e) {\r\n        let countPrice = 0;\r\n    let countSelectedNum = 0;\r\n    let cartList = this.data.cartList;\r\n    let length = cartList.length;\r\n\r\n        /* 因为是假数据，所以需要循环查找到对应的数据将其替换 */\r\n    for(let i = 0; i < length; i++) {\r\n      for(let j = 0; j < cartList[i].commodity.length; j++) {\r\n                if (cartList[i].commodity[j].id == e.detail.commodity.id) {\r\n          cartList[i].commodity[j] = e.detail.commodity;\r\n          cartList[i].commodity[j].selectedNum = e.detail.selectedNum;\r\n        }\r\n        if (cartList[i].commodity[j].isselected == 1) {\r\n          /* 点击选中的时候，计算价格，要判断下设置的商品选中数量，\r\n           * 我这里的是对点击了的商品才设置了选中的数量，所以需要对没有点击的商品数量设置为1，然后就默认的加一\r\n           */\r\n          if (cartList[i].commodity[j].selectedNum != undefined) {\r\n            countPrice += cartList[i].commodity[j].price * cartList[i].commodity[j].selectedNum;\r\n            countSelectedNum += cartList[i].commodity[j].selectedNum\r\n          } else {\r\n            countPrice += cartList[i].commodity[j].price * 1;\r\n            countSelectedNum += 1;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n        /* 对是否全选中进行判断 */\r\n        let isSelectedAll = true;\r\n        for (let i = 0; i < length; i++) {\r\n            for (let j = 0; j < cartList[i].commodity.length; j++) {\r\n                /* 若商品中的isselecetd有为0的就终止循环，直接设置为未全选 */\r\n                if (cartList[i].commodity[j].isselected == 0) {\r\n                    isSelectedAll = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n    this.setData({\r\n      cartList,\r\n            isSelectedAll,\r\n            countPrice,\r\n      countSelectedNum\r\n    })\r\n  },\r\n    /* 全选中商品 */\r\n    handleSelectAll() {\r\n        let isSelectedAll = !this.data.isSelectedAll;\r\n        let cartList = this.data.cartList;\r\n        let length = cartList.length;\r\n    let countPrice = 0;\r\n    let countSelectedNum = 0;\r\n\r\n        /* 遍历数据中的isselected来进行全选的操作 */\r\n        for(let i = 0; i < length; i++) {\r\n            for (let j = 0; j < cartList[i].commodity.length; j++) {\r\n                if(isSelectedAll) {\r\n                    cartList[i].commodity[j].isselected = 1;\r\n          /* 全选的时候，计算价格，要判断下设置的商品选中数量，\r\n           * 我这里的是对点击了的商品才设置了选中的数量，所以需要对没有点击的商品数量设置为1，然后就默认加一\r\n           */\r\n          if (cartList[i].commodity[j].selectedNum != undefined) {\r\n            countPrice += parseInt(cartList[i].commodity[j].price) * cartList[i].commodity[j].selectedNum;\r\n            countSelectedNum += cartList[i].commodity[j].selectedNum;\r\n          } else {\r\n            countPrice += cartList[i].commodity[j].price * 1;    \r\n            countSelectedNum += 1;        \r\n          }\r\n                } else {\r\n                    cartList[i].commodity[j].isselected = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setData({\r\n            isSelectedAll,\r\n            cartList,\r\n      countPrice,\r\n      countSelectedNum\r\n        })\r\n    },\r\n})4.父子组件传值较常用的都是父组件往子组件传值，所以子组件往父组件传值就会不是很熟悉我这里的话，是因为用的假数据，在点击商品选中或者不选中时，需要改变商品里的选中属性，所以用到了子组件往父组件传值，也包括传递选中的商品数量子组件往父组件传值的话，是通过在调用this.triggerEvent()来实现的/* 在父组件中定义方法：bind:handleselect或者也可以直接写成bindhandleselect*/\r\n<cart-item commodity=\"{{item}}\" bind:handleselect=\"handleSelect\" />在子组件中调用this.triggerEvent('handleselect', { commodity, selectedNum})这个this.triggerEvent('handleselect', { commodity, selectedNum })方法中，handleselect的名称要与父组件中引用子组件时绑定的方法名称一样，后面的对象就是传递的值，也可以直接是以直接量的形式传递，然后再父组件中通过e.detail来获取对应的值handleSelect(e) {\r\n    console.log(e.detail)\r\n    console.log(e.detail.commodity)\r\n    console.log(e.detail.selectedNum)\r\n}5.calc的注意事项我以前也遇到过，然后现在再用的时候，一时间把这点给忘了，在看到编译器样式的时候，才猛然想起.user-content{\r\n    padding: 10px 0 10px 50px;\r\n    width: calc(100% - 50px);  /* 计算宽度，'+'或'-'符号前后有空格 */\r\n    height: 18px;\r\n}css中使用calc可以进行简单的运算：单位可以是百分比，px，rem，em等单位使用\"+\",\"-\",\"*\",\"/\"运算符（使用\"+\"或者\"-\"符号时，符号前后必须加上空格）在Firefox浏览器上使用要加上-moz前缀chrome浏览器上使用要加上-webkit前缀（使用\"+\"或者\"-\"符号时，符号前后必须加上空格）6.部分想法其实在样式上还是挺快就完成了，就是在计算商品价格的时候，想了挺久在计算价格时，当时就有点蒙圈，总是想着要怎么判断他是增加数量还是减少数量，然后就陷入死循环的之中。其实不用想她是增加还是减少数量，因为你都是传的是商品的数量，而且在计算时，也是判断了商品是否选中，所以，直接点，计算价格乘以数量就可以了然后选中的商品数量的统计就和计算价格的思路是一样的了正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）往期好文推荐：判断iOS和Android及PC端css实现波浪线及立方体微信小程序中遇到的多规格问题(一)实现单行及多行文字省略号"}
{"title": "vue 项目快速输出微信、支付宝、百度小程序 ", "author": "Rolan", "pub_time": "2018-11-14 00:01", "content": "上周，Megalo@0.2.0 正式发布，优化了数据更新性能的同时，支持了百度智能小程序，着实激动了一把，这“可能”是目前社区里第一个同时支持三端小程序的 vue 小程序框架。下面我们就来试试他的效果。跟着文档走官方文档的第一部分就是快速入门，顺藤摸瓜，构建一个 megalo 项目。安装$ npm install -g @megalo/cli\r\n复制代码构建$ megalo megalo-yanxuan-demo\r\n复制代码打包以微信小程序为入口$ npm run dev:wechat\r\n复制代码至此一个完整的 megalo 项目就构建好了，接下来我们开始转移源码转移 weex 项目我从以前 weex 的 demo 项目， yanxuan-weex-demo ，为基础进行转移，转移过程中涉及到很多 weex 特有的 api 的移除和转换。网络请求以网络请求为例，weex 是使用的 streamlet stream = weex.requireModule('stream');\r\nexport default {\r\n    methods: {\r\n        GET (api, callback) {\r\n            return stream.fetch({\r\n                method: 'GET',\r\n                type: 'json',\r\n                url: api\r\n            }, callback)\r\n        }\r\n    }\r\n}\r\n复制代码因为小程序都有提供网络请求的 API，所以此处对此进行改造，如下export default {\r\n    methods: {\r\n        GET (api, callback) {\r\n            let { platform } = this.$mp || {},\r\n                request = ()=>{}\r\n            switch(platform) {\r\n                case 'wechat':\r\n                    request = wx && wx.request\r\n                break;\r\n                case 'alipay':\r\n                    request = my && my.httpRequest\r\n                break;\r\n                case 'swan':\r\n                    request = swan && swan.request\r\n                break;\r\n                default:\r\n                break;\r\n            }\r\n            request && request({\r\n                url: api,\r\n                success: callback\r\n            })\r\n        }\r\n    }\r\n}\r\n复制代码类似的还有 toast、message 等组件的改造。组件由于 weex 中的 <recycle-list> 、 <loading> 、 <refresh> 、 <scroller> 等组件在小程序组件内是不存在的，所以有三种解决方案自定义一个同名 vue 组件找小程序可用的组件替换实在不行就砍掉需求吧比如 weex 的 <slider> 组件，可以用小程序的 <swiper> 替换，好在微信、支付宝和百度小程序都有支持。cssWeex 容器默认的宽度 (viewport) 是 750px，小程序以 750rpx 为基。所以直接将需要的 px 转换成 rpx。另外自己实现了 1 像素的 wpx，替换成 px 即可。执行三端效果最后看下改造效果。同时执行三端效果比预想的要好，没有过多的适配出错demo 源码 抛给大家供大家把玩。哪些可以转只要现有工程没有做以下几件事，理论上，都是可以转移的，只需要稍微更新一下格式使用 megalo 暂不支持的 vue 特性涉及浏览器特有的 dom 操作，window、userAgent、location、getElementById 等使用第三方组件库且该组件库使用了 dom 操作使用了 vue-router，暂不支持全局使用 vuex不过，方案都是可以调整的，以上功能在社区均可以找到替代方案。换之即可。"}
{"title": "小程序云开发初体验 ", "author": "Rolan", "pub_time": "2018-11-14 00:25", "content": "云开发\r\n开发者可以使用云开发开发微信小程序、小游戏，无需搭建服务器，即可使用云端能力。\r\n云开发为开发者提供完整的云端支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。\r\n类似于Bmob后端云或知晓云\r\n云开发的出现，让小程序的开发变得更简单方便，开发人员可以不用去购买搭建服务器，不用操心服务端的稳定性和数据库的安装\r\n\r\n开通云开发\r\n在微信开发工具里，直接点击'云开发'，会引导你开通， 需要注意的是云开发能力从基础库 2.2.3 开始支持\r\n\r\n云开发开通后自动获得一套云开发环境，各个环境相互隔离，每个环境都包含独立的数据库实例、存储空间、云函数配置等资源。每个环境都有唯一的环境 ID 标识，初始创建的环境自动成为默认环境。\r\n有一个免费的基础版\r\n开通云开发后初始默认可拥有最多两个环境。在实际开发中，建议每一个正式环境都搭配一个测试环境\r\n数据库\r\n云开发提供了一个json数据库(可以理解为MongoDB 这类 NoSQL 数据库)，就是一个json格式的对象。 一个数据库有多个集合，相当于关系型数据库的表。 集合数组里有多个对象，每一个对象就是一个记录，相当于关系型数据库中的行。数据库的操作提供了很多API，后面结合例子简单示例说明\r\n[\r\n    {\r\n      \"id\": 342166,\r\n      \"haspromotionTag\": false,\r\n      \"img\": \"http://p1.meituan.net/128.180/movie/740bd990e4af29d537ce324ec2cd08d6300433.jpg\",\r\n      \"version\": \"v2d imax\",\r\n      \"nm\": \"无双\",\r\n      \"preShow\": false,\r\n      \"sc\": 8.9,\r\n      \"globalReleased\": true,\r\n      \"wish\": 125425,\r\n      \"star\": \"周润发,郭富城,张静初\",\r\n      \"rt\": \"2018-09-30\",\r\n      \"showInfo\": \"今天183家影院放映2258场\",\r\n      \"showst\": 3,\r\n      \"wishst\": 0\r\n    },\r\n    {\r\n      \"id\": 1209159,\r\n      \"haspromotionTag\": false,\r\n      \"img\": \"http://p0.meituan.net/128.180/movie/4d9bedd239f41eaf08cd1c4297e4ec7d858156.jpg\",\r\n      \"version\": \"\",\r\n      \"nm\": \"找到你\",\r\n      \"preShow\": false,\r\n      \"sc\": 9,\r\n      \"globalReleased\": true,\r\n      \"wish\": 66559,\r\n      \"star\": \"姚晨,马伊琍,袁文康\",\r\n      \"rt\": \"2018-10-05\",\r\n      \"showInfo\": \"今天182家影院放映1039场\",\r\n      \"showst\": 3,\r\n      \"wishst\": 0\r\n    }\r\n]\r\n复制代码存储\r\n基础版提供了5G的存储容量，可以把文件(图片、视频...)上传到存储空间，在云端管理。直接使用小程序提供的上传下载接口，处理起来非常方便。\r\n云函数\r\n云函数是写后端代码的，云函数里可以操作数据库，操作存储，根据自身的业务需求完成后端代码的实现。云函数，是部署在云端的，但是我们可以在开发工具里编写后端的云函数，完成后再部署到云端，可以说所有逻辑都在一套代码里。\r\n我的第一个云开发小程序\r\n创建云开发项目时，据官方描述，在微信开发工具里，有一个QuickStart选项，但我发现并没有，可能是开发工具版本或其他原因。\r\n\r\n给数据库添加数据\r\n我在猫眼电影拷贝了部分数据，准备倒入小程序云开发的数据库\r\n\r\n可以看到，在控制台，可以自行添加数据，也可以直接倒入一个json文件。我这里选择调用它的API去倒入猫眼json数据\r\n首先我创建了一个名为movies的集合，紧接着调用初始化的方法\r\n\r\napp.js\r\n\r\n...\r\nonLaunch: function () {\r\n    wx.cloud.init()\r\n}\r\n...\r\n复制代码要操作数据库，需要先获取到数据库引用,  同时，获取到我刚创建的movies集合的引用, 由于在其他页面也需要调用，我这里把它们都挂到app的属性上\r\nconst app = getApp()\r\n...\r\napp.$db = wx.cloud.database()\r\napp.$collect_movies = app.$db.collection('movies')\r\n...\r\n复制代码最后， 调用添加的方法\r\ndata.subjects.forEach(o => {\r\n  app.$collect_movies.add({\r\n    data: o\r\n  })\r\n})\r\n复制代码现在云开发控制台数据库里已经有添加的数据了\r\n显示所有电影\r\napp.$collect_movies.where({\r\n  _openid: 'ofgUd0Rb4w8E7Af40N46ExxozS5g'\r\n}).get({\r\n  success: function (res) {\r\n    console.log('res', res)\r\n    that.setData({\r\n      movies: res.data\r\n    })\r\n  }\r\n})\r\n复制代码根据ID查询指定电影\r\napp.$collect_movies.doc('W8Wf4t2AWotkhlzK').get({\r\n    success: function (res) {\r\n      console.log('res',res)\r\n      that.setData({\r\n        movie: res.data\r\n      })\r\n    }\r\n})\r\n复制代码查询9分以上的电影\r\nconst _ = app.$db.command\r\napp.$collect_movies.where({\r\n    sc: _.gte(9)\r\n}).get({\r\n    success: function (res) {\r\n      wx.hideLoading()\r\n      that.setData({\r\n        movies: res.data\r\n      })\r\n    }\r\n})\r\n复制代码获取9分以上或0分的电影\r\nconst _ = app.$db.command\r\napp.$collect_movies.where({\r\n    sc: _.eq(0).or(_.gte(9))\r\n}).get({\r\n    success: function (res) {\r\n      wx.hideLoading()\r\n      that.setData({\r\n        movies: res.data\r\n      })\r\n    }\r\n})\r\n复制代码修改主演名\r\n# 确认修改\r\nconst that = this\r\napp.$collect_movies.doc(this.currentMovieId).update({\r\n  data: {\r\n    star: this.data.actor\r\n  },\r\n  success: function (res) {\r\n    that.initUpdateData()\r\n  }\r\n})\r\n复制代码删除一部电影\r\n# 确定删除\r\ndelAction(e) {\r\n    const that = this\r\n    const id = e.currentTarget.dataset.id\r\n    app.$collect_movies.doc(id).remove({\r\n      success: function (res) {\r\n        that.initUpdateData()\r\n      }\r\n    })\r\n}\r\n复制代码\r\n文件管理\r\n上传图片到云存储\r\n试着把手机相册的图片上传到小程序云存储中，可以在小程序端直接使用提供的api\r\nwx.cloud.uploadFile({\r\n  cloudPath: 'example.png', // 上传至云端的路径\r\n  filePath: '', // 小程序临时文件路径\r\n  success: res => {\r\n    // 返回文件 ID\r\n    console.log(res.fileID)\r\n  },\r\n  fail: console.error\r\n})\r\n复制代码如果单纯从代码量来看，比上传到腾讯自家腾讯云还简单，当然比上传到像阿里云、七牛云这样的平台操作更简单。\r\n上传成功之后，返回的不是图片url, 而是文件id。如果要显示图片或者播放视频，这个文件id，小程序的组件image/video也能识别\r\n <image class=\"movie\" mode=\"widthFix\" src=\"{{ fileId }}\" wx:if=\"{{ fileId }}\"> </image>\r\n复制代码upload() {\r\n    const that = this\r\n    wx.chooseImage({\r\n      count: 1,\r\n      sizeType: ['original', 'compressed'],\r\n      sourceType: ['album', 'camera'],\r\n      success(res) {\r\n        const tempFilePaths = res.tempFilePaths\r\n        console.log(tempFilePaths[0])\r\n        wx.cloud.uploadFile({\r\n          cloudPath: 'test/2.png', // 上传至云端的路径\r\n          filePath: tempFilePaths[0], // 小程序临时文件路径\r\n          success: res => {\r\n            // 返回文件 ID\r\n            console.log(res.fileID)\r\n            that.setData({\r\n              fileId: res.fileID\r\n            })\r\n          },\r\n          fail: console.error\r\n        })\r\n      }\r\n    })\r\n}\r\n复制代码\r\n\r\n根据文件id下载文件\r\ndownloadFile() {\r\n  wx.cloud.downloadFile({\r\n  fileID: 'cloud://ii-1853ca.6969-ii-1853ca/test/2.png',\r\n  success: res => {\r\n    // 返回临时文件路径\r\n    console.log('tempFilePath', res)\r\n    // cloud://ii-1853ca.6969-ii-1853ca/test/2.png\r\n    this.setData({\r\n      downloadFileResult: res\r\n    })\r\n  },\r\n  fail: err => {\r\n    // handle error\r\n  }\r\n})\r\n复制代码根据文件id换取临时网络链接\r\n可以根据文件 ID 换取临时文件网络链接，文件链接有有效期为两个小时\r\nconst that = this\r\nwx.cloud.getTempFileURL({\r\n    fileList: [this.data.fileId],\r\n    success: res => {\r\n      // https://6969-ii-1853ca-1253918415.tcb.qcloud.la/test/2.png\r\n      that.setData({\r\n        fileList: res.fileList\r\n      })\r\n    },\r\n    fail: err => {\r\n      // handle error\r\n    }\r\n})\r\n复制代码云函数\r\n怎么玩？\r\n云函数是运行在Node.js环境下的\r\n首先在小程序项目根目录找到配置文件project.config.json文件，加上一个配置, 指定本地已存在的目录作为云函数的本地根目录\r\n  \"cloudfunctionRoot\": \"./functions/\",\r\n复制代码指定之后神奇的一幕就是图标会变成 “云目录图标”\r\n\r\n子目录都是我通过右键菜单创建一个新的云函数，其中文件名就是云函数名\r\n每创建一个云函数，都会出现弹窗，询问你是否有node环境，确定后会自动打开终端，安装依赖, 所以每一个云函数里面都是这样的：\r\n\r\n在index.js中, 默认是这样的\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n\r\n}\r\n复制代码创建一个相加的云函数\r\n\r\nplus/\r\n\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\n// context 对象包含了此处调用的调用信息和运行状态\r\n// event 指的是触发云函数的事件\r\nexports.main = async (event, context) => {\r\n  return {\r\n    sum: event.a + event.b\r\n  }\r\n}\r\n复制代码在小程序端调用plus云函数, 参数名一眼就看明白，不用解释\r\nwx.cloud.callFunction({\r\n  name: 'plus',\r\n  data: {\r\n    a: 1,\r\n    b: 2,\r\n  },\r\n  success: function (res) {\r\n    console.log('plus', res.result) // 3\r\n  },\r\n  fail: console.error\r\n})\r\n复制代码调用后报错，是因为没有把创建的云函数上传部署到云端, 如何部署？看下图\r\n\r\n部署成功之后，我们来到云控制台， 发现云函数已经在上面\r\n\r\n回到小程序，再次调用云函数，发现已经可以了, 拿到了预期的值3\r\n获取小程序用户信息\r\n云开发的云函数的独特优势在于与微信登录鉴权的无缝整合。当小程序端调用云函数时，云函数的传入参数中会被注入小程序端用户的 openid，开发者无需校验 openid 的正确性，因为微信已经完成了这部分鉴权，开发者可以直接使用该 openid。与 openid 一起同时注入云函数的还有小程序的 appid\r\n定义云函数\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  return event.userInfo\r\n}\r\n复制代码调用云函数\r\nwx.cloud.callFunction({\r\n    name: 'userInfo',\r\n    success: function (res) {\r\n      console.log('userInfo', res.result)\r\n        /*\r\n          {\r\n            appId:\"wx8dae61dd0ef5c510\",\r\n            openId:\"ofgUd0Rb4w8E7Af40N46ExxozS5g\"\r\n           }\r\n        */\r\n    },\r\n    fail: console.error\r\n})\r\n复制代码异步云函数\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  return new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      resolve(event.a + event.b)\r\n    }, 3000)\r\n  })\r\n}\r\n复制代码在云函数中我们可以引入第三方依赖来帮助我们更快的开发。云函数的运行环境是 Node.js，因此我们可以使用 npm 安装第三方依赖。比如除了使用 Node.js 提供的原生 http 接口在云函数中发起网络请求，我们还可以使用一个流行的 Node.js 网络请求库 request 来更便捷的发起网络请求。\r\n注意，现在上传云函数时不会在云端自动安装依赖，需要开发者在本地安装好依赖后一起打包上传。\r\n云函数操作数据库\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\nconst db = cloud.database()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  // 获取电影集合数据\r\n  return db.collection('movies').get()\r\n}\r\n复制代码云函数调用其他云函数\r\n\r\n定义云函数\r\n\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  return await cloud.callFunction({\r\n    name: 'plus',\r\n    data: {\r\n      a: 1,\r\n      b: 2,\r\n    }\r\n  })\r\n}\r\n复制代码\r\n调用云函数\r\n\r\nwx.cloud.callFunction({\r\n  name: 'cloudFuncCallColundFunc',\r\n  complete: res => {\r\n    console.log('cloudFuncCallColundFunc', res)\r\n  },\r\n})\r\n复制代码云函数日志、测试\r\n可以看到调用的云函数的调用日志\r\n可以直接测试编写好的云函数，传入参数, 点击运行调试按钮即可\r\n云开发初体验总结\r\n云开发大概在8月份公测，9月份发布出来的，现在已经快11月份了，据官方描述，有很多开发人员参与进去，是他们没有预料到的， 同时也被提出了很多吐槽点，小程序的云开发也可以说是在试水阶段，有不少坑，后面肯定会越来越完善。 逐渐成熟，会是一个非常不错的解决方案， 特别是针对那些初创公司。作者：stupidWall链接：https://juejin.im/post/5bea4569e51d455d981bf43e"}
{"title": "Quikapp快应用【小程序】开发入门教程 ", "author": "Rolan", "pub_time": "2018-11-14 00:44", "content": "最近华为牵头国内几大厂商出了小程序Quikapp快应用，这里给大家编写快应用入门教程 首先记住几个网站1、官网：https://www.quickapp.cn 2、文档：https://doc.quickapp.cn/ 3、工具： 使用Visual Studio Code开发 使用WebStorm开发 教程地址（https://doc.quickapp.cn/tutorial/getting-started/code-edit-conf.html） 4.环境： 需安装6.0以上版本的NodeJS，请从NodeJS官网下载5.依赖库 hap-toolkit、hap-tools第一步：安装npm install -g hap-toolkit 安装第二步：hap脚手架生成一个初始项目hap init test1 初始化项目目录 这一步大家别急着npm run server 否则报一下错误报错第三步：安装依赖npm install第四步：运行服务npm run server image.png 还是失败，新出的东西官网还不是很完善，后面应该不会出现，这里花了几分钟找到了原因，项目少了hap-tools库， 这里没看到官网有这个库的介绍，package.json里也没 ap-tools 这个库的引入。 大家输入npm install hap-tools 手动安装下这个库。 安装 然后npm run server 开发者可以通过命令行终端或者调试服务器主页看到提供* 扫描的二维码 开发者通过快应用调试器扫码安装按钮，扫码安装待调试的rpk文件 开发者点击快应用调试器中的开始调试按钮，开始调试成功 完美快应用入门教程 给大家解释下目录说明├── sign rpk包签名模块 │ └── debug 调试环境 │ ├── certificate.pem 证书文件 │ └── private.pem 私钥文件 ├── src │ ├── Common 公用的资源和组件文件 │ │ └── logo.png 应用图标 │ ├── Demo 页面目录 │ | └── index.ux 页面文件，可自定义页面名称 │ ├── app.ux APP文件，可引入公共脚本，暴露公共数据和方法等 │ └── manifest.json 项目配置文件，配置应用图标、页面路由等 └── package.json 定义项目需要的各种模块及配置信息 大家像小程序一样，在这上面开发就好了。Quikapp快应用基于Nodejs内建一个本地服务器运行代码、语言JavaScript，语法支持ES6，如果熟悉vue\\weex一类的MVVM框架，基本可以直接入手。这一章是Quikapp快应用开发入门，有空补上下一章编写第一个快应用。Quikapp快应用、如何接入Bmob后端云？ 既然语言是JavaScript， 直接下载Bmob的JavaScript SDk引入，就可以直接操作后端数据库，配合云函数可以实现Quikapp快应用的接口对接。很快Bmob也会推出快应用的针对性SDK，这样云函数也不需要写了，跟小程序一样无需写一行后端代码，愉快的对接Quikapp快应用了。作者：微信小程序开发 链接：https://www.jianshu.com/p/eacb61ba1ef4"}
{"title": "小程序类似抖音视频整屏切换 ", "author": "Rolan", "pub_time": "2018-11-15 00:15", "content": "最近在项目中需要加一个功能，在小程序中将已有的短视频功能，按照抖音的方式来浏览，整屏，可上下滑动切换视频，并添加上滑下滑的动画。思路1.在video标签上添加时间监听。 2.如果1无法成功，就在video上面罩一层 cover-view，在cover-view上添加时间监听。 3.如果上面两种方法都不行，用小程序的onPageScroll页面处理函数来监听页面的滚动。 4.上述三种方法都不行的话，用canvas在video上面罩一层，监听滚动事件。尝试现在video标签上添加了触摸事件的监听，但是无法成功监听到触摸事件。 因为video 是原生组件，层级较高，所以尝试在上面罩一层cover-view，并监听滚动事件，但是同样无法监听。前面两种方法不行，我就采用了onPageScroll来监听页面是否发生滚动。这个方法会拿到当前页面在垂直方向已滚动的距离。scrollindex用来控制滚动，totalNum是滚动的总数，部分代码如下在ios上可以满足需求，能上下滚动，也能加上动画，但是在安卓上却不能动，尝试着在页面json文件中配置滚动相关，但都没办法，所以这个方法也不行了。最后只有canvas这一个办法了，在video组件上面定位一个canvas，在上面添加时间监听，这是发现成功了，可以在控制台看到打印出来的监听 console。实现wxml：下面是wxml代码，主要思路就是让video宽高等于屏幕，点赞评论分享等功能，用cover-view定位到视频上方，在将canvas定位到video上面滚动时滚动的是封面图案，video标签只有一个，滚动更改video的src。wxss:都是一些定位相关的样式没有特殊的样式就不贴图了。不过做的时候这里有个坑，产品希望添加无限的向下滑动视频，可以无限加载，所以最开始我才用的是animation动画，对每一屏根据手指向上或者向下添加动画，这样做的话就无法做到，后来发现可以使用小程序的api，wx.createAnimation()在js中实现。js：onload的时候this.animation = wx.createAnimation();用于切换时创建动画。需要监听的滚动事件js主要做的是判断滚动方向，给wxml通过微信提供的animation方法来动态添加动画，这样就可以实现无限加载的需求了。scrollTop的作用是用来调整video标签位置，因为现在滚动的时候添加滚动的事视频的封面图不是视频本身，需要隐藏视频，假如用wx:if；哎控制的话，会导致视频隐藏在展现之后无法监听之前添加的事件。效果在真机上可以生效，在手机上录了视频不知道怎么传上来，转gif也没找到在mac怎么转。。。最后弄了好久弄出来的，真机和模拟器的效果差异很大，最好在真机测试。目前也不知道有没有更好的办法，菜鸟前端一个～"}
{"title": "青铜选手带你动手撸一个博客小程序给自己（第二期） ", "author": "Rolan", "pub_time": "2018-11-15 00:28", "content": "上一篇的的的链接 赖了一个星期了，let us 接着上一篇的搞。在上一篇里搞了一下基础设施建设，这一篇我们...稍微搞那么一丢丢上层建筑。这一篇里本菜鸡想分享的tip小程序登陆逻辑与登陆状态维持的两种姿势发送评论时的一个投机倒把的小“优化”小程序微信登陆与前端登陆状态保存小程序登陆小程序登陆其实是个比较简单的基本操作，但凡是看过微信开发文档的应该都能懂，不过本菜鸡还是想尝试性的分享一下。首先先明确一下 为啥要用微信登陆 ，在本菜鸡看来在这个项目里使用微信登陆主要有三个目的方便用户 ：相比于用户手动注册、填写各种信息、再手动输入账号密码登陆，利用微信登陆用户点一下，就可以完成上面的全部操作，注册、登陆全都由后台利用微信提供的相关的信息完成方便后台用户管理使用微信的相关能力 ：通过微信登陆，后台可以获得唯一标识用户的openid，而这个openid，是后台调用微信相关敏感接口的必填项（例如：微信支付）然后，明确一下微信登陆过程中的几个概念然后，结合本次项目的实际情况捋一下微信登陆的流程调用wx.login方法获取code ，顺手调用一下wx.getUserInfo获取一下用户的基本信息（头像，微信名啥的）调用后端接口，将code与获取的用户信息userInfo（非必需）传递给后端。后端接收到参数，将code拿出来与存在后端的appid、appsecrect拼接成微信登陆链接$url='https://api.weixin.qq.com/sns/jscode2session?appid='.$this->appId.'&secret='.$this->appSecret.'&js_code='.$code.'&grant_type=authorization_code';\r\n复制代码访问该链接获得返回结果（json格式的），验证下是否成功，如果OJBK，就从结果里掏出openid$wxResult=json_decode(curl_get($url),true);\r\n if(!$wxResult||!array_key_exists('openid',$wxResult)){\r\n      return ResultService::failure('获取openid不成功');\r\n }\r\n $openId=$wxResult['openid'];\r\n复制代码其实获得到openid微信登陆已经差不多了，剩下就是怎么用的问题了，下面的步骤是在本次项目的流程，供各位老哥参考根据openid查一下数据库，看看是否是存在， 若存在 ，则说明是老用户，不用新增用户，直接用在步骤3中获取到的由前端传来的userInfo更新一下后台的用户信息即可（头像，省份，微信名啥的）。 若不存在 ，则这是个新用户，把openid与userInfo存到用户表中经过步骤5，库里已经有了这个用户的数据，然后拿用户数据，按照一定规则，生成个token返回给小程序端，小程序端把token存到localStorage里，后端将token与用户信息以键值对的形式存到缓存里，以后小程序请求的时候带着token来，后端根据token查缓存来确定用户登陆状态。至此，本项目中微信登陆的流程搞完了。登陆完的结果就是，后台新增或更新了用户数据，小程序端有了token。小程序登陆状态保持本菜鸡个人觉得常用的保持登陆状态的方法有两种token（个人推荐）session先说第一种，也是本项目采用的方法，其实在上面的步骤5、6已经把这个方法将清楚了，登陆后服务端下发token给小程序端，同时服务端自己也存一份，存哪里就根据实际情况（cache、redis、session啥的都行），然后搞个有效期，过期了就消失得那种。小程序每次请求后端接口的时候把token放到header里后端在处理请求前先把token从header里取出来，拿这个token去查缓存，如果有，就说明用户还在登陆状态，继续往后走，如果没有，则说明用户离线了，就直接返回一下告诉小程序端需要重新登陆，小程序收到后跳转到登录页。第二种也在做网站用户登陆的时候是非常常见的操作，在撸网站的时候，用户登陆后把用户信息存到session里，用户在请求的时候能够从session中取到用户信息，之所以这样是因为，浏览器请求服务器，服务器响应时，会带一个sessionid回去给浏览器，浏览器下次请求时候会自动带着sessionid，服务器会根据sessionid来到相应的会话里，所以能取到session中的用户BUT在小程序中有所不同，这是因为小程序网络访问是用的微信封装的wx.request，而该方法并不会把sessionid存下来，因此，为了能和网站登陆搞成一个逻辑，我们手动存一下sessionid，在下次请求的时候带着sessionid去即可。部分代码如下服务端（PHP）//前面先搞登陆，登陆完了把用户存到session里然后\r\nreturn ResultService::success('',['sessionId'=>session_id()]);\r\n\r\n复制代码小程序端//登陆\r\ndataUtils.userLogin({ code: code, info: JSON.stringify(info) }).then(res => {\r\n        if (res.statusCode == '200') {\r\n          wx.setStorageSync('sessionId', res.data.data.sessionId);\r\n          $Message({\r\n            content: '登陆成功',\r\n            type: 'success'\r\n          });\r\n          this.checkUserLogin();\r\n        }\r\n        else {\r\n          $Message({\r\n            content: '登陆未成功',\r\n            type: 'error'\r\n          });\r\n        }\r\n//请求例子（不同后端header名不一样，比如php的后端就是 PHPSESSID=你的sessionId）\r\nfunction userJoinPromise(data,sessionId){\r\n  let url = 'travel/api/userJoin';\r\n  return getServerDataPromise(url, data, { 'Cookie': 'PHPSESSID=' + sessionId });\r\n}\r\n复制代码下班了下班了，先写到这明天继续撸"}
{"title": "微信小程序之canvas 文字断行和省略号显示 ", "author": "Rolan", "pub_time": "2018-11-15 00:42", "content": "文字的多行处理在dom元素中很好办。但是canvas中没有提供方法，只有通过截取指定字符串来达到目的。那么下面就介绍我自己处理的办法：wxml：<canvas canvas-id='word' id='test'></canvas>canvas肯定要一个画板容器啦，记得设置宽高哦，小程序中默认宽高是300px和150pxjs：在page中//处理文字多出省略号显示\r\n    dealWords: function (options) {\r\n        options.ctx.setFontSize(options.fontSize);//设置字体大小\r\n        var allRow = Math.ceil(options.ctx.measureText(options.word).width / options.maxWidth);//实际总共能分多少行\r\n        var count = allRow >= options.maxLine ? options.maxLine : allRow;//实际能分多少行与设置的最大显示行数比，谁小就用谁做循环次数\r\n            \r\n        var endPos = 0;//当前字符串的截断点\r\n        for (var j = 0; j < count; j++) {\r\n            var nowStr = options.word.slice(endPos);//当前剩余的字符串\r\n            var rowWid = 0;//每一行当前宽度    \r\n            if (options.ctx.measureText(nowStr).width > options.maxWidth) {//如果当前的字符串宽度大于最大宽度，然后开始截取\r\n                for (var m = 0; m < nowStr.length; m++) {\r\n                    rowWid += options.ctx.measureText(nowStr[m]).width;//当前字符串总宽度\r\n                    if (rowWid > options.maxWidth) {                        \r\n                        if (j === options.maxLine - 1) { //如果是最后一行\r\n                            options.ctx.fillText(nowStr.slice(0, m - 1) + '...', options.x, options.y + (j + 1) * 18);    //(j+1)*18这是每一行的高度        \r\n                        } else {\r\n                            options.ctx.fillText(nowStr.slice(0, m), options.x, options.y + (j + 1) * 18);\r\n                        }\r\n                        endPos += m;//下次截断点\r\n                        break;\r\n                    }\r\n                }\r\n            } else {//如果当前的字符串宽度小于最大宽度就直接输出\r\n                options.ctx.fillText(nowStr.slice(0), options.x, options.y + (j + 1) * 18);\r\n            }\r\n        }\r\n    },（1） measureText（）.width 这是小程序 测量文本尺寸信息的方法，目前仅返回文本宽度。这里是官方说明（2） (j + 1) * 18   中18表示每一行行高是18，这是我自己定义的行高如果这个数值小于定义的字体大小，多半会出现两行文字重叠的现象，前面的 j+1 表示当前是多少行。整体表示当前行与上一行相比需要加多少距离（3） 在 j===options.maxLine-1 这个表示最后一行的处理情况里面   有slice(0，endPos-1)，为什么这里要减一，是因为省略号也要占宽度，大概是11.5的样子，所以要减掉这个省略号的宽度。因为一般中文字符宽度都和设置的字体大小差不多。如果是英文就要小一点，这里就没有考虑这么精细了。反正减一就是精确度的意思。。。可以自行多减或者少减（4） endPos += m 表示下一次截断的时候是从哪里开始。因为每次去截字符串都是最初的字符串，并没有真正意义上的截断一次之后就是剩下的字符串了，所以要把每次截断的点和上一次截断的点加上，才是最新一次字符串截断的位置。（5） 循环和判断使用的有点多，不知道对性能有没有影响。。。。。。调用的时候：var ctx = wx.createCanvasContext('word');\r\nvar name='窗前明月光，疑是地上霜，举头望明月，低头思故乡。';\r\nthis.dealWords({\r\n    ctx: ctx,//画布上下文\r\n    fontSize: 16,//字体大小\r\n    word: name,//需要处理的文字\r\n    maxWidth: 100,//一行文字最大宽度\r\n    x: 0,//文字在x轴要显示的位置\r\n    y: 0,//文字在y轴要显示的位置\r\n    maxLine: 3//文字最多显示的行数\r\n})\r\nctx.draw(); （1） 这个方法能够处理一行或者多行的情况，就看maxLine设置的大小了。当然如果设置maxLine为0或者-1，就会不显示的。。。看一下效果：（1） canvas我设置的是200 * 200的大小，其它的设置就是上面调用的时候设置的（1） 这是当maxWidth设置为200px的时候的显示情况。 完成 (＾－＾)V"}
{"title": "论如何将 h5 页面快速转换成微信小程序 ", "author": "Rolan", "pub_time": "2018-11-16 00:32", "content": "微信小程序自开放出来到现在也有一段时间了，相信其底层架构也被琢磨得差不多了。微信小程序本身是双线程运行的结构，而 h5 页面是单线程的运行模式，因此两者无法直接互通。微信小程序的运行模式如下：微信小程序本身提供了 web-view 组件来支持在微信小程序中嵌入 h5 页面，但是 web-view 组件在使用上还是有一些限制：不支持个人类型与海外类型的小程序、不支持全屏、页面与小程序通信不方便、很多小程序接口无法直接调用等。如果无法使用 web-view，这里还有一条路可以走，利用 h5-to-miniprogram 工具来将 h5 页面转换成小程序。起步假设你已经有一个 h5 页面，包含四个文件：h5 页面\r\n   |---- index.html\r\n   |---- index.css\r\n   |---- index.js\r\n   |---- index.png\r\n复制代码这种结构我们再熟悉不过了，具体每个文件的内容可参考这里： github.com/wechat-mini…。页面渲染出来的效果如下：页面很简单，但是值得一提的时，这个页面引入了 jQuery 库，所以 index.html 和 index.js 是这样的：<!doctype html>\r\n<html lang=\"zh\">\r\n  <head>\r\n    <meta charset=\"utf-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no, minimal-ui\">\r\n    <meta content=\"yes\" name=\"apple-mobile-web-app-capable\">\r\n    <meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\">\r\n    <meta name=\"format-detection\" content=\"telephone=no, email=no\">\r\n    <title>demo</title>\r\n    <style type=\"text/css\">\r\n      html, body {\r\n        width: 100%;\r\n        height: 100%;\r\n      }\r\n    </style>\r\n    <link rel=\"stylesheet\" href=\"./index.css\">\r\n  </head>\r\n  <body>\r\n    <img class=\"logo\" src=\"./index.png\">\r\n    <div class=\"cnt\"></div>\r\n    <script src=\"https://juneandgreen.github.io/test/h5-to-miniprogram-demo/demo2/js/jquery-1.12.4.min.js\"></script>\r\n    <script src=\"./index.js\"></script>\r\n  </body>\r\n</html>\r\n复制代码$(document).ready(function() {\r\n  $('.cnt').text('h5 to miniprogram');\r\n});\r\n复制代码微信小程序里是不暴露 dom/bom 接口的，说想要使用 jQuery 是非常困难的。尽管难以置信，但是确实是有办法的，后面会简述一下原理，让我先继续看下要如何操作。配置因为运行环境的不同，为了在编译时和运行时对两者进行一些兼容操作，我们需要一份配置文件：module.exports = {\r\n  index: 'h5', // 首页\r\n  urlMap: { // 每个页面对应的初始 url\r\n    h5: 'https://weixin.qq.com/index?a=1&b=2#hash',\r\n  },\r\n  resFilter(src, pageKey) {\r\n    // 资源过滤，用于替换 h5 中使用到的资源路径\r\n    return pageKey === 'h5' && src === './index.png' ? 'https://raw.githubusercontent.com/wechat-miniprogram/h5-to-miniprogram-demo/master/h5/index.png' : src\r\n  },\r\n}\r\n复制代码配置文件很简单，就是一个 js 文件，里面包含各种配置项。例如 index 配置项用于配置首页； urlMap 用于配置每个页面的初始 url，这个 url 会被解析到 window.location 中，通常用于页面跳转或单页系统中； resFilter 配置项用于调整资源路径，这里是因为考虑到微信小程序包大小有限制，默认不会去处理图片等资源，所以需要提供一个方法来替换资源路径为网络路径。因为配置文件需要拷贝到微信小程序项目中执行，所以配置文件必须是一个纯净的没有额外依赖的文件（比如 require('fs') 在配置文件中是不允许的）。构建生成有了原始的 h5，有了配置文件，那就可以开始进行转换并生成微信小程序项目了。我们来编写一个构建脚本，起名为 build.js：const path = require('path')\r\nconst toMiniprogram = require('h5-to-miniprogram')\r\n\r\ntoMiniprogram({\r\n  entry: { // 入口 h5 页面路径\r\n    h5: path.join(__dirname, './h5/index.html'),\r\n  },\r\n  output: path.join(__dirname, './miniprogram'), // 输出目录\r\n  config: path.join(__dirname, './config.js'), // 配置文件路径\r\n}).then(res => {\r\n  console.log('done')\r\n}).catch(err => {\r\n  console.error(err)\r\n})\r\n复制代码构建脚本也很简单，引入 h5-to-miniprogram 工具，此工具直接暴露一个 async 方法，调用时将必须的参数传入即可。可以看到参数中的入口配置是一个 key-value 对象，这里的 value 不能理解，就是页面的路径，key 则是页面的名称。例子中这个页面的 key 就是 h5，我们回到上面的配置文件那里就会发现，很多个地方都需要用到这个 key，这个 key 可以作为页面的唯一标识。写完构建脚本后，后续就简单很多了，执行：node build.js\r\n复制代码然后就会看到构建脚本中指定的输出目录—— miniprogram 目录被生成出来。完整的 demo 在这里： github.com/wechat-mini…使用使用官方提供的开发者工具打开 miniprogram 目录，可以看到已经基本达到我们想要的效果了：原理原理其实很简单，h5 页面在浏览器运行的过程就是解析 html 到渲染 dom 树的过程，然后提供一些 dom/bom 接口给 js 调用。那么在小程序中我们把这一套给模拟一遍就行了，方法很暴力，但是却意外的有效：因为给 h5 页面提供了类似浏览器的环境，实现了最底层的适配，所以理论上来说那些通用的框架和库也能支持运行。上面的例子中就表明了 jQuery 是能够运行的，像 react、vue 也是可以做到支持的。微信小程序是双线程的运行模式，视图层专注于渲染，逻辑层专注于逻辑。逻辑层是在一个纯净的 js 线程中跑，那里没有 dom/bom 接口，只能运行页面逻辑层的代码。要模拟浏览器环境，最基本的就是要在逻辑层里模拟出一棵 dom 树，本质上和建立一棵虚拟树类似，因为它并不是真实的 dom 树。整个流程简单来说是这样的：不管是页面中的静态 html 内容还是使用 innerHTML 等接口动态插入的 html 内容都可以走上面的流程来进行 dom 树的创建。dom 树创建比较简单，只是细节比较多，此处的关键是将创建好的 dom 节点映射到微信小程序的自定义组件，利用自定义组件的特性可以轻易的将我们创建好的 dom 树给渲染出来。如果你还不清楚微信小程序的自定义组件是什么的话，可以戳官方文档了解一下。"}
{"title": "小程序云开发之踩到狗尾巴 ", "author": "Rolan", "pub_time": "2018-11-19 00:05", "content": "前段时间用了下快狗打车，感觉贼方便，师傅响应速度和服务态度都特别好，搬个家再也没有以前那么痛苦了，女票也是给了大大的赞。正好最近毕业设计选题跟这个类似，参考了云开发文档，真心感觉云函数，云数据库，快且好用，立马开写，快快搞定毕设，好好工作（欢迎hr小姐姐楼层回复撩我）。不料，快速云开发之快狗毕设项目，犹如踩上了狗尾巴，坑坑真多，给各位像我一样，要快速写毕设，快速听女票话搬家的同学，记录一下。先给你们看下运行效果：一、程序骨架的基本构建1.功能的完整实现做个东西首先就是要把它的基本功能实现了，这个是毋庸置疑的。如果你是自己准备做个自己的小 程序，那么你肯定要对自己的小程序应该实现怎样的功能了如指掌，在心里应该把实现功能的流程 预演个几百遍了。这里第一个坑就出现了，我做的那会可没有想这么多，毕竟作为一个愣头青，莽 就完事了，从想法出来到开始动手时间不到1个小时，事实证明这是非常非常不可取的，也充分暴露 了我经验的不足。如果你不想像我一样写到后面一步一坑的话，最好提前想好。2.页面的基本构建作为一个较大的项目，主页结构应该做到结构清晰，语义化良好，尽量使用BEM命名规范，当然你要 是想你的代码写完后自己都看不懂，你就瞎**命名当我没说。整个页面大概采用什么布局也要事先 想想清楚，当然手机端一般都是弹性布局比较好，让你的页面元素可大可小，完美适配不同尺寸的 手机。布局的时候千万不要舍不得用盒子，如果把布局比作是整理衣柜的话，当你的衣服足够 多的话，一两个衣柜显然是无法满足条件的，你的衣服将被堆在一起，凌乱不堪。但是如果你有足 够的衣柜来放置衣服的话，你的衣服将被分门别类放置的整整齐齐。在本小程序中，主页的弹性布 局是将地图部分设置为 flex:1 ，让地图高度随手机大小来变化，而其他部分保持不变来实现的。 但是在实际运行中，却总是出现各种问题，最终我的解决办法是再在页面中总出问题的部分加入了 一个盒子，又在弹性布局里嵌套了一个弹性布局，这样首页的适应性布局就完美实现了。3.数据库的设计云开发的发布，让后端对于数据的操作变的更简单了。微信小程序本质上是数据驱动页面，所以你 想在页面上展示什么，就设置一个对应的数据去关联。然后当我们想改变页面的时候，只需要改动 数据就可以了。由于我这个小程序数据比较简单，并没有把所有的数据都放在云端，我只建立一张 订单表orders。因为订单里展示的信息不多所以只有‘时间’‘发货地’‘收货地’‘价格’几个属性，‘isdone’是用来标 记订单是否完成的，表现在页面中就是订单状态会显示‘已完成’或者‘已取消’4. 选个好组件库这个不是必须的，但是有时候选择到一个适合的组件库用起来真的爽，可以让你的开发事半功倍 我选的是vant(这个我选的就不是很好)，希望你能选上一个让你用完发出一句真香感慨的。二、程序功能的基本实现如果你已经完成了上面的前三步，那你简直比我好太多了！剩下的只不过是将功能一个一个添加上 去罢了。由于本程序的实现使用了大量api，我不会去把这些api一个个详细讲解，这样纯粹是浪费 时间。但是我会把一些实现想法和一些我遇到的坑像大家说明，避免你们像我一样踩坑。1. 实时获取点的坐标并将地址显示在页面仔细看了演示图的同学会发现当我移动地图时，起点的地址是在实时发生变化的，当我停止拖动 地图时，起点的地址就会更新到最新点。那么这个功能是如何实现的呢？其实这里是有一点巧妙的。实际上我用cover-image在地图上标记了一个起点，这个点是一直垂直居中固定在地图的中心的 。这样我只需要获取这个中心点的坐标并使用逆地址解析就能得到这个点的位置描述啦，是不是有 点巧妙。而怎么获取中心点的坐标和完成逆地址解析呢，当然这一切都有腾讯爸爸提供给我们的ap i去完成了。这里有个注意的点就是我们应在用户松开时来显示更新后的地址，bindregionchang这 个可以做到，当 e.type = end 时再显示就可以了，细节虽然小，但是还是不能忽视了。2. 输入地址时要能有模糊搜索提示这个效果主要依赖于腾讯地图小程序jsSDK中的输入关键词提示，调用这个接口我们将可以在返回 值中拿到一个数组，里面包含着我们需要的各种信息。拿到数据是很简单的，但是如何处理它呢？ 这个数组的长度是不固定的，其实很简单我们只需要将拿到的数据setData给一个我们定义的空数 组searchresult，这样所有的数据就到了这个数组里，到时候再去页面上循环这个数组，这样我们 就可以将里面的数据都拿出来并让它们显示在它们该显示的地方，所以这部分的关键在wxml里，下 面是我写的：<view class=\"content\">\r\n  <scroll-view class=\"scrollcontent\" scroll-y style=\"height: {{scrollheight}}rpx;\">\r\n    <block wx:for=\"{{searchresult}}\" wx:key=\"index\">\r\n      <van-cell-group border=\"{{true}}\">\r\n        <van-cell class=\"resultlist\" title=\"{{item.title}}\" border=\"{{true}}\" data-title=\"{{item.title}}\"\r\n        data-location=\"{{item.location}}\" icon=\"location\" label=\"{{item.address}}\" bind:click=\"getlistvalue\"/>\r\n      </van-cell-group>\r\n    </block>\r\n  </scroll-view>\r\n</view>\r\n复制代码3.主页车型切换并带来价格的变化这个需求是让顾客可以自由选择车型，这个有点类似滴滴打车的‘快车’'拼车'‘优享’。刚开始做的 时候我以为这是一个scroll-view和scroll-into-view配合来实现的。等到我把一切基本都实现了的 时候，最后一个效果就是实现滑动切换时划过一定距离就自动进入下一页，不够据距离就回弹。我 想了很多方法来判断，各种js判断各种利用scroll-left都搞不定。直到我无意中在官方文档中看到 了swiper这个组件，这丝般顺滑的滑动切换，距离够了自动下一页，不够就回弹，这不就正是我所 需要的吗，于是我直接删了原来的代码，花了不到半个小时就撸完了这个小组件（核心在于判断cur renttab与index是否相等，注意这个index后面还有大用）。看到这完美效果的我不禁泪流满面。所 以这件事告诉我们当你一直搞不定某个效果时，你应该静下心来想想是不是你开始就弄错了方向， 避免做无用功，浪费时间。接下来奉上我完美实现的代码(wxml和js部分)：wxml:<view class=\"container\">\r\n    <view class=\"container-header\">\r\n    <view class=\"carLists {{currentTab === index ?'on': ''}}\" wx:for=\"{{carName}}\" wx:key=\"index\" data-id=\"{{item.id}}\" data-index=\"{{index}}\" bindtap=\"switchTab\">\r\n      {{item.name}}\r\n    </view>\r\n    </view>\r\n    <block wx:if=\"{{index>0}}\">\r\n        <van-icon name=\"arrow-left\" class=\"arrow-left\" bind:click=\"last\" />\r\n    </block>\r\n    <block wx:if=\"{{index<3}}\">\r\n        <van-icon name=\"arrow\" class=\"arrow\" bind:click=\"next\" />\r\n    </block>\r\n    <swiper class=\"carList\" current=\"{{currentTab}}\" bindchange=\"swiperChange\">\r\n      <block wx:for=\"{{cars}}\" wx:key=\"index\">\r\n        <swiper-item class=\"carview\">\r\n          <image class=\"carImg\" src=\"{{item.image}}\" mode=\"aspectFill\"/>\r\n        </swiper-item>\r\n      </block>\r\n    </swiper>\r\n  </view>\r\n复制代码js:switchTab:function(e){\r\n      if (this.data.currentTab === e.target.dataset.index) {\r\n        return;\r\n    } else {\r\n        this.setData({\r\n            currentTab: e.currentTarget.dataset.index,\r\n            index:e.currentTarget.dataset.index\r\n        })\r\n    }\r\n  },\r\n  \r\n  \r\n  swiperChange:function(e){\r\n    // console.log( e.detail)\r\n    if(e.detail.source == 'touch'){\r\n      this.setData({\r\n        currentTab: e.detail.current,\r\n        index:e.detail.current\r\n    })\r\n    }\r\n   \r\n  },\r\n    next:function(e){\r\n      // console.log(this.data.currentTab,this.data.currentTab)\r\n       if (this.data.currentTab === this.data.index && this.data.currentTab <3 ) {\r\n          this.setData({\r\n            currentTab:this.data.currentTab + 1,\r\n            index:this.data.index +1\r\n          })\r\n        }\r\n       \r\n    },\r\n  \r\n    last:function(e){\r\n      if (this.data.currentTab === this.data.index && this.data.currentTab > 0 ) {\r\n        this.setData({\r\n          currentTab:this.data.currentTab - 1,\r\n          index:this.data.index -1\r\n        })\r\n      }\r\n    }\r\n复制代码4.关于距离及价格的计算之前在输入起点和终点的时候我们可以通过腾讯地图的api拿到两者的具体坐标，这里我采用的距 距离计算没有采用腾讯地图所提供的api(因为有距离限制，仅限10km以内)，这个距离对于我们来说 无疑是太短了，于是我采取了一个通用公式，只要能有两地坐标，便可以算出两地间的距离，这样 一来我们的老司机们就不用再受到距离的限制了。//计算两坐标点之间的距离\r\n      distance: function (lat1, lng1, lat2, lng2) {\r\n        const rad1 = lat1 * Math.PI / 180.0;   \r\n        const rad2 = lat2 * Math.PI / 180.0;   \r\n        const a = rad1 - rad2;   \r\n        const b = lng1 * Math.PI / 180.0 - lng2 * Math.PI / 180.0;  \r\n        const r = 6378137;\r\n        const distance = (r * 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) + Math.cos(rad1) * Math.cos(rad2) * Math.pow(Math.sin(b / 2), 2)))).toFixed(0)\r\n        return distance / 1000;//单位转化为公里\r\n      }\r\n复制代码现在我们拿到了距离，但是怎么能让价格根据所选车型来动态变化呢？还记得之前页面里给每个 滑块的index吗？这里我们恰好就可以用它来做一个switch判断，给getPrice函数传入一个index 参数判断不同值并给出不同的计价方式，这样一来价格变会随着车型的切换而变化了。最后我们 的效果就达到了。5.订单完成数据的上传及拉取有了云开发之后数据库的操作简直不要太简单了！取消订单时，在选择完取消订单理由后，们 将向云数据库添加一条数据，只需几条命令我们就可以将我们的数据真正的存在数据库里并保存起 来，听上去是不是很心动呢wx.cloud.init();//初始化\r\nconst db = wx.cloud.database();\r\nconst cancelOrder = db.collection('orders')//orders为手动在云数据库里添加的一张空表\r\n//三步操作后我们就连上了我们的数据库\r\n    cancelOrder.add({\r\n      data:{\r\n        time:globalData.time,\r\n        shipAddr:globalData.address,\r\n        receiveAdrr:globalData.receiveAdrr,\r\n        price:globalData.price,\r\n        isdone:false\r\n      }\r\n    })\r\n复制代码这样订单数据就被我们添加到了数据库里，可以被我们随时访问了。然后在通过一条简单的查 询语句就可以在我的订单里显示了。orders.where({\r\n      _openid:'xxxxxxxx'//用户的openid\r\n    }).get({\r\n      success: res=> {\r\n        this.setData({\r\n          orders:res.data\r\n        })\r\n        // console.log(res.data)\r\n        wx.hideLoading();//加载完成关闭加载框\r\n      }\r\n    })\r\n复制代码最后在页面上循环输出orders里的值就可以得到一堆订单了写在最后一个完整项目的实现确实不是那么简单的，即使是一个简单流程的实现，很多看似简单的东西 里经常藏着大坑，而不同页面之间的联系也是很让人头痛的，我们要从之前那种局部的眼光中跳脱 出来，从更大的层面来看待构建我们的项目骨架。使用组件化，函数化的编程思想可以很好的帮助 我们降低代码的耦合性，增加代码的复用性，使我们的代码结构更清晰。写本篇文章的目的是为了 方便自己以后重构项目的时候看，也是为了给有跟我一样想法，跃跃欲试想撸个完整项目的同学一 个参考，少踩一些坑。最后有什么建议或者文中有什么错误的地方欢迎在评论中指出，互相学习， 共同进步！这是我在掘金发的第一篇文章，看完觉得还不错的同学点个赞再走吧！完整项目点这： 项目地址主要参考:快狗打车拉货搬家微信小程序微信小程序官方文档： developers.weixin.qq.com/miniprogram…腾讯地图api文档： lbs.qq.com/qqmap_wx_js…vant Weapp小程序ui组件库： youzan.github.io/vant-weapp/…"}
{"title": "微信小程序之物流状态时间轴 ", "author": "Rolan", "pub_time": "2018-11-1 00:16", "content": "一个月左右没更新博客了，最近有点懒了哈（工作上真的忙），很多工作上学习到的东西都没有及时分享出来，有点愧疚，不过自己最近一直在收集资料和学习一些新技术，最主要是想要构建自己的前端技术体系和自定义一个前端规范文档，哈哈哈。说重点啦，微信小程序里面开发的商城模块还挺多的，刚好写了一个物流状态的时间轴，简单分享一下哈。（一）实现效果真机测试的结果（图片忘记缩小了）（二）实现分析页面布局拆分：简单的说：就是父级容器下，左边的子级容器是设置绝对定位（记得父级要设置相对定位哈），然后自己调位置，中间子级容器下放三个子容器（设置时间轴线、点的样式），右边的子级容器设置； wxml代码有备注信息 。（三）实现代码1、wxml代码：<view class='g_con'>\r\n\r\n  <view class='topExpress'>\r\n\r\n    <view class='topExpress-left'>\r\n      <image src='/images/Exchange_goods_map_1.png' style='width:60rpx;height:60rpx;border-radius:50%;'></image>\r\n    </view>\r\n    <view class='topExpress-right'>\r\n      <view class='topExpress-right-top'>圆通速递</view>\r\n      <view class='topExpress-right-middle'>运单号：813291235464788594</view>\r\n      <view class='topExpress-right-bottom'>官方电话 95554 ></view>\r\n    </view>\r\n\r\n  </view>\r\n\r\n  <!-- 物流时间轴 -->\r\n  <view class='expressRecord'>\r\n\r\n\r\n    <!-- 顶部收货地址 -->\r\n    <view class='expressRecord-getAddress'>\r\n      <view class='expressRecord-top'>\r\n        <view class='getAddress-icon'>\r\n          收\r\n        </view>\r\n        <view class='getAddress-text'>[收货地址] 广东省深圳市南山区 南山街道 亿利达大厦</view>\r\n      </view>\r\n    </view>\r\n\r\n    <!-- 顶部收货地址半个时间轴线 -->\r\n    <view class='noReach-online-top-close'></view>\r\n\r\n\r\n    <!-- 单个物流记录点时间轴：当前正在进行的物流状态 -->\r\n    <view class='expressRecord-single-close'>\r\n\r\n      <!-- 左边子容器 -->\r\n      <view class='expressRecord-single-noReach-online-top-close'>\r\n        <!-- 正在进行的时间轴上半个时间线 -->\r\n        <view class='online-top-closing'></view>\r\n        <!-- 正在进行的时间轴点 -->\r\n        <view class='dot-closing'></view>\r\n        <!-- 正在进行的时间轴下半个时间线 -->\r\n        <view class='online-bottom'></view>\r\n      </view>\r\n\r\n      <!-- 右边子容器 -->\r\n      <view class='expressRecord-text'>\r\n        <view class='expressRecord-statusing'>运输中</view>\r\n        <view class='expressRecord-status-addressing'>武汉转运中心公司 已发出，下一站 深圳转运中心</view>\r\n      </view>\r\n\r\n      <!-- 相对父级容器绝对定位的日期 -->\r\n      <view class='expressRecord-dating'>\r\n        <view class='expressRecord-date-text'>\r\n          昨天\r\n        </view>\r\n        <view class='expressRecord-date-time'>\r\n          20:39\r\n        </view>\r\n      </view>\r\n    </view>\r\n\r\n\r\n    <!-- 单个物流记录点时间轴：已经过去的物流状态 -->\r\n    <view class='expressRecord-single-close'>\r\n      <view class='expressRecord-single-noReach-online-top-close'>\r\n        <view class='online-top-close'></view>\r\n        <view class='dot-close'></view>\r\n        <view class='online-bottom'></view>\r\n      </view>\r\n\r\n      <view class='expressRecord-text'>\r\n        <view class='expressRecord-status'></view>\r\n        <view class='expressRecord-status-address'>武汉转运中心公司 已收入</view>\r\n      </view>\r\n\r\n      <view class='expressRecord-date'>\r\n        <view class='expressRecord-date-text'>\r\n          昨天\r\n        </view>\r\n        <view class='expressRecord-date-time'>\r\n          20:37\r\n        </view>\r\n      </view>\r\n    </view>\r\n\r\n\r\n\r\n\r\n    <view class='expressRecord-single-close'>\r\n      <view class='expressRecord-single-noReach-online-top-close'>\r\n        <view class='online-top-close'></view>\r\n        <view class='dot-close'></view>\r\n        <view class='online-bottom'></view>\r\n      </view>\r\n\r\n      <view class='expressRecord-text'>\r\n        <view class='expressRecord-status'></view>\r\n        <view class='expressRecord-status-address'>湖北省孝感市汉川市公司 已打包</view>\r\n      </view>\r\n\r\n      <view class='expressRecord-date'>\r\n        <view class='expressRecord-date-text'>\r\n          昨天\r\n        </view>\r\n        <view class='expressRecord-date-time'>\r\n          14:37\r\n        </view>\r\n      </view>\r\n    </view>\r\n\r\n\r\n\r\n\r\n    <view class='expressRecord-single-close'>\r\n      <view class='expressRecord-single-noReach-online-top-close'>\r\n        <view class='online-top-close'></view>\r\n        <view class='dot-close'></view>\r\n        <view class='online-bottom'></view>\r\n      </view>\r\n\r\n      <view class='expressRecord-text'>\r\n        <view class='expressRecord-status'>已揽件</view>\r\n        <view class='expressRecord-status-address'>湖北省孝感市汉川市公司 已收件</view>\r\n      </view>\r\n\r\n      <view class='expressRecord-date'>\r\n        <view class='expressRecord-date-text'>\r\n          昨天\r\n        </view>\r\n        <view class='expressRecord-date-time'>\r\n          14:17\r\n        </view>\r\n      </view>\r\n    </view>\r\n\r\n\r\n\r\n\r\n\r\n    <view class='expressRecord-single-close'>\r\n      <view class='expressRecord-single-noReach-online-top-close'>\r\n        <view class='online-top-close'></view>\r\n        <view class='dot-close'></view>\r\n        <!-- 起始位置，下半个时间轴线不用 -->\r\n        <view class='online-bottom-start'></view>\r\n      </view>\r\n\r\n      <view class='expressRecord-text'>\r\n        <view class='expressRecord-status'>已发货</view>\r\n        <view class='expressRecord-status-address'>卖家发货</view>\r\n      </view>\r\n\r\n      <view class='expressRecord-date'>\r\n        <view class='expressRecord-date-text'>\r\n          昨天\r\n        </view>\r\n        <view class='expressRecord-date-time'>\r\n          13:50\r\n        </view>\r\n      </view>\r\n    </view>\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  </view>\r\n\r\n\r\n\r\n</view>\r\n复制代码2、wxss代码：page {\r\n  background: #f4f4f4;\r\n}\r\n\r\n.g_con {\r\n  width: 100vw;\r\n  overflow-x: hidden;\r\n}\r\n\r\n.topExpress {\r\n  width: 710rpx;\r\n  height: 155rpx;\r\n  background: #fff;\r\n  margin: 10rpx auto;\r\n  display: flex;\r\n  border-radius: 10rpx;\r\n}\r\n\r\n.topExpress-left {\r\n  width: 100rpx;\r\n  height: 100%;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n\r\n.topExpress-right {\r\n  font-size: 26rpx;\r\n  color: #333;\r\n  display: flex;\r\n  justify-content: space-around;\r\n  flex-direction: column;\r\n  align-items: flex-start;\r\n  padding: 20rpx 0;\r\n}\r\n\r\n.topExpress-right-middle {\r\n  font-size: 22rpx;\r\n}\r\n\r\n.topExpress-right-bottom {\r\n  font-size: 20rpx;\r\n  color: #666;\r\n}\r\n\r\n.expressRecord {\r\n  width: 710rpx;\r\n  padding-top: 30rpx;\r\n  padding-bottom: 200rpx;\r\n  background: #fff;\r\n  margin: 0 auto;\r\n  border-radius: 10rpx;\r\n}\r\n\r\n.expressRecord-getAddress {\r\n  width: 100%;\r\n  font-size: 22rpx;\r\n  color: #999;\r\n  display: flex;\r\n}\r\n\r\n.expressRecord-top {\r\n  width: 100%;\r\n  display: flex;\r\n  justify-content: flex-start;\r\n  align-items: center;\r\n}\r\n\r\n.getAddress-icon {\r\n  width: 30rpx;\r\n  height: 30rpx;\r\n  border-radius: 50%;\r\n  background: #999;\r\n  font-size: 18rpx;\r\n  color: #fff;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  margin-left: 80rpx;\r\n}\r\n\r\n.getAddress-text {\r\n  margin-left: 20rpx;\r\n}\r\n\r\n.noReach-online-top-close {\r\n  width: 1rpx;\r\n  height: 50rpx;\r\n  background: #d7d7d7;\r\n  margin-left: 95rpx;\r\n}\r\n\r\n.expressRecord-single-close {\r\n  width: 100%;\r\n  height: 122rpx;\r\n  display: flex;\r\n  justify-content: flex-start;\r\n  align-items: center;\r\n  position: relative;\r\n}\r\n\r\n.expressRecord-single-noReach-online-top-close {\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n.online-top-closing {\r\n  width: 1rpx;\r\n  height: 50rpx;\r\n  background: #d7d7d7;\r\n  margin-left: 95rpx;\r\n}\r\n\r\n.online-top-close {\r\n  width: 1rpx;\r\n  height: 50rpx;\r\n  background: #999;\r\n  margin-left: 95rpx;\r\n}\r\n\r\n.dot-closing {\r\n  width: 10rpx;\r\n  height: 10rpx;\r\n  border-radius: 50%;\r\n  margin-left: 90rpx;\r\n  margin-top: 6rpx;\r\n  margin-bottom: 6rpx;\r\n  background: #fe4f33;\r\n}\r\n\r\n.dot-close {\r\n  width: 10rpx;\r\n  height: 10rpx;\r\n  border-radius: 50%;\r\n  margin-left: 90rpx;\r\n  margin-top: 6rpx;\r\n  margin-bottom: 6rpx;\r\n  background: #999;\r\n}\r\n\r\n.online-bottom {\r\n  width: 1rpx;\r\n  height: 50rpx;\r\n  background: #999;\r\n  margin-left: 95rpx;\r\n}\r\n\r\n.online-bottom-start {\r\n  width: 1rpx;\r\n  height: 50rpx;\r\n  /* background: #999; */\r\n  margin-left: 95rpx;\r\n}\r\n\r\n.expressRecord-text {\r\n  margin-left: 30rpx;\r\n}\r\n\r\n.expressRecord-statusing {\r\n  font-size: 26rpx;\r\n  color: #333;\r\n}\r\n\r\n.expressRecord-status-addressing {\r\n  font-size: 22rpx;\r\n  color: #333;\r\n}\r\n\r\n\r\n.expressRecord-status {\r\n  font-size: 26rpx;\r\n  color: #999;\r\n}\r\n\r\n.expressRecord-status-address {\r\n  font-size: 22rpx;\r\n  color: #999;\r\n}\r\n\r\n.expressRecord-dating {\r\n  position: absolute;\r\n  height: 100%;\r\n  /* top: 0;\r\n  bottom: 0; */\r\n  left: 20rpx;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  flex-direction: column;\r\n  color: #333;\r\n}\r\n\r\n.expressRecord-date {\r\n  position: absolute;\r\n  height: 100%;\r\n  /* top: 0;\r\n  bottom: 0; */\r\n  left: 20rpx;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  flex-direction: column;\r\n  color: #999;\r\n}\r\n\r\n.expressRecord-date-text {\r\n  font-size: 24rpx;\r\n}\r\n\r\n.expressRecord-date-time {\r\n  font-size: 18rpx;\r\n}\r\n\r\n复制代码如果感觉有用的话，点个赞呗，支持一下我哈。"}
{"title": "微信小程序中的ios兼容性问题 ", "author": "Rolan", "pub_time": "2018-11-1 00:32", "content": "1.ios中input的placeholder属性字体不居中对placeholder设置line-height及font-size对input设置高度2.ios中滚动卡顿设置-webkit-overflow-scrolling:touch;3.微信小程序中解决ios中new Date() 时间格式不兼容在实现倒计时，根据后台返回的时间格式转换时，后台返回了时间格式为”2018-11-12 11:12:11”，然后利用new Date() 转换时，ios中无法展示，安卓中显示正常let time = '2018-12-10 11:11:11';\r\nlet temporaryTime1 = new Date(time);\r\nthis.setData({\r\n   timeRemain1: temporaryTime1,\r\n})\r\n/* 利用正则表达式替换时间中的”-”为”/”即可 */\r\nlet time = '2018-12-10 11:11:11';\r\nlet temporaryTime = new Date(time.replace(/-/g,'/'));\r\nlet temporaryTime1 = new Date(time);\r\nthis.setData({\r\n    timeRemain: temporaryTime,\r\n    timeRemain1: temporaryTime1,\r\n })4. 微信小程序scroll-view隐藏滚动条方法在wxss里加入以下代码：::-webkit-scrollbar{\r\nwidth: 0;\r\nheight: 0;\r\ncolor: transparent;\r\n}暂时遇到的兼容性就是这么多，会持续更新，若大家有遇到，可在评论区告知下，感谢正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）往期好文推荐：判断ios和Android及PC端实现文字的省略号纯css实现瀑布流（multi-column多列及flex布局）"}
{"title": "微信小程序Markdown渲染组件wemark ", "author": "Rolan", "pub_time": "2018-11-1 00:42", "content": "wemark可以实现在小程序下渲染Markdown内容，支持图片、表格在内的大部分Markdown特性。特性以小程序自定义组件形式提供，可直接引入使用支持大部分markdown标记的解析、渲染支持代码表格、代码高亮、HTML视频等特性支持使用原生rich-text进行渲染兼容mpvue等开发框架使用1、下载并拷贝wemark目录到小程序根目录2、在页面的配置文件中引用wemark组件{\r\n    \"usingComponents\": {\r\n        \"wemark\": \"../wemark/wemark\"\r\n    }\r\n}\r\n\r\n3、 WXML中使用：<wemark md=\"{{md}}\" link highlight type=\"wemark\"></wemark>\r\n\r\n参数说明：md，必填，需要渲染的Markdown字符串；link，是否解析链接，如果解析，会使用小程序navigator组件展现，可在小程序内跳转，默认为false；highlight，是否对代码进行高亮处理，默认为false；type，渲染方式，wemark会使用wemark的数据结构和模板进行渲染，rich-text会使用小程序内置的rich-text组件进行渲染（不支持链接跳转、视频）。运行效果其他wemark项目地址：https://github.com/TooBug/wemark"}
{"title": "微信小程序仿微信SlideView组件slide-view ", "author": "Rolan", "pub_time": "2018-11-1 00:52", "content": "微信小程序仿微信SlideView组件。使用1、安装 slide-view从小程序基础库版本 2.2.1 或以上、及开发者工具 1.02.1808300 或以上开始，小程序支持使用 npm 安装第三方包。npm install --save miniprogram-slide-view\r\n\r\n2、在需要使用 slide-view 的页面 page.json 中添加 slide-view 自定义组件配置{  \r\n    \"usingComponents\": {    \r\n        \"slide-view\": \"miniprogram-slide-view\"\r\n    }\r\n}\r\n3、WXML 文件中引用 slide-view每一个 slide-view 提供两个<slot>节点，用于承载组件引用时提供的子节点。left 节点用于承载静止时 slide-view 所展示的节点，此节点的宽高应与传入 slide-view 的宽高相同。right 节点用于承载滑动时所展示的节点，其宽度应于传入 slide-view 的 slideWidth 相同。<slide-view class=\"slide\" width=\"320\" height=\"100\" slideWidth=\"200\">\r\n  <view slot=\"left\">这里是插入到组内容</view>\r\n  <view slot=\"right\">\r\n    <view>标为已读</view>\r\n    <view>删除</view>\r\n  </view>\r\n</slide-view>\r\n\r\n参数说明：width：Number类型，默认值显示屏幕的宽度，slide-view组件的宽度height：Number类型，默认值0，slide-view组件的高度slide-width：Number类型，默认值0，滑动展示区域的宽度（默认高度与slide-view相同）运行效果其他slide-view项目地址：https://github.com/wechat-min..."}
{"title": "十几行代码就可以让你的微信小程序挂掉 ", "author": "Rolan", "pub_time": "2018-11-4 23:22", "content": "mpvue （ github 地址请参见 ）是一个使用Vue.js 开发小程序的前端框架。框架基于 Vue.js核心， mpvue 修改了 Vue.js 的runtime 和compiler 实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套 Vue.js 开发体验。由来已久一直以来，我都在用mpvue来编写小程序应用，虽然问题很多，不过都有替代方案。比如在mpvue中，slot（插槽）中的内容不能动态的渲染，那我们可以放弃使用slot内使用动态数据。该问题在github中有多人反应。再比如在mpvue中，自定义指令会直接导致编译报错，那么我们可以放弃使用自定义指令。该问题在github中也有多人反应。但是今天的问题实在太严重，我一定要吐槽一下。bug现象我们在开发过程中，发现在某种情况下，页面UI层的更新时机全部错乱。即 数据变更后，只有在下次的onShow生命周期里有体现（有种“慢一拍”的感觉），整体的感觉就是 页面的展示和交互完全瘫痪 。bug调查我们花了整整一天的时间调查，最后发现问题是 在自定义组件上动态为v-if绑定值赋值上 。将代码精简到十几行就可以复现bug。bug再现记住，这是一个mpvue项目。我在src/pages/目录下新建一个test页面，对应的index.vue文件的代码如下，逻辑很简单，就是利用v-if控制一个组件的显示：<template>\r\n  <test v-if=\"show\"></test>\r\n</template>\r\n<script>\r\nimport test from '@/components/posterTest.vue'\r\nexport default {\r\n  data () {\r\n    return { show: true }\r\n  },\r\n  onShow () {\r\n    this.show = false    //在onShow生命周期里，先将v-if绑定值置位false，2秒再置位true\r\n    setTimeout(() => { this.show = true }, 2000)\r\n  },\r\n  components: { test }\r\n}\r\n</script>复制代码其中引入了posterTest组件。为了调查bug，我将多余的操作处理全部去掉，只有一张图片，它的代码如下：<template lang=\"html\">\r\n  <div class=\"poster\">\r\n    <img src=\"https://interactive-examples.mdn.mozilla.net/media/examples/firefox-logo.svg\" alt=\"\">\r\n  </div>\r\n</template>\r\n<script>\r\nexport default { }\r\n</script>复制代码这个页面只要一加载，2秒后控制台就会报下面的错误。而只要报了这个错误，其他页面也跟着挂了。就像前面提到的一样，结果是灾难性的——页面都挂掉了，双向绑定的更新总像慢了一拍。找到报错的代码，上面还有了一条有意添加的注释（也是vue源码的）所以我怀疑是mpvue在调度上存在问题。解决方法mpvue还是要用的，但是以后不能再用v-if来操作组件的显示了，乖乖用v-show吧。但是话说回来，vue这样的操作可是一点毛病没有的。总结作为框架，作为一个“轮子”，我觉得不应该有这样“后果严重”的bug出现。再退一步说，一个页面的bug能导致到整个应用“瘫痪”，也是很恐怖的。还是要感谢mpvue为我们带来的种种方便。"}
{"title": "微信小程序性能优化方案——让你的小程序如此丝滑 ", "author": "Rolan", "pub_time": "2018-11-4 23:42", "content": "首先，问一个问题，当用户点击小程序后发生了什么？上图中的三个状态，我们经常遇到，它们分别对应小程序的下面三个状态：有三个点的白屏（左侧）： 下载代码包的阶段没有三个点的白屏（中间）： 业务代码注入和渲染的阶段加载中（右边）： 业务代码中异步请求数据总的来说，小程序呈现到用户面前，实际上经历了下面两个阶段：运行环境的加载下载代码包下面具体介绍这两个阶段：运行环境预加载这步是微信做的。微信会在用户打开小程序之前就已经准备好环境，用户点击小程序入口后，直接下载小程序的代码包即可。下载代码包启动小程序小程序代码包里面的代码，不是小程序的源代码，而是编译、压缩、打包之后的代码包。下图中，左侧的“ 预加载 ”对应的是运行环境的预加载，右侧的“小程序启动” 对应的是下载代码包启动小程序。小程序提供的运行环境，分为逻辑层（AppService）和 视图层（webView），逻辑层是执行javascript的地方，视图层是渲染页面的地方。当小程序的代码包下载完毕后，业务代码分别注入逻辑层和渲染层。提升加载性能的最最最关键性一点是，控制包的大小，这个也是微信官方的说法。控制包的大小提升体验最直接的方法是 控制小程序包的大小 ，基本上可以说，1M的代码包，下载耗时1秒左右。控制包的大小的措施压缩代码，清理无用的代码图片放在cdn采用分包策略分包预加载独立分包（版本要求有点高）除了上面讲的控制包的大小，对异步请求的优化也很重要。对异步请求的优化onLoad 阶段就可以发起请求，不用等ready请求结果放在缓存中, 下次接着用请求中可以先展示骨架图先反馈，再请求。比如说，点赞的按钮，可以先改变按钮的样式，再 发起异步请求。提升渲染性能setData 干了啥每调用一次setData, 都是逻辑层向渲染层的一次通讯，这个通信还不是直接传给webView, 而是通过走了native层，通讯的开销很大。渲染层收到通讯后，还需要重新渲染出来，所以，emmm, 一次setData带来两次开销：通信的开销 + webview更新的开销。在数据传输时，逻辑层会执行一次 JSON.stringify 来去除掉 setData 数据中不可传输的部分，之后将数据发送给视图层。同时，逻辑层还会将 setData 所设置的数据字段与 data 合并，使开发者可以用 this.data 读取到变更后的数据。减少setData的数据量如果一个数据不能会影响渲染层，则不用放在setData里面合并setData的请求，减少通讯的次数这个很好理解吧列表的局部更新在一个列表中，有 n 条数据，采用上拉加载更多的方式，假如这个时候想对其中某一个数据进行点赞操作，还能及时看到点赞的效果此时，可以采用setData全局刷新，点赞完成之后，重新获取数据，再次进行全局重新渲染，这样做的优点是：方便，快捷！缺点是：用户体验极其不好，当用户刷量100多条数据后，重新渲染量大会出现空白期（没有渲染过来）如果采用布局刷新，将点赞的 id 传过去，知道点的是那一条数据, 将点赞的 id 传过去，知道点的是那一条数据。重新获取数据，查找相对应id的那条数据的下标（ index 是不会改变的），用setData进行局部刷新this.setData({\r\n    list[index] = newList[index]\r\n})\r\n复制代码小心后台页面的js小程序中可能有n个页面，所有的这些页面，虽然都拥有自己的webview(渲染层)， 但是却共享同一个js运行环境。也就是说，当你跳到了另外一个页面（假设是B页面），本页面（假设是A页面）的定时器等js操作仍在进行，并且不会被销毁，并且会抢占B页面的资源。在h5的环境中，当我们跳转到其他页面，老页面的js环境会被自动销毁，定时器什么都被销毁掉了，因此我们不需要关心老页面中，还有哪些js代码可能还会执行。但是在小程序中，我们必须手动的“清理”掉这样的代码。小心onPageScrollpageScroll 事件，也是一次通讯，是webview层向js逻辑层的通讯。这次通讯也是开销较大，如果考虑到这个事件被频繁的调用，回调函数如果有复杂的setData的话，emmmmm， 性能就会很差了。​小心获取节点位置在h5 中的环境中，为了实现懒加载、下拉加载，我们 不得不 去获取节点的位置。为啥说 不得不 ，是因为我们本可以用新的api ——intersectionObject去轻松实现（google等主流浏览器都已经支持了），但是微信的内置X5浏览器很遗憾的不支持。没想到，在小程序的环境中，微信竟然良心发现，支持intersectionObject api, 因此获取节点的信息，尽量还是用这api 吧。尽可能使用小程序组件自定义组件的更新只在组件内部进行，不受页面其他不能分内容的影响；比如一些运营活动的定时模块可以单独抽出来，做成一个定时组件，定时组件的更新并不会影响页面上其他元素的更新；各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、setData调用优化心得相比于上面的优化策略，最重要的是找出小程序中的性能瓶颈。在自己的优化实践中，遇到了下面的问题：下拉加载更多，特别特别卡，通过列表局部更新的技巧，发现性能改善不大。 后来发现，是因为首页需要监听scroll事件，导致scroll事件被频繁的触发，回调函数中有耗时操作，导致onreachBottom事件被阻塞了，也就是说，要等大概1~2秒才会去发起下一页的请求。 取消掉scroll事件的监听，原本>4s的加载时间，控制在1s之内。"}
{"title": "微信小程序里自动获得当前手机所在的经纬度并转换成地址 ", "author": "Rolan", "pub_time": "2018-11-4 23:50", "content": "效果：我在手机上打开微信小程序，自动显示出我当前所在的地理位置：具体步骤：1. 使用微信jssdk提供的getLocation API拿到经纬度；2. 调用高德地图的api使用经纬度去换取地址的文字描述。\r\nwx.ready(() => {\r\n\r\nwx.getLocation({\r\n\r\ntype: \"gcj02\",\r\n\r\nsuccess: function(res) {\r\n\r\nvar location =\r\n\r\n\"&location=\" + res.longitude + \",\" + res.latitude;\r\n\r\nReservationService.getGeocode(location).then(response => {\r\n\r\nif (\r\n\r\nresponse.data.status === \"1\" &&\r\n\r\nresponse.data.info === \"OK\"\r\n\r\n) {\r\n\r\nself.country =\r\n\r\nresponse.data.regeocode.addressComponent.country;\r\n\r\nself.city = response.data.regeocode.addressComponent.city;\r\n\r\nvar express =\r\n\r\n\"/\" +\r\n\r\nself.country +\r\n\r\n\"|\" +\r\n\r\nresponse.data.regeocode.addressComponent.province +\r\n\r\n\"|\" +\r\n\r\nself.city +\r\n\r\n\"|\" +\r\n\r\nresponse.data.regeocode.addressComponent.district +\r\n\r\n\"|\" +\r\n\r\nresponse.data.regeocode.addressComponent.township +\r\n\r\n\"/g\";\r\n\r\nself.address = response.data.regeocode.formatted_address.replace(\r\n\r\neval(express),\r\n\r\n\"\"\r\n\r\n);\r\n\r\n} else {\r\n\r\n// get location error, plz input address\r\n\r\nalert(\"无法获取地址信息,请稍后再试\");\r\n\r\n}\r\n\r\n});\r\n\r\n}\r\n\r\n});\r\nReservationService.getGeocode的实现：getGeocode(location) {const key = '此处填入您高德地图app的key';return axios.post('https://restapi.amap.com/v3/g...' + key + location);}看下面一个使用高德地图API将经纬度转换成文字描述的地址的例子，使用postman发送请求：API响应：\r\n{\r\n\r\n\"status\": \"1\",\r\n\r\n\"regeocode\": {\r\n\r\n\"addressComponent\": {\r\n\r\n\"city\": [],\r\n\r\n\"province\": \"北京市\",\r\n\r\n\"adcode\": \"110101\",\r\n\r\n\"district\": \"东城区\",\r\n\r\n\"towncode\": \"110101001000\",\r\n\r\n\"streetNumber\": {\r\n\r\n\"number\": \"44号\",\r\n\r\n\"location\": \"116.39795,39.9097239\",\r\n\r\n\"direction\": \"东北\",\r\n\r\n\"distance\": \"117.874\",\r\n\r\n\"street\": \"广场东侧路\"\r\n\r\n},\r\n\r\n\"country\": \"中国\",\r\n\r\n\"township\": \"东华门街道\",\r\n\r\n\"businessAreas\": [\r\n\r\n{\r\n\r\n\"location\": \"116.3998109423077,39.90717459615385\",\r\n\r\n\"name\": \"天安门\",\r\n\r\n\"id\": \"110101\"\r\n\r\n},\r\n\r\n{\r\n\r\n\"location\": \"116.39981058278138,39.92383706953642\",\r\n\r\n\"name\": \"景山\",\r\n\r\n\"id\": \"110101\"\r\n\r\n},\r\n\r\n{\r\n\r\n\"location\": \"116.4118112683418,39.91461494422115\",\r\n\r\n\"name\": \"王府井\",\r\n\r\n\"id\": \"110101\"\r\n\r\n}\r\n\r\n],\r\n\r\n\"building\": {\r\n\r\n\"name\": \"天安门\",\r\n\r\n\"type\": \"风景名胜;风景名胜相关;旅游景点\"\r\n\r\n},\r\n\r\n\"neighborhood\": {\r\n\r\n\"name\": [],\r\n\r\n\"type\": []\r\n\r\n},\r\n\r\n\"citycode\": \"010\"\r\n\r\n},\r\n\r\n\"formatted_address\": \"北京市东城区东华门街道天安门\"\r\n\r\n},\r\n\r\n\"info\": \"OK\",\r\n\r\n\"infocode\": \"10000\"\r\n\r\n}\r\n要获取更多Jerry的原创文章，请关注公众号\"汪子熙\""}
{"title": "mpvue小程序开发 - 生命周期梳理 ", "author": "Rolan", "pub_time": "2018-11-6 00:16", "content": "最近在开发小程序，尝试性地使用了一下mpvue框架。mpvue 是一个使用 Vue.js 开发小程序的前端框架。框架基于 Vue.js 核心，mpvue 修改了 Vue.js 的 runtime 和 compiler 实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套 Vue.js 开发体验。mpvue同时维护了Vue和小程序的两套机制，因此需要对两套机制进行关联。这里主要对mpvue的生命周期来进行一些梳理。微信小程序生命周期首先我们需要了解，微信小程序的生命周期：App对象，主要有onLaunch, onShow和onHide。Page对象，主要有onLoad, onShow, onReady, onHide和onUnload。Vue到mpvuempvue的出现使得我们可以用书写Vue实例的方式去声明这两种对象，并使得Vue实例兼容小程序的生命周期。Vue的生命周期主要体现在8个钩子：beforeCreate, created, beforeMount, mounted, beforeUpdate, updated, beforeDestroy, destroyed。来对比一下Vue和mpvue的生命周期，看一下mpvue做出了什么改变：对比来看，mpvue主要是对created和beforeMount之间的过程做了改变。在Vue中，这个阶段主要作用是将template编译为render函数：而在mpvue中，对于App或Page组件（这里的Is App or Page component应该要解释为“是否为App或Page组件”），为他们初始化小程序的生命周期，并注册App对象或Page对象：这里可以看出来，mpvue中，Vue和小程序生命周期钩子触发的基本顺序是beforeCreate -> created -> onLaunch/onLoad -> onShow -> onReady -> beforeMount -> mounted -> ...实践验证这里有一个入口页面，包含一个通过wx.navigateTo跳转到newPage的按钮。newPage中包含一个card组件，和一个通过wx.navigateBack跳转回入口页面的按钮。在App, newPage和card的各个生命周期钩子输出信息，来观察它们的触发情况和顺序。在App被创建，跳转到newPage前我们可以观察到，app对象首先被创建，触发onLaunch和onShow。在这之后，newPage被create。需要注意的是，此时我们还没有跳转到newPage，也就是说在mpvue中，无论页面是否被访问到，其Vue实例的beforeCreate和created都在app创建后就被触发。第一次跳转到newPage并返回入口页面由于newPage页面的beforeCreate和created已经提前被触发过了，在调用了wx.NavigateTo跳转到newPage时，先触发小程序的生命周期，再触发beforeMount，这时候开始创建子组件card的实例，按照beforeCreate -> created -> onLoad -> onReady -> beforeMount -> mounted 的顺序触发生命周期钩子。（这里组件的onShow为什么没有触发..需要再深入探究一下）在wx.navigateBack时，小程序的生命周期钩子onUnload被触发。但需要注意的是：Vue的生命周期钩子beforeDestroy和destroyed并没有被触发，也就是说小程序中newPage的page对象被卸载了，但newPage和card的Vue实例并没有被销毁。第二次跳转到newPage并返回入口页面newPage和card都已经被create且没有destroy，在再次wx.navigateTo时将直接从onLoad -> onShow -> onReady开始触发，newPage的mount和update过程也会出发，而component之后update过程被触发了。这里可以发现，在onLoad之后还经过了几个阶段，才开始触发Vue实例的生命周期钩子，而上一次保存在内存中的数据并没有被destroy，因此在重新加载的过程中，Vue实例还保存着上一次加载页面时的数据。开发时遇到的问题遇到的问题主要是由create过程在页面加载前就被统一触发引起的。 在使用Vue时，经常在created钩子中获得新的data。因为此时对data的数据观测已经被建立，但是页面内容尚未被挂载，Vue实例可以观测到data的变化并在视图显示出来之前改变其内容。如果在mpvue中，我们想获取页面路由query中的数据，或是想在页面创建时请求接口，我们可能会这样考虑：在created中获取数据？ 在mpvue中，created只被触发一次，且在页面创建前被触发，也就是说query中的数据是无法获得的，再次访问页面时如果数据发生了变化，created中的逻辑也并不会再次执行。推迟到beforeMount？ 从功能上说，在beforeMount获取数据是没有问题的。但由于页面unload时没有触发destroy，在再次加载页面时，Vue实例仍然保存着前一次获得的数据，而页面的onLoad、onShow均在beforeMount之前被触发，实践时会发现，页面在数据更新之前就会被显示出来，旧的数据会在页面中“一闪而过”。在onLoad中获取数据？ 实践证明这的确是一种最稳妥的方法，数据能被正确地设置，页面也不会“闪”。 但是官方文档有这样一句话： 除特殊情况外，不建议使用小程序的生命周期钩子。 这里大概是为了代码的移植性做考虑吧，不知道这里算不算特殊情况呢。使用computed？ 为了避免使用小程序的生命周期钩子，还可以考虑使用computed的来获取query中的内容，而query需要在页面onLoad之后才存在，这里需要注意做一些判断。总结从Vue过度到mpvue还是非常平滑的，特别是在有过小程序开发经验的情况下。但是由于小程序本身和浏览器的差异，使得开发过程中会遇到一些难以理解的问题，将生命周期做一下梳理对更顺利地进行开发是有一些好处的。但是，从这里也可以看到，对于开发小程序来说，mpvue实际上额外地维护了一套Vue的机制，并对小程序的事件、数据进行代理、同步，实际上这个过程可能会造成一些性能上的损耗。再加上mpvue目前还是存在一些缺陷，而小程序也支持了数据绑定、组件化开发，个人认为若是追求高质量的开发还是直接使用原生小程序更优吧~"}
{"title": "微信小程序中遇到的多规格问题(一) ", "author": "Rolan", "pub_time": "2018-11-6 00:25", "content": "1.效果图2.文件及部分思路index.wxml文件<view class=\"multipleStandard\" bindtap=\"standardSelect\">\r\n  <view class=\"standard\">\r\n    规格:\r\n    <text class=\"item\">颜色</text>    \r\n    <text class=\"item\">颜色</text>    \r\n    <text class=\"item\">颜色</text>    \r\n  </view>\r\n  <image src=\"/images/arrows.png\" class=\"arrows\"></image>\r\n</view>\r\n<view style=\"background:rgb(207, 224, 232); height: 300rpx;margin-top: 50rpx;\"></view>\r\n<view animation=\"{{animationData}}\" class=\"selectStandard\" catchtouchmove=\"noMove\">\r\n  <view class=\"tophead\">\r\n    <view class=\"topimg\">\r\n      <image src=\"{{goods.original_img}}\"></image>\r\n    </view>\r\n    <view class=\"topright\">\r\n      <view class=\"selectClose\">\r\n        <view style=\"color:#ef5426;\">{{standardObject.price}}</view>\r\n        <image src=\"/images/close.png\" bindtap=\"handleClose\"></image>\r\n      </view>\r\n      <view style=\"margin:10rpx 0;color:#999999;\">库存:{{standardObject.store_count}}</view>\r\n      <view>规格: {{mergeStandard}}</view>\r\n    </view>\r\n  </view>\r\n  <view class=\"standard\" wx:for=\"{{commodityStandard}}\" wx:key=\"{{standardIndex}}\" wx:for-index=\"standardIndex\">\r\n    <view class=\"standardTitle\">{{item[0].spec_name}}</view>\r\n    <view class=\"standardItem\">\r\n      <block wx:for=\"{{item}}\" wx:key=\"{{item.item_id}}\">\r\n        <view class=\"selectItem {{isSelect[item.isClick]}}\" bindtap=\"handleStandardClick\" data-standard-index=\"{{standardIndex}}\" data-index=\"{{index}}\" data-id=\"{{item.item_id}}\">{{item.item}}</view>        \r\n      </block>\r\n    </view>\r\n    <view style=\"height:1px; width:100%;background-color:#eeeeee;\"></view>\r\n  </view>\r\n  <view class=\"selectCount\">\r\n    <view class=\"countname\">数量</view>\r\n    <view class=\"countright\">\r\n      <i-input-number value=\"{{commodityNum}}\" min=\"1\" max=\"{{store_count}}\" bindchange=\"handleCommodityNumber\" />\r\n    </view>\r\n  </view>\r\n  <view class=\"submitBtn\" bindtap=\"submitSelected\">\r\n    确定\r\n  </view>\r\n</view>\r\n<i-message id=\"message\" />index.wxss文件.multipleStandard{\r\n  display: flex;\r\n  margin-top: 20rpx;\r\n  padding: 15rpx 20rpx;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n  box-shadow: 0 0 10px #ccc;\r\n}\r\n.item{\r\n  margin-right: 15rpx;\r\n}\r\n.arrows{\r\n  width: 16rpx;\r\n  height: 27rpx;\r\n}\r\n\r\n/* 规格弹窗 */\r\n.selectStandard {\r\n  width: 100%;\r\n  height: 1000rpx;\r\n  background-color: #fff;\r\n  position: fixed;\r\n  z-index: 333;\r\n  bottom: -600px;\r\n  border-top-left-radius: 20rpx;\r\n  border-top-right-radius: 20rpx;\r\n}\r\n\r\n/* 头部选中的规格 */\r\n.tophead {\r\n  display: flex;\r\n  margin: 30rpx 3%;\r\n  width: 94%;\r\n  align-items: center;\r\n  text-align: center;\r\n}\r\n\r\n.topimg {\r\n  width: 200rpx;\r\n  height: 200rpx;\r\n}\r\n\r\n.topimg image {\r\n  width: 100%;\r\n  height: 100%;\r\n  border-radius: 20rpx;\r\n  background-color: red;\r\n}\r\n\r\n.topright {\r\n  margin-left: 30rpx;\r\n  font-size: 28rpx;\r\n  text-align: left;\r\n  width: 66%;\r\n}\r\n/* 关闭按钮 */\r\n.selectClose {\r\n  display: flex;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n}\r\n\r\n.selectClose image {\r\n  width: 30rpx;\r\n  height: 30rpx;\r\n}\r\n\r\n.standard {\r\n  margin: 0 3%;\r\n  width: 94%;\r\n  font-size: 28rpx;\r\n}\r\n\r\n.standardTitle {\r\n  font-size: 30rpx;\r\n  margin-top: 20rpx;\r\n}\r\n.standardItem {\r\n  display: flex;\r\n  flex-wrap: wrap;\r\n    width: 100%;\r\n}\r\n.selectItem {\r\n  border: solid 1px #666;\r\n  margin: 20rpx;\r\n  padding: 5rpx 23rpx;\r\n  border-radius: 16rpx;\r\n}\r\n/* 规格选中时样式 */\r\n.standardSelected{\r\n  color: #fff;\r\n  background: #f26740;\r\n    background-color:#fe6732;\r\n    border:solid 1px #fe6732;\r\n    margin:20rpx;\r\n    padding:5rpx 23rpx;\r\n    border-radius:16rpx;\r\n}\r\n.standardNormal{\r\n  color: #000;\r\n}\r\n.standardDisable{\r\n  color: #eee;\r\n}\r\n\r\n/* 选择的数量 */\r\n.selectCount {\r\n  margin: 30rpx 3%;\r\n  width: 94%;\r\n  font-size: 28rpx;\r\n}\r\n.countright {\r\n  float: right;\r\n  display: flex;\r\n  text-align: center;\r\n  align-items: center;\r\n}\r\n\r\n.countname {\r\n  margin-bottom: 20rpx;\r\n  font-size: 30rpx;\r\n}\r\n\r\n.submitBtn {\r\n  position: absolute;\r\n  bottom: 0;\r\n  width: 70%;\r\n  margin: 0 15% 20rpx 15%;\r\n  text-align: center;\r\n  z-index: 66;\r\n  height: 80rpx;\r\n  background-color: #fe6732;\r\n  border-radius: 40rpx;\r\n  color: white;\r\n  font-size: 32rpx;\r\n  line-height: 80rpx;\r\n}index.js文件const {\r\n    $Message\r\n} = require('../../component/iview/base/index');\r\nPage({\r\n  data: {\r\n    animationData: {},\r\n    isSelect: [\"standardNormal\", \"standardSelected\", \"standardDisable\"],  /* 用于区别当前的规格是否选中 */\r\n    goods: {\r\n      goods_name: \"男鞋\",\r\n      store_count: 158,\r\n      cost_price: \"10.00\",\r\n      original_img: \"/images/commodity.jpg\",     \r\n    },\r\n    commodityStandard: [\r\n      [\r\n        {\r\n          spec_name: \"颜色\",\r\n          item_id: 535385,\r\n          item: \"白色\",\r\n          src: \"\",\r\n          isClick: 0\r\n        },\r\n        {\r\n          spec_name: \"颜色\",\r\n          item_id: 535386,\r\n          item: \"黑色\",\r\n          src: \"\",\r\n          isClick: 0\r\n        }\r\n      ],\r\n      [\r\n        {\r\n          spec_name: \"尺寸\",\r\n          item_id: 535692,\r\n          item: \"170\",\r\n          src: \"\",\r\n          isClick: 0\r\n        },\r\n        {\r\n          spec_name: \"尺寸\",\r\n          item_id: 535693,\r\n          item: \"180\",\r\n          src: \"\",\r\n          isClick: 0\r\n        }\r\n      ],\r\n      [\r\n        {\r\n          spec_name: \"重量\",\r\n          item_id: 552569,\r\n          item: \"11\",\r\n          src: \"\",\r\n          isClick: 0\r\n        },\r\n        {\r\n          spec_name: \"重量\",\r\n          item_id: 552570,\r\n          item: \"15\",\r\n          src: \"\",\r\n          isClick: 0\r\n        }\r\n      ]\r\n    ],\r\n    standardInfo: [\r\n      {\r\n        id: 1018269,\r\n        key: \"535385_535692_552569\",\r\n        price: \"10.00\",\r\n        productprice: \"0.00\",\r\n        store_count: 20\r\n      },\r\n      {\r\n        id: 1018270,\r\n        key: \"535385_535692_552570\",\r\n        price: \"20.00\",\r\n        productprice: \"0.00\",\r\n        store_count: 20\r\n      },\r\n      {\r\n        id: 1018271,\r\n        key: \"535385_535693_552569\",\r\n        price: \"30.00\",\r\n        productprice: \"0.00\",\r\n        store_count: 20\r\n      },\r\n      {\r\n        id: 1018272,\r\n        key: \"535385_535693_552570\",\r\n        price: \"40.00\",\r\n        productprice: \"0.00\",\r\n        store_count: 20\r\n      },\r\n      {\r\n        id: 1018273,\r\n        key: \"535386_535692_552569\",\r\n        price: \"50.00\",\r\n        productprice: \"0.00\",\r\n        store_count: 20\r\n      },\r\n      {\r\n        id: 1018274,\r\n        key: \"535386_535692_552570\",\r\n        price: \"60.00\",\r\n        productprice: \"0.00\",\r\n        store_count: 20\r\n      },\r\n      {\r\n        id: 1018275,\r\n        key: \"535386_535693_552569\",\r\n        price: \"70.00\",\r\n        productprice: \"0.00\",\r\n        store_count: 20\r\n      },\r\n      {\r\n        id: 1018276,\r\n        key: \"535386_535693_552570\",\r\n        price: \"80.00\",\r\n        productprice: \"0.00\",\r\n        store_count: 18\r\n      }\r\n    ],\r\n    selectedId: [],\r\n    selectedStandard: [],\r\n    standardObject: {},\r\n    commodityNum: 1,\r\n  },\r\n  onLoad: function (options) {\r\n    let goods = this.data.goods;\r\n    let standardObject = this.data.standardObject;\r\n    standardObject.price = goods.cost_price;\r\n    standardObject.store_count = goods.store_count;\r\n        let store_count = goods.store_count;\r\n    this.setData({\r\n      standardObject,\r\n            store_count\r\n    })\r\n  },\r\n  /* 规格选择 */\r\n  standardSelect() {\r\n    var that = this\r\n    var animal1 = wx.createAnimation({\r\n      timingFunction: 'ease-in'\r\n    }).translate(0, -600).step({\r\n      duration: 300\r\n    })\r\n    that.setData({\r\n      animationData: animal1.export(),\r\n    })\r\n  },\r\n  /* 关闭规格选择 */\r\n  handleClose() {\r\n    var that = this\r\n    var animal1 = wx.createAnimation({\r\n      timingFunction: 'ease-in'\r\n    }).translate(0, 600).step({\r\n      duration: 300\r\n    })\r\n    that.setData({\r\n      animationData: animal1.export()\r\n    })\r\n  },\r\n  /* 每个规格的点击事件 */\r\n  handleStandardClick(e) {\r\n    let id = e.currentTarget.dataset.id;\r\n    // 总规格名称索引\r\n    let standardIndex = e.currentTarget.dataset.standardIndex;\r\n    // 单个规格名称索引\r\n    let index = e.currentTarget.dataset.index;\r\n    let commodityStandard = this.data.commodityStandard;\r\n    let standardLength = commodityStandard[standardIndex].length;\r\n\r\n    // 用于存储规格的id\r\n    let selectedId = this.data.selectedId;\r\n    // 用总规格名称索引来存储每个选中的规格id\r\n    selectedId[standardIndex] = id;\r\n\r\n    let selectedStandard = this.data.selectedStandard;\r\n\r\n    // 在点击的时候，只需要对点击的这个规格所在的数组进行循环\r\n    for (let i = 0; i < standardLength; i++) {\r\n      // 找到对应的单个规格索引，并设置isClick及单个规格名称\r\n      if (index == i) {\r\n        commodityStandard[standardIndex][index].isClick = 1;\r\n        selectedStandard[standardIndex] = commodityStandard[standardIndex][index].item;\r\n      } else {\r\n        commodityStandard[standardIndex][i].isClick = 0;\r\n      }\r\n    }\r\n\r\n    // 将id用_连接起来\r\n    let mergeId = selectedId.join('_');\r\n    console.log(mergeId);\r\n    let mergeStandard = selectedStandard.join('  ');\r\n    console.log(mergeStandard);\r\n\r\n    let standardInfo = this.data.standardInfo;\r\n    let standardInfoLength = standardInfo.length;\r\n    // 用于存储选中的规格\r\n    let standardObject = {};\r\n\r\n    for (let i = 0; i < standardInfoLength; i++) {\r\n      if (standardInfo[i].key == mergeId) {\r\n        standardObject = standardInfo[i];\r\n        break;\r\n      } else {\r\n        standardObject = this.data.standardObject;\r\n      }\r\n    }\r\n\r\n    this.setData({\r\n      currentId: id,\r\n      commodityStandard,\r\n      selectedId,\r\n      standardObject,\r\n      mergeStandard,\r\n      selectedStandard,\r\n    })\r\n\r\n  },\r\n  /* 选择数量 */\r\n  handleCommodityNumber(e) {\r\n      let commodityNum = e.detail.value;\r\n      if (commodityNum >= this.data.store_count) {\r\n          commodityNum = this.data.store_count;\r\n      }\r\n      this.setData({\r\n          commodityNum\r\n      })\r\n  },\r\n  /* 保存选择的规格 */\r\n  submitSelected() {\r\n      let selectedStandard = this.data.selectedStandard;\r\n      let length = selectedStandard.length;\r\n      console.log(length)\r\n      if (length == 0) {\r\n          $Message({\r\n              content: '请选择规格',\r\n              type: 'error'\r\n          });\r\n          return false;\r\n      }\r\n      for (let i = 0; i < length; i++) {\r\n          if (length < this.data.commodityStandard.length) {\r\n              $Message({\r\n                  content: '请选择规格',\r\n                  type: 'error'\r\n              });\r\n              break;\r\n          }\r\n          if (selectedStandard[i] == undefined) {\r\n              $Message({\r\n                  content: '请选择规格',\r\n                  type: 'error'\r\n              });\r\n              break;\r\n          }\r\n      }\r\n      $Message({\r\n          content: '选择成功',\r\n          type: 'success'\r\n      });\r\n  },\r\n})我这里提示信息使用了插件iview，可以在官网直接下载后使用iview weapp3.部分思路及改进方法开始想到的是将需合并的id的位置写死，比如，第一个位置就传第一个规格里选中的规格id，第二个位置就传第二个规格里选中的规格id,不过此时有问题，就是后台的id拼接是根据当前规格长度来拼接的，从最短的开始往长的拼接，然后，长度相等的时候，我这边的话，后台是从第一个开始拼接的，而且你选规格时，也可能是随机点的，此时若是采用第一种位置写死的方法就会有问题，因为会找不到对应的合并后的规格id因为我这里一开始用的数据就刚好满足我的设想，但是后面换了个数据后就出现问题了index.wxml文件也做部分修改,可以直接查找下，类名为standardItem<view class=\"standardItem\">\r\n  <block wx:for=\"{{item}}\" wx:key=\"{{item.item_id}}\">\r\n    <view class=\"selectItem {{item.item_id == Specifications[standardIndex]?'standardSelected':'standardNormal'}}\" bindtap=\"handleStandardClick\" data-standard-index=\"{{standardIndex}}\" data-name=\"{{item.item}}\" data-id=\"{{item.item_id}}\">{{item.item}}</view>        \r\n  </block>\r\n</view>*增加另一种模拟数据goods: {\r\n  goods_name: \"男鞋\",\r\n  store_count: 95,\r\n  market_price: \"10.00\",\r\n  shop_price: \"101.00\",\r\n  cost_price: \"10.00\",\r\n  original_img: \"/images/commodity.jpg\",\r\n  store_id: 170,\r\n},\r\ncommodityStandard: [\r\n  [\r\n    {\r\n      spec_name: \"颜色\",\r\n      item_id: 532825,\r\n      item: \"白色\",\r\n      src: \"\",\r\n      isClick: 0\r\n    },\r\n    {\r\n      spec_name: \"颜色\",\r\n      item_id: 532826,\r\n      item: \"黑色\",\r\n      src: \"\",\r\n      isClick: 0\r\n    },\r\n    {\r\n      spec_name: \"颜色\",\r\n      item_id: 532827,\r\n      item: \"红色\",\r\n      src: \"\",\r\n      isClick: 0\r\n    }\r\n  ],\r\n  [\r\n    {\r\n      spec_name: \"大小\",\r\n      item_id: 532828,\r\n      item: \"160\",\r\n      src: \"\",\r\n      isClick: 0\r\n    },\r\n    {\r\n      spec_name: \"大小\",\r\n      item_id: 532829,\r\n      item: \"150\",\r\n      src: \"\",\r\n      isClick: 0\r\n    }\r\n  ],\r\n  [\r\n    {\r\n      spec_name: \"重量\",\r\n      item_id: 552581,\r\n      item: \"10\",\r\n      src: \"\",\r\n      isClick: 0\r\n    }\r\n  ]\r\n],\r\n/* 这里合并规格的信息 */\r\nspec_goods_price: [\r\n  {\r\n    id: 1018286,\r\n    key: \"552581_532828_532825\",\r\n    price: \"10.00\",\r\n    productprice: \"0.00\",\r\n    store_count: 9\r\n  },\r\n  {\r\n    id: 1018287,\r\n    key: \"552581_532828_532826\",\r\n    price: \"20.00\",\r\n    productprice: \"0.00\",\r\n    store_count: 10\r\n  },\r\n  {\r\n    id: 1018288,\r\n    key: \"552581_532828_532827\",\r\n    price: \"30.00\",\r\n    productprice: \"0.00\",\r\n    store_count: 10\r\n  },\r\n  {\r\n    id: 1018289,\r\n    key: \"552581_532829_532825\",\r\n    price: \"40.00\",\r\n    productprice: \"0.00\",\r\n    store_count: 10\r\n  },\r\n  {\r\n    id: 1018290,\r\n    key: \"552581_532829_532826\",\r\n    price: \"50.00\",\r\n    productprice: \"0.00\",\r\n    store_count: 7\r\n  },\r\n  {\r\n    id: 1018291,\r\n    key: \"552581_532829_532827\",\r\n    price: \"60.00\",\r\n    productprice: \"0.00\",\r\n    store_count: 10\r\n  }\r\n],index.js文件onLoad: function (options) {\r\n    let goods = this.data.goods;\r\n    /* 用于存储对应的价格及库存 */\r\n    let standardObject = this.data.standardObject;\r\n    standardObject.price = goods.cost_price;\r\n    standardObject.store_count = goods.store_count;\r\n    \r\n    let spec_goods_price =this.data.spec_goods_price;\r\n    if (spec_goods_price) {\r\n      this.checkPrice(spec_goods_price);\r\n    }\r\n    this.setData({\r\n      standardObject,\r\n    })\r\n},\r\nhandleStandardClick: function (e) {\r\n    // 总规格名称索引\r\n    let standardIndex = e.currentTarget.dataset.standardIndex;\r\n    let id = e.currentTarget.dataset.id;\r\n    /* 存储选中的规格名称 */\r\n    let name = e.currentTarget.dataset.name;\r\n    let selectedStandard = this.data.selectedStandard;\r\n    selectedStandard[standardIndex] = name;\r\n    let mergeStandard = selectedStandard.join('  ');\r\n    let Specifications = this.data.Specifications;\r\n    Specifications[standardIndex] = id;\r\n    console.log(mergeStandard)\r\n    this.setData({\r\n      Specifications,\r\n      mergeStandard,\r\n      selectedStandard,\r\n    })\r\n    this.checkPrice(this.data.spec_goods_price);\r\n},\r\n/*在还未选择完规格时，暂时选用第一个合并后的规格价格及库存*/\r\ncheckPrice: function (spec_goods_price) {\r\n    let standardObject = this.data.standardObject;\r\n    if (!this.checkSpecifications(spec_goods_price)) {\r\n      standardObject.price = spec_goods_price[0].price;\r\n      standardObject.store_count = spec_goods_price[0].store_count;\r\n      this.setData({\r\n        standardObject,\r\n      })\r\n    }\r\n},\r\n/* 保存及校验是否选好了规格 */\r\nsubmitSelected: function (e) {\r\n    let spec_goods_price = this.data.spec_goods_price;\r\n    let i = 0;\r\n    let optionid = \"\";\r\n    if (spec_goods_price) {\r\n        optionid = this.checkSpecifications();\r\n        if (optionid) {\r\n            $Message({\r\n              content: '选择成功',\r\n              type: 'success'\r\n            });\r\n        } else {\r\n            $Message({\r\n              content: '请选择规格',\r\n              type: 'error'\r\n            });\r\n        }\r\n    }\r\n},\r\ncheckSpecifications(spec_goods) {\r\n    let spec_goods_price = spec_goods || this.data.spec_goods_price;\r\n    let Specifications = this.data.Specifications;\r\n    let SpecificationsLength = spec_goods_price[0].key.split(\"_\").length;\r\n    let standardObject = this.data.standardObject;\r\n    if (Specifications.length != SpecificationsLength) {\r\n      return false;\r\n    } else {\r\n      for (let i = 0; i < spec_goods_price.length; i++) {\r\n        /* 若selectSpecifications全为true，则选中了对应的合并后的规格 */\r\n        let selectSpecifications = true;\r\n        for (let j = 0; j < Specifications.length; j++) {\r\n          if (spec_goods_price[i].key.indexOf(Specifications[j]) == -1) {\r\n            selectSpecifications = false;\r\n            break;\r\n          }\r\n        }\r\n        if (selectSpecifications) {\r\n          standardObject.price = spec_goods_price[i].price;\r\n          standardObject.store_count = spec_goods_price[i].store_count;\r\n          this.setData({\r\n            standardObject,\r\n          })\r\n          return spec_goods_price[i].id;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n},利用indexOf来判断合并后的key值，就不用通过写死位置存储规格，然后这里用了动画，可以自己查看官方完档微信创建动画这里的规格啥的，格式可能会是多样的，我这里的话，就是返回这样的格式，其实我还想实现就是根据库存来判断是否可以点击，比如选尺码28，然后可能颜色为黑色的就库存不足，此时，是不能让他点击的，日后会在做下这个功能，欢迎大家在评论区指正，共同进步^_^正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）"}
{"title": "微信小程序http连接访问解决方案 ", "author": "Rolan", "pub_time": "2018-11-6 00:32", "content": "HTTP + 加密 + 认证 + 完整性保护 = HTTPS，小程序考虑到信息安全的问题，选用了更为稳定安全的https 来进行信息传递。HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。这就导致了许多好用的http  API无法在小程序中被调用。但是也有解决方案。1.中继访问 中继访问有两种方式，一种需要自己拥有一个云服务和域名。拥有域名和云服务器域名完成备案之后下载证书https指引教程如下------> 腾讯云上免费部署HTTPS再讲域名解析到你的云服务器的IP。这样子你的域名就是https的了，小程序可以访问你的服务器了，现在就开始在云服务上实现访问http API 服务实际上只需要面向小程序和API Server 做一个双面响应即可。实现这种功能，显而易见，在服务器上部署一个Web项目是最简单的实现方式：我们以访问豆瓣图书API 为例：https://api.douban.com/v2/book/isbn/豆瓣API虽然是https的，但是来自小程序的访问是被禁止的。下面代码同样适用于http 连接Java代码：这个是通用代码，无论是访问什么APIpackage DataService;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.net.HttpURLConnection;import java.net.URL;import java.net.URLConnection;import java.sql.ResultSet;import com.google.gson.Gson;/* * Author:陈浩东 * QQ:1025584691 */public class DouBanBook {    //豆瓣接口实现    public static String doPost(String url, String params, Integer connTimeout, Integer readTimeout, String contentType)    {        PrintWriter out = null;        BufferedReader in = null;        String result = \"\";        try        {            URL realUrl = new URL(url);            // 打开和URL之间的连接,根据url            URLConnection conn = realUrl.openConnection();            // 设置通用的请求属性            conn.setRequestProperty(\"accept\", \"*/*\");            conn.setRequestProperty(\"connection\", \"Keep-Alive\");            conn.setRequestProperty(\"user-agent\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)\");            conn.setRequestProperty(\"Content-Type\", contentType == null? \"application/json\" : contentType);            // 发送POST请求必须设置如下两行            conn.setDoOutput(true);            conn.setDoInput(true);            // 设置请求超时时间和读取超时时间            conn.setConnectTimeout(connTimeout == null ? 180 : connTimeout);            conn.setReadTimeout(readTimeout == null ? 180 : readTimeout);            // 获取URLConnection对象对应的输出流，设置utf-8编码            out = new PrintWriter(new OutputStreamWriter(conn.getOutputStream(), \"utf-8\"));            // 发送请求参数            out.print(params);            // flush输出流的缓冲            out.flush();            // 定义BufferedReader输入流来读取URL的响应,设置utf-8编码            in = new BufferedReader(new InputStreamReader(conn.getInputStream(), \"utf-8\"));            String line;            while ((line = in.readLine()) != null)                result += line;        }        catch (Exception e)        {            e.printStackTrace();            result = null;        }        //使用finally块来关闭输出流、输入流        finally        {            try            {                if (out != null)                {                    out.close();                }                if (in != null)                {                    in.close();                }            }            catch (IOException ex)            {                ex.printStackTrace();            }        }        return result;    }}根据访问不同的API，只需要修改Servlet的写法就可以：Servlet：package Servlet;import java.io.IOException;import java.io.Writer;import java.util.HashMap;import java.util.Map;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.google.gson.Gson;import DataService.DouBanBook;/** * Servlet implementation class doubanbook */@WebServlet(\"/doubanbook\")public class doubanbook extends HttpServlet {    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {         request.setCharacterEncoding(\"utf-8\");            response.setContentType(\"text/html;charset=utf-8\");            response.setHeader(\"Access-Control-Allow-Origin\", \"*\");            response.setHeader(\"Access-Control-Allow-Methods\", \"GET,POST\");            String isbn = request.getParameter(\"isbn\")==null?\"no\":request.getParameter(\"isbn\");            String sshpwd = request.getParameter(\"ssh_secret\")==null?\"no\":request.getParameter(\"ssh_secret\");            System.out.println(sshpwd);            System.out.println(isbn);            Map<String, Object> result = new HashMap<String, Object>();            String json = new Gson().toJson(result);            Writer out = response.getWriter();            out.write(DouBanBook.doPost(\"https://api.douban.com/v2/book/isbn/\"+isbn, null, null, null, null));            out.flush();    }    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        // TODO Auto-generated method stub        doGet(request, response);    }}同样，你也可以用Python，php等语言来实现中继访问这个功能。无域名和云服务器对于个人开发者来说，尤其是学生来说，又是是没有条件购买长时间的云服务器的，这个时候我们如果是开发小程序的话，可以用他们提供的空间。使用微信小程序的云开发能力，Node.js 函数，用js 实现服务端的响应，访问非https API。参照写法一：云函数调用方式访问API　　 不知道什么原因，云函数我感觉并不是很稳定，建议有条件的还是用自己的服务器来实现吧。"}
{"title": "A计划小程序的血与泪 ", "author": "Rolan", "pub_time": "2018-11-8 00:21", "content": "A计划只是一个代号，不代表任何小程序微信小程序，简称小程序，英文名Mini Program，是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用。最近两周由于公司业务需求，本胖主导开发了一款功能简单的小程序—A计划（以下本次开发小程序的代号），可以说这两周本胖都是在浏览小程序官网以及小程序论坛，适应小程序的开发模式以及填开发过程中的大坑小。这里需要说一句，自己平时做demo和开发公司级别的正式项目永远都是两码事哈，本胖这次也是深有体会，很多之前做demo时候只是模棱两可的知识在这次开发中得到了深入认识，还有就是对小程序开放能力的深入理解，知道了小程序能做什么，小程序不能做什么，所以敬以此文记录本胖对小程序的认知，如有错误，烦请指出，谢谢。1 小程序登录以及授权1.1 小程序登录任何项目都会涉及到登录这个问题，在JSP的远古时代登录都是直接由服务端控制，在现在react，vue单页面时代，登录是有客户端控制，所以现在的很多前端框架都会有全路由守护这种东西，能很方便地帮助我们控制路由权限，那么在小程序里面的登录时怎么控制的呢？小程序里面的登录主要分2种A. 利用现有登录体系直接复用现有系统的登录体系，只需要在小程序端设计用户名，密码/验证码输入页面，便可以简便的实现登录，只需要保持良好的用户体验即可。\r\n复制代码B.利用OpenIdOpenId 是一个小程序对于一个用户的标识，利用这一点我们可以轻松的实现一套基于小程序的用户体系，值得一提的是这种用户体系对用户的打扰最低，可以实现静默登录。具体步骤如下：\r\n\r\n1.小程序客户端通过 wx.login 获取 code\r\n\r\n2.传递 code 向服务端，服务端拿到 code 调用微信登录凭证校验接口，微信服务器返回 openid 和会话密钥 session_key ，此时开发者服务端便可以利用 openid 生成用户入库，再向小程序客户端返回自定义登录态\r\n\r\n复制代码这次由于需要获取用户手机号的，所以我们选择了第二种（注意了，个人主体的小程序号是获取不了用户手机号的）。但是这里需要强调的一点是登录和授权获取用户信息（比如手机号，头像，微信步数）是两回事情，不要搞混淆了，登录是可以做到静默登录的，但是很少有小程序只做一个登录的，那会是一个没有灵魂的小程序哈。1.2 授权这里不得不承认，微信是中国流量最大的app，所有小程序才有了生根萌芽的沃土，做小程序就不得不涉及到相关用户权限的授权。A计划小程序这次涉及到授权的地方主要是获取用户手机号，还记得那年夏天微信小程序获取手机号还是可以直接通过API方式直接弹出授权弹框的，这次发现竟然不行了，只好去官网看看改动了哪些（不得不说这也是小程序的不确定性，一家独大，想改就改），发现现在要获取用户手机号只能通过引导用户触发相应的按钮才行。1.3 登录+授权解决方案这次本胖采用的方案是专门用一个页面（login）来进行用户的登录以及授权，这里需要注意的是，你在取微信用户绑定的手机号，需先调用wx.login接口。我们首先需要下面这个button组件用来引导用户触发登录<button type=\"primary\" open-type=\"getPhoneNumber\" bindgetphonenumber=\"getPhoneNumber\">微信登录</button>\r\n复制代码然后需要在login页面的onload事件中发起wx.login()，获取对应的code存起来。 关键的一步到了，在用户点击确定授权的按钮，我们需要监听getPhoneNumber事件getPhoneNumber(e) {\r\n    if (e.detail.iv) {\r\n      this.setData({\r\n        iv: e.detail.iv,\r\n        encryptedData: e.detail.encryptedData\r\n      });\r\n      this.login(this.getPhone);\r\n    }\r\n}\r\n复制代码注意到上面最后一行的代码，是在获取到iv以及encryptedData这两个解密用户手机号必备的变量的时候才去发起登录以及获取对应的手机号前端显示用。可以看到上面的微信登录按钮其实一开始是先做了一个获取用户手机号权限的操作，操作成功后才登录的，如果一开始就登录了，但是用户没有同意授权手机号，那么将变得毫无意义，因为手机号才是小程序需要快捷获取的核心用户信息之一。登录完成后客户端可以获取到一个自定义token。类似于浏览器里面的JSSSESIONID,可以存小程序本地，在需要的时候手动带上就可以了，这一点比不了浏览器可以设置自动带上cookie那么方便。2 生成海报为什么很多小程序里面都会有生成海报呢，其实也是因为小程序不能直接转发到朋友圈，不能直接转发到QQ以及其他社交平台，那么就需要出现海报这个中间传播者。这次A计划小程序里面也有这个功能，于是本胖就愉快地开始了海报的填坑。小程序的海报一般都是通过canvas生成的，也就是填小程序canvas的各种坑哈。2.1 实体机海报空白上图中就是在生成海报的时候出现的实体机空白问题，但是在模拟器里面却不会有，在查阅了很多资料以后发现是图片资源没能及时加载出来，就会造成在drawImg的时候没有真实的图片可以画，当然就是空白了。既然是因为在画图的时候图片没有及时请求到造成的问题，那么解决的方案当然就是在页面初始化的时候就去异步请求图片downloadFile(url, name) {\r\n  wx.downloadFile({\r\n    url: url,\r\n    success: function (res) {\r\n   \r\n    }\r\n  });\r\n}\r\n复制代码2.2 背景图片自适应canvas是需要设置大小的，否则取他的默认大小。但是canvas的单位是px和小程序标准的单位rpx是不同的。所以我们需要动态给canvas区域设置宽高才能让canvas满满填充整个理想区域。createNewImg: function (text) {\r\n  wx.createSelectorQuery().select('#canvas-container').boundingClientRect( (rect) => {\r\n      this.setData({\r\n        canvasW: rect.width,\r\n        canvasH: rect.height\r\n      });\r\n      var width = this.data.canvasW,\r\n        height = this.data.canvasH,     \r\n        context = wx.createCanvasContext('mycanvas');\r\n      context.drawImage(this.data.imgUrl1, 0, 0, width, height);\r\n      context.draw();\r\n    }).exec();\r\n  },\r\n复制代码上面的代码就是用过获取不同屏幕下canvas的包裹元素的宽高然后动态给canvas赋值,然后对应图片的画图也是一个道理，就可以让图片只适应不同屏幕。2.3 文字居中好了，画好了主图本胖就要在主图写字了，需求是写一段文字，字数不定，居中显示。本胖一开始想当然了用了setTextAlign设置了文字的对齐方式，可是一看竟然没有说明用，于是本胖只好想算出所有文字的全部长度，用区域宽度减去文字的长度除以2设置文字的起始X坐标就可以了。context.fillText(`我是吕胖胖`, (width - context.measureText(`我是吕胖胖`).width) / 2, );\r\n复制代码上面代码里面的measureText就是解决问题的核心API。2.4 canvas层级太高 导致ios中海报随着屏幕滑动因为海报主体使用了fixed布局，所以会被固定在屏幕的中间，在模拟器里面测试没有问题，但是在ios上面会出现手指滑动海报，海报会随着页面滑动，这是不是看起来很滑稽。这种现象是因为canvas这东西在小程序里面地位那是相当的高，下面是小程序对canvas的介绍。canvas组件是原生组件，他有如下的限制原生组件的使用限制\r\n由于原生组件脱离在 WebView 渲染流程外，因此在使用时有以下限制：\r\n\r\n原生组件的层级是最高的，所以页面中的其他组件无论设置 z-index 为多少，都无法盖在原生组件上。\r\n后插入的原生组件可以覆盖之前的原生组件。\r\n原生组件还无法在 scroll-view、swiper、picker-view、movable-view 中使用。\r\n部分CSS样式无法应用于原生组件，例如：\r\n无法对原生组件设置 CSS 动画\r\n无法定义原生组件为 position: fixed\r\n不能在父级节点使用 overflow: hidden 来裁剪原生组件的显示区域\r\n原生组件的事件监听不能使用 bind:eventname 的写法，只支持 bindeventname。原生组件也不支持 catch 和 capture 的事件绑定方式。\r\n在iOS下，原生组件暂时不支持触摸相关事件。\r\n原生组件会遮挡 vConsole 弹出的调试面板。\r\n在工具上，原生组件是用web组件模拟的，因此很多情况并不能很好的还原真机的表现，建议开发者在使用到原生组件时尽量在真机上进行调试。\r\n复制代码一开始本胖查阅资源后大部分是设置如下disable-scroll='true'\r\n复制代码但是试过后并没有什么软用，最后无意间突然发现了一个好用的属性catchtouchmove='true'\r\n复制代码该属性加在海报最外面的view上面。3 生成小程序码+自定义分析其实微信小程序本身就自带了数据分析，里面有很多比如统计小程序的访问量，访问分析，用户画像等等。当然了，如果你和本胖一样对这些统计不满足的话，你还可以自己定义一些统计。本胖这次的需求是如下生成N个小程序码，然后区别不同渠道的流量3.1 生成多个小程序二维码目前小程序二维码有二种，一种是普通的正方形的（体验版本就是这种），还有一种是小程序官方为了区别其他二维码而专门设置的圆形的体验码，下面所说的体验码都是圆形的体验码，目前只能通过请求小程序官方接口获取。本胖采用的请求A类接口才获取二维码https://api.weixin.qq.com/wxa/getwxacode?access_token=ACCESS_TOKEN\r\n复制代码这个接口需要获取一个叫做access_token的东西下面是获取access_token的接口GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET\r\n复制代码好了，接下来就是愉快地获取二维码了。这时候又一次见识到小程序坑爹的地方了。本胖愉快地写了一个本地ajax请求（一定要post），代码如下：$.ajax({\r\n  method: 'post',\r\n  url: 'https://api.weixin.qq.com/wxa/getwxacode',\r\n  dataType: 'json',\r\n  data: {\r\n    access_token: 本胖的accesss_token\r\n    path: 'pages/index/index?id=1',\r\n  },\r\n  success: (data) => { \r\n    console.log(data);\r\n  }\r\n});\r\n复制代码发现报错，参数为空，再去看官方发现有下面的提示哦哦，原来是要json字符串，而jq默认是contentType是application/x-www-form-urlencoded，于是本胖很快按照提示改成了下面的contentTypecontentType: \"application/json; charset=utf-8\"\r\n复制代码这会总该可以了吧。没想到又是接受不到参数。。。。最后在尝试了很多次以后终于发现了正确的请求方式$.ajax({\r\n  method: 'post',\r\n  url: '/wxa/getwxacode?access_token=本胖的accesss_token',\r\n  dataType: 'json',\r\n  contentType: 'text/plain;charset=UTF-8',\r\n  data: JSON.stringify({\r\n    path: 'pages/index/index?id=1',\r\n  }),\r\n  success: (data) => { \r\n    console.log(data);\r\n  }\r\n});\r\n复制代码有没有很惊喜，有没有很意外。这种设计真的很蛋疼，小程序官方最好给一个请求实例哈。3.2 自定义分析 好了，经历了千辛万苦的尝试，本胖在上一届总算请求到了A计划的小程序圆形码了。接下来就是做自定义分析。所谓自定义分析，在小程序后台管理系统是可以找到的，顾名思义就是我们可以自己定义一些用户行为的分析，比如用户点击某个按钮的次数，用户停留在某些页面的时间等等，可以说是小程序官方留给开发者埋点的口子看了一下关于自定义分析的介绍（文章真的很长很长），知道了自定义分析主要步骤如下1.新建事件\r\n2.选择配置方式\r\n    A.填写配置：不需要任何小程序代码\r\n    B.API上报：需要加对应的小程序代码\r\n3.保存测试或者发布\r\n复制代码注意到了在选择配置方式的时候是有2种的，本胖这次需求是要通过不同的小程序码区别不同渠道的流量，所以选择了第二种。对了，这里需要说明之前在获取小程序码的时候path参数，本胖在路径后面是传了参数的，这个参数就是用来区别不同渠道。然后配置好后，可以获取到对应的上报代码wx.reportAnalytics('statistics', {\r\n  id: '',\r\n});\r\n    \r\n复制代码这里看出本胖是选择了一个名称是statistics的事件名称，然后本胖在A计划小程序的首页的onload事件中加入了以下代码onLoad: function(options) {\r\n  console.log(options);\r\n  wx.reportAnalytics('statistics', {\r\n    id: options.id\r\n  });\r\n}\r\n复制代码那么不同渠道的小程序进入就会获取到不同的id上报给小程序平台，在后台管理中根据不同的渠道id的上报次数来判断不同渠道的流量情况但是，现实有这么美好吗？在体验版的小程序的路径中加入了不同的id，体验了一把，去小程序的后台查看对应的数据（本胖的自定义事件已经发布），有下面的截图看的只是不同id的去重总和数据，并没有不同id对应的数据，也就说通过小程序的自定义分析实现不同小程序码区别不同渠道的想法是不行的，该次尝试以失败告终，也让本胖知道了小程序有哪些是还做不了的，所以说这样的尝试也是有意义的哈。对于这个需求，本胖最终还是打算采用我们自己的服务端来实现不同渠道的流量分析。4 其他坑点哈哈，这一节的标题不知道取什么好了，只好取了这个。4.1 横向滚动做H5的时候，实现横线滚动那是so easy的事情，大家都懂哈，不就是一个熟悉的问题嘛。 但是，这么简单的需求在小程序里面并没有那么简单。<view>\r\n  <scroll-view scroll-x>\r\n  </scroll-view>\r\n</view>\r\n复制代码像上面这样，设置了scroll-x属性就以为当scroll-view 的内容超出scroll-view 时候会出现横向滚动条，但是实际上并不是这样的，还需要下面的设置scroll-view\r\n  white-space: nowrap;\r\n子元素\r\n  display: inline-block;\r\n复制代码white-space:nowrap;这个属性在css里面的意思是规定段落中的文本不进行换行4.2 inupt动态绑定尝试过小程序的都发现他的语法和vue很像，所以上手都是很快的。但是当本胖遇到input的时候果断写了下面的代码<input value=\"{{name}}\">\r\n复制代码想通过这种方式的绑定来动态获取到输入框输入的值。但是现实又是残酷的。人家小程序根本就不支持这种写法。有没有很坑，都向vue学习了90%的语法了，input绑定变量使用评率这么高的竟然不学。吐槽归吐槽，活还是要继续干下去的。只好采用react版方式来动态获取input的输入值了。this.setData({\r\n  val: e.detail.value\r\n});\r\n复制代码4.3 wx.request这是小程序用来获取服务端数据的api，使用频率那也是很高的，但是他在本胖看来主要有2处需要注意的地方1.默认的contentType是application/json，需要自己改写为合适的和服务器端通讯\r\n2.和传统的ajax很像，容易走入回调地狱，可以自己封装成promise形式哈\r\n复制代码5. 小结这篇文章主要是总结了本胖这两周在开发A计划小程序遇到的问题以及对应的解决方案和对微信小程序的一些个人看法。不过，微信小程序的确可以说是前端史上一次重大的突破，其体验，能力（虽然大部分也都是通过使用微信app的能力）都比一般的H5更好更强。而且语法和vue很像，易于上手，开发体验也不错，相应的社区工具都越来越完善了，很期待小程序的未来。这应该是本胖工作2年多来写的最长的一篇技术博文了，二年多时间说过就过，本胖唯有努力使自己的能力与年龄成正相关才行哈。"}
{"title": "青铜选手带你动手撸一个博客小程序给自己 ", "author": "Rolan", "pub_time": "2018-11-8 00:45", "content": "看掘金也又一年多了，感叹各位大佬技术6的一批，刚上学的时候也给人搞过一两个小程序，突然心血来潮想总结总结经验，给自己也搞一个爽一爽，顺便也在写一篇，让各位大佬看看还有什么问题，毕竟本屌虚心的一批无图言鸡儿=>成品图菜鸡实践中总结的一些tip小程序登陆获取用户信息（与服务器交互）小程序显示富文本与markdown（使用了towxml）对wx.request的小封装（搞成promise爽一爽）iview weapp组件的使用小程序原生组件的使用针对上拉加载更多的小总结手动实现个简单的假的瀑布流功能需求分类显示博客显示博客内容（富文本/Markdown）用户在微信小程序登陆用户登陆后评论博客显示我爱看的一些书籍信息（特殊服务）一键将书籍发送到kindle（特殊服务）前期准备去UI中国或者其他网站扒拉个看着顺眼的UI设计图（毕竟审美是硬伤）去阿里图标网站找上一套顺眼的图标。选几个用来给小程序的底部tab栏用，由于小程序tab图标切换是靠换图片来实现的，因此可以从阿里图标上每个图标下两份，灰色版的下一份，彩色版的下一份。稍微整理一下图标的命名3. 个人注册个小程序账号（直接去微信公众平台注册，简单的一批），注册完后登陆一下，把appid与appsecrect搞到手4. 数据接口准备（重要的一环，总不能都是空架子把），，根据各位看官的博客后台的实际情况搞，一般都有数据接口的，用来获取文章啥的。这里我用的是自己开发的后端，所以接口什么的都是按需开发的~各位看官要是如果有兴趣可以找我要后台（thinkphp+vue+element搞的管理后台）这个项目用到的接口主要有获取顶部轮播图的接口（getSlides）根据栏目获取栏目下博客的接口（getPostOfCategory）获取文章的接口（getPost）用户登陆接口（wxLogin）用户绑定邮箱的接口（bindMail）发送书籍的接口（sendBook）获取配置的接口（getConfig）获取文章评论的接口用户评论文章的接口 这里要解释一下getConfig，每日推荐、首页博客等一些显示博客的地方说白了其实就是从服务端取不同栏目下的文章，因此需要一个栏目id来调用getPostOfCategory接口，但是又不想把栏目id写死在小程序里，万一哪天心情不好把栏目给删了小程序岂不要改代码？刚好当时做后台的时候搞了一个配置管理的功能，这次刚好用到；专门为小程序新建了一个配置组，把小程序用到的栏目id和其他乱七八糟的东西（比如分页的每页大小，背景图啥的）以key-value的形式存在后端，每次小程序启动的时候从后端获取一下配置存在localStorage里，这样在后台改改配置，小程序显示的栏目自然也就切换了。不瞎bb了开整基础设施根据需求规划一下，在pages文件夹里把所需要的页面右键新建出来由于用到了iview组件和towxml，所以把这俩老哥也给放根目录新建一个netUtils.js（网络层）,封装一下wx.request，放进netUtils里，同时把服务器地址baseUrl也作为常量放在netUtils里，所有的网络访问url都从baseUrl拼接而来，方便切换测试与生成环境再此基础上搞出来一个dataUtils（即数据层），将所有的从服务器获取数据的网络请求行为（全搞成promise）全部放在这里（可选）由于很多页面都会跳转到文章内容页、搜索页等页面，因此后面又搞了一个navUtils.js把常用的跳转都写在这里面，省的每次都在写一遍文件结构：netUtils.js关键部分const BASEURL = \"https://localhost:8888/\";\r\nconst APIURL = \"https://localhost:8888/api/\";\r\n/**\r\n * 封装request\r\n */\r\nconst requestPromise = function ({ url, data, header,\r\n  method = 'GET' }) {\r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url: url,\r\n      data: data,\r\n      header: header,\r\n      method: method,\r\n      success: (res) => { resolve(res) },\r\n      fail: (err) => { reject(err) }\r\n    })\r\n  });\r\n};\r\nmodule.exports={\r\n  BASEURL:BASEURL,\r\n  APIURL:APIURL,\r\n  request: requestPromise\r\n}\r\n复制代码dataUtils关键部分let netUtils = require('./netUtils.js');\r\n/**\r\n * 获取服务器数据基本方法\r\n */\r\nfunction getServerDataPromise(url,data,header=null,method='GET'){\r\n  let dataUrl = netUtils.BASEURL+url;\r\n  return new Promise((resolve, reject) => {\r\n    netUtils.request({\r\n      url: dataUrl,\r\n      data: data,\r\n      header:header,\r\n      method:method\r\n    }).then(res => {\r\n      resolve(res);\r\n    }).catch(err => {\r\n      reject(err);\r\n    });\r\n  });\r\n}\r\n/**\r\n * 获取栏目下文章\r\n */\r\nfunction getPostOfCategoryPromise(data) {\r\n  let url ='api/front/portal/getPostOfCategory';\r\n  return getServerDataPromise(url,data);\r\n};\r\n/**\r\n * 获取幻灯片\r\n */\r\nfunction getSlidesPromise(data){\r\n  let url ='api/front/portal/getSlide';\r\n  return getServerDataPromise(url,data);\r\n}\r\n\r\n........各位老哥根据实际情况把自己的接口封装一下搞一搞\r\n\r\n\r\nmodule.exports = {\r\n  getPostOfCategory: getPostOfCategoryPromise,\r\n  getSlides: getSlidesPromise,\r\n  checkToken: checkToken,\r\n  userLogin:userLoginPromise,\r\n  getContent: getContentPromise,\r\n  addComment: addCommentPromise,\r\n  getComment:getCommentPromise,\r\n  getKindleEmail: getKindleEmailPromise,\r\n  bindKindleEmail: bindKindleEmailPromise,\r\n  sendBook: sendBookPromise,\r\n  getNav:getNavPromise,\r\n  search: searchPromise,\r\n  getUser: getUserPromise,\r\n  checkLogin: checkLoginPromise,\r\n  getConfig: getConfigPromise\r\n};\r\n复制代码先搞个首页我的个人习惯是先把页面的js获取数据的部分写好，然后再去写wxml与wxss，有了数据填充，比教容易看出来页面的效果，调试完页面后，在取js把点击事件、跳转等其他的一些代码补全。 前端代码比较简单，就不在这贴了，值得注意的一点是，首页使用了iview的组件，因此在index.json中应先把使用的组件配置一下 index.json{\r\n  \"usingComponents\": {\r\n    \"i-row\": \"../../iview/row/index\",\r\n    \"i-col\": \"../../iview/col/index\",\r\n    \"i-spin\": \"../../iview/spin/index\",\r\n    \"i-icon\": \"../../iview/icon/index\",\r\n    \"i-message\": \"../../iview/message/index\",\r\n    \"i-divider\": \"../../iview/divider/index\"\r\n  },\r\n  \"enablePullDownRefresh\":true\r\n}\r\n复制代码index.jslet netUtils=require('../../utils/netUtils.js');\r\nlet dataUtils=require('../../utils/dataUtils.js');\r\nlet navUtils=require('../../utils/navUtils.js');\r\nconst { $Message } = require('../../iview/base/index');\r\n// pages/index/index.js\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    IMGURL: netUtils.BASEURL,\r\n// 幻灯片\r\n    slides:[],\r\n// 推荐\r\n    recommends:[],\r\n    recommendPage:1,\r\n    recommendPageSize:5,\r\n    // blog\r\n    blogs: [],\r\n    blogPage: 1,\r\n    blogPageSize: 10,\r\n//config\r\n    slideId: getApp().globalData.StorageDB.get('config.slideId'),\r\n    recommendCategoryId: getApp().globalData.StorageDB.get('config.recommendCategoryId'),\r\n    blogCategoryId:getApp().globalData.StorageDB.get('config.blogCategoryId'),\r\n    hasMore:true\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n    this.getSlides();\r\n    this.getRecommend();\r\n    this.getBlog();\r\n  },\r\n  /**\r\n   * 页面相关事件处理函数--监听用户下拉动作\r\n   */\r\n  onPullDownRefresh: function () {\r\n    this.setData({\r\n      // 推荐\r\n      recommends: [],\r\n      recommendPage: 1,\r\n      recommendPageSize: 5,\r\n      // blog\r\n      blogs: [],\r\n      blogPage: 1,\r\n      blogPageSize: 10,\r\n      hasMore:true\r\n    });\r\n    this.getSlides();\r\n    this.getRecommend();\r\n    this.getKindleBook();\r\n    this.getBlog();\r\n  },\r\n\r\n  /**\r\n   * 页面上拉触底事件的处理函数\r\n   */\r\n  onReachBottom: function () {\r\n    this.getBlog();\r\n  },\r\n  //自定义方法\r\n\r\n  getSlides(){\r\n    dataUtils.getSlides({id:1})\r\n    .then(res=>{\r\n      if(res.data.status=='200'){\r\n        this.setData({\r\n          slides:res.data.data.item\r\n        });\r\n      }\r\n    });\r\n  },\r\n  getRecommend(){\r\n    dataUtils.getPostOfCategory({\r\n      page:this.data.recommendPage,\r\n      pageSize:this.data.recommendPageSize,\r\n      id:this.data.recommendCategoryId\r\n    }).then(res=>{\r\n      if (res.data.status == '200') {\r\n        if(res.data.data.pageData.length==0){\r\n          return;\r\n        }\r\n        let recommendPage = this.data.recommendPage;\r\n        recommendPage = recommendPage + 1;\r\n        let recommends = this.data.recommends.concat(res.data.data.pageData);\r\n        this.setData({\r\n          recommends: recommends,\r\n          recommendPage: recommendPage\r\n        });\r\n      }\r\n      else{\r\n        $Message({\r\n          content: '未获取到数据～',\r\n          type: 'error'\r\n        });\r\n      }\r\n    });\r\n  },\r\n  getBlog() {\r\n    dataUtils.getPostOfCategory({\r\n      page: this.data.blogPage,\r\n      pageSize: this.data.blogPageSize,\r\n      id: this.data.blogCategoryId\r\n    }).then(res => {\r\n      if (res.data.status == '200') {\r\n        if (res.data.data.pageData.length == 0) {\r\n          this.setData({\r\n            hasMore:false\r\n          });\r\n          return;\r\n        }\r\n        let blogPage = this.data.blogPage;\r\n        blogPage = blogPage + 1;\r\n        let blogs = this.data.blogs.concat(res.data.data.pageData);\r\n        let blogLeft=blogs.filter((value,index)=>{return index%2!=0});\r\n        let blogRight = blogs.filter((value, index) => { return index % 2 == 0 });\r\n        this.setData({\r\n          blogs: res.data.data.pageData,\r\n          blogLeft:blogLeft,\r\n          blogRight:blogRight,\r\n          blogPage: blogPage\r\n        });\r\n      }\r\n      else {\r\n        $Message({\r\n          content: '未获取到数据～',\r\n          type: 'error'\r\n        });\r\n      }\r\n    });\r\n  },\r\n  navToContent(e){\r\n    navUtils.navToContent(e.currentTarget.dataset.id);\r\n  },\r\n  navToBlog(){\r\n    wx.switchTab({\r\n      url: '../blog/blog',\r\n    });\r\n  }\r\n})\r\n复制代码代码比较简单（毕竟技术比较菜），值得注意的是这个getBlog方法，该方法获取的是首页上，中下部分的那一坨博客，当页面触底时会会加载更多觉得单纯的排列下来比较平庸，因此想搞个瀑布流，反正没那么多性能和外观要求，所以就搞了个假的瀑布流，具体操作就是在获取到数据后，把数据分成两半，左半边和右半边，在前端也是把这两个数组分别循环一下即可。由于页面有下拉刷新与拉到底部会加载更多，因此，在这的逻辑就是，当触发上拉加载时从服务器获取到数据判断下数据是否为空，若为空则说明无更多数据可加载将hasMore设为false即可，page与blogs数据均不变若不为空则 拼接 到现有数据数组的尾部，同时将页码page在现有基础上+1（即将页码的操作放在每次请求之后，这样每次请求时候无需考虑页码是否+1直接用即可），即先拼接在处理页码最后setData当触发下拉刷新时先将page设置为1，清空现有blogs数据调用getBlog这样做能把下拉刷新与上拉加载的功能均用getBlog来做无需根据情况来判断如何处理（替换or拼接）从服务器请求来的数据第一期结尾罗里吧嗦的有点长了，越写越感觉做的不咋地写的更不咋地，看各位看官凑合的看下把（估计没几个人会看到这个地方...），我也整理整理思路，希望写后续第二期的时候能把想表达的写出来。"}
{"title": "小游戏群聊分享又有新套路，小程序实现全面布局 ", "author": "Rolan", "pub_time": "2018-11-9 00:21", "content": "11 月 5 日晚，微信宣称「为了让用户更好地发现和使用基于地理位置的小程序服务」，对附近的小程序进行了升级，新增了分类导航、服务标签、在线客服展示等功能。同时，小程序新增了带有状态的群分享卡片、局域网通信等功能。本次更新几乎将微信小程序的整体布局一一展现：线上连接线下：附近的小程序功能升级。以往更多的是线下扫码进入小程序，而升级后的附近的小程序则更像美团、大众点评，可以实现线上到线下的用户延申。小程序卡片升级：小程序和小游戏的群分享卡片，支持实时显示活动参与人数。原来分享小程序卡片只能邀请好友进入小程序、加入游戏，升级后的卡片分享者及点击用户，均可使用「请提醒我」按钮，接收活动开始提醒，及时获取活动状态。小程序打通物联网：小程序支持与同一局域网内的设备进行网络通信，可实现操控智能硬件、为智能硬件配置网络等功能。关于附近的小程序我们在《微信重磅改版！这是要用「附近的小程序」再造一个美团？》一文中已进行过详解，接下来我们将就小程序卡片与小程序打通物联网两方面做出介绍。群分享小程序卡片升级群分享卡片升级，即分享者及点击过该卡片的参与者，可使用「请提醒我」按钮，在默认的 24 小时内（过期时间戳支持修改）都可以接收活动开始提醒，以及时获取活动状态。当有朋友分享小程序卡片到群聊中，分享者及点击过该卡片的参与者将可以设置「请提醒我」，接下来默认 24 小时内将可以及时接收到动态消息，获得「小程序提醒」，将用户迅速召回小程序。从某种程度上看，动态消息和消息模板有些许相似，他们都能以向用户传达消息为手段召回用户。作为一个新鲜出炉的新能力，动态消息的目前受到的限制并不算小。它的出现也可以看作微信对小程序活动能力的再补充。用户可接受小程序短期活动的动态消息，商家或组织利用小程序举办活动也更加方便。动态消息适合的场景非常多样，多人游戏、活动报名、多人砍价、活动倒数都可以用升级的群分享卡片进行通知和扩散，配合小程序卡片的图片引导用户点击「请提醒我」，小程序就能在活动开始时提示用户「已开始」。我们阅读开发文档后发现，动态消息的固定句型为「成员正在加入，当前 X/Y 人」，X、Y 的定义都为 String（字符串）类型，这意味着，你将可以创造各种「投机」的句型：成员正在加入，当前 2/4 人成员正在加入，当前 二/four 人成员正在加入，当前 请关注我们的微信公众号/zxcx0101人成员正在加入，当前 已有2998人参与拼团，就差你了/ 人这对很多工具类、拼团类小程序和小游戏来说都意义重大。新功能发布后，「小打卡」的开发者就兴奋地表示要和微信群深度绑定，利用群分享卡片，为小程序创造更多价值。小程序打通物联网本次更新最大的创新可能在于：小程序将支持连接包括智能家居等物联网设备。就像在 iPhone 上使用 Home app，在本次更新后，你将可以把你的小程序当作遥控器，在其中实现对智能电灯、智能音箱、路由器、空调等的控制。微信小程序的开发文档中新增了对「局域网通信」的描述，其中第一句为：基础库 2.4.0 提供了 wx.startLocalServiceDiscovery 等一系列 mDNS API，可以用来获取局域网内提供 mDNS 服务的设备的 IP。简单理解 mDNS，即每个进入局域网的主机，如果开启了 mDNS 服务的话，都会向局域网内的所有主机组播一个消息：「我是谁，我的 IP 地址是多少」。然后其他也有该服务的主机就会响应，也会告诉你，「它是谁，它的 IP 地址是多少」。值得注意的是，mDNS 仅是实现了服务发现，所以只能用于控制，而不能用于服务。不仅仅是物联网，「小程序支持与同一局域网内的设备进行网络通信」，也意味着你将来可以像打局域网联机 CS 一样，实现局域网内一起打小游戏。可能会有读者好奇，既然小游戏支持多人同玩，何必再玩局域网联机？我们可以设想一个场景，你在一个酒吧里，老板说：「大家连接好 WiFi，打开 XXX 小程序，点击抽奖按钮，22:00 会准时开奖。」老板需要做的，是下载一个 app，开启 mDNS 服务充当局域网服务器，用于大家加入，而在小程序内实现功能。同样，酒吧老板也可以说：「我们现在组一个小程序版赛车局，大家有兴趣的加入。」从而实现同在一个局域网下的玩家，无需添加微信好友实现多人游戏。小程序给腾讯更多尝试的勇气除了上面提到的大更新，微信小程序也放出了不少小更新：单个小程序最多可跳转 10 个其他小程序；影响用户体验的小程序页面同步旋转也来了，当用户旋转手机时，小程序页面也可同步旋转；开发者对图片的处理也更加方便，当用户选择图片后，开发者用图片压缩接口就可以按需设置压缩比例进行压缩。一大波新能力袭来，开发者们已摩拳擦掌。之前曾被戏称为「微信的增量杀手」的小程序，这次的更新完全不让人失望，隐隐让人觉得小程序或许是「腾讯的布局工具」，帮腾讯尝试各种可能。「附近的小程序」连接线下，腾讯的野心昭昭；小程序控制智能家居，小米等家居厂商想要的生态也能在这里实现；小程序新增动态消息通知，与群绑定分享创造更大价值。在小程序生态初见雏形的今天，小程序给了腾讯更大的勇气，延申自己的边界，触达未及的领域。"}
{"title": "浅析微信支付：查询订单和关闭订单 ", "author": "Rolan", "pub_time": "2018-11-9 00:30", "content": "浅析微信支付系列已经更新六篇了哟～，没有看过的朋友们可以看一下哦。浅析微信支付：支付结果通知浅析微信支付：统一下单接口浅析微信支付：微信公众号网页授权声明：这里的查询订单、关闭订单接口仅适用于 小程序支付、公共号支付、扫码支付、APP支付，刷卡支付方式此处并不适用。1、查询订单以下为微信官方的查询订单文档：https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_21.1. 应用场景该接口提供所有微信支付订单的查询，商户可以通过查询订单接口主动查询订单状态，完成下一步的业务逻辑。需要调用查询接口的情况：\r\n◆ 当商户后台、网络、服务器等出现异常，商户系统最终未接收到支付通知；\r\n◆ 调用支付接口后，返回系统错误或未知交易状态情况；\r\n◆ 调用刷卡支付API，返回USERPAYING的状态；\r\n◆ 调用关单或撤销接口API之前，需确认支付状态；1.2. 接口链接https://api.mch.weixin.qq.com/pay/orderquery1.3. 是否需要证书不需要1.4. 调用接口查询订单接口需要使用微信订单号或者商户订单号来查询，其他参数为商户平台信息的公共参数，为常量，此处省略解释。微信订单号：transaction_id（微信的订单号，建议优先使用）\r\n商户订单号：out_trade_no（商户系统内部订单号）此两个参数必填其中之一，微信推荐使用微信订单号来查询，下面为实现代码：private void doOrderQuery() {\r\n    System.out.println(\"查询订单\");\r\n    HashMap<String, String> data = new HashMap<String, String>();\r\n    // data.put(\"out_trade_no\", out_trade_no);\r\n    data.put(\"transaction_id\", \"4008852001201608221962061594\");\r\n    try {\r\n        WXPay wxPay = new WXPay(WXPayConfigImpl.getInstance());\r\n        Map<String, String> r = wxPay.orderQuery(data);\r\n        System.out.println(r);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}wxPay.orderQuery方法为封装的sdk方法，具体实现请参考作者github源码。对于商户关键信息的写入，公共方法为wxPay.fillRequestData，实现如下：/**\r\n * 向 Map 中添加 appid、mch_id、nonce_str、sign_type、sign <br>\r\n * 该函数适用于商户适用于统一下单等接口，不适用于红包、代金券接口\r\n *\r\n * @param reqData r\r\n * @return map\r\n * @throws Exception e\r\n */\r\npublic Map<String, String> fillRequestData(Map<String, String> reqData) throws Exception {\r\n    reqData.put(\"appid\", config.getAppID());\r\n    reqData.put(\"mch_id\", config.getMchID());\r\n    reqData.put(\"nonce_str\", WXPayUtil.generateNonceStr());\r\n    if (SignType.MD5.equals(this.signType)) {\r\n        reqData.put(\"sign_type\", WXPayConstants.MD5);\r\n    } else if (SignType.HMACSHA256.equals(this.signType)) {\r\n        reqData.put(\"sign_type\", WXPayConstants.HMACSHA256);\r\n    }\r\n    reqData.put(\"sign\", WXPayUtil.generateSignature(reqData, config.getKey(), this.signType));\r\n    return reqData;\r\n}以上为查询微信订单的使用方式，具体的返回参数请参考官方文档。2、关闭订单以下为微信官方的关闭订单文档：https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_32.1. 应用场景以下情况需要调用关单接口：商户订单支付失败需要生成新单号重新发起支付，要对原订单号调用关单，避免重复支付；\r\n系统下单后，用户支付超时，系统退出不再受理，避免用户继续，请调用关单接口。注意：订单生成后不能马上调用关单接口，最短调用时间间隔为5分钟。2.2. 接口链接https://api.mch.weixin.qq.com/pay/closeorder2.3. 是否需要证书不需要2.4. 调用接口关闭订单接口需要使用商户订单号来查询，其他参数为商户平台信息的公共参数，为常量，此处省略解释。商户订单号：out_trade_no（商户系统内部订单号）PS：关单接口只能使用微信订单号来查询，和查询接口不同，下面为实现代码：private void doOrderClose() {\r\n    System.out.println(\"关闭订单\");\r\n    HashMap<String, String> data = new HashMap<String, String>();\r\n    data.put(\"out_trade_no\", out_trade_no);\r\n    try {\r\n        WXPay wxPay = new WXPay(WXPayConfigImpl.getInstance());\r\n        Map<String, String> r = wxPay.closeOrder(data);\r\n        System.out.println(r);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}关单接口的公共参数设置和查询订单一致，这里就不重复解释了，具体的返回参数请参考微信官方文档。PS：关单接口可能会调用失败，已支付、已关闭等场景，所以需要开发者注意官方文档中的错误码，对异常情况进行处理。结语以上为查询订单、关闭订单的调用方式，如果是刷卡支付方式，他的关闭订单接口为撤销订单:reverse，在作者sdk源码中也有具体的实现方式。预告：下一篇文章 申请退款和退款回调接口，敬请期待！！！​如果想要提前一览源码的小伙伴，可以先看看我的 github，地址如下：​https://github.com/YClimb/wxpay-sdk/blob/master/README.md加作者私人微信，作者微信号如下 yclimb，标明 微信支付 可拉入微信支付讨论群与小伙伴一起探讨哦，一定要标明 微信支付 哦～"}
{"title": "小程序第三方框架对比 ( wepy / mpvue / taro ) ", "author": "Rolan", "pub_time": "2018-10-19 00:21", "content": "众所周知如今市面上端的形态多种多样，手机Web、ReactNative、微信小程序, 支付宝小程序, 快应用等,每一端都是巨大的流量入口，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。但面对目前市面上成熟的小程序第三方框架如何针对自己的需求进行选择也是一个麻烦事,本文针对当前市面上的三大转译框架进行一个综合对比,希望能对大家的技术选择有所帮助,如有哪里不妥的地方希望指正;　小程序开发有哪些痛点?频繁调用 setData及 setData过程中页面跳闪组件化支持能力太弱(几乎没有)不能使用 less、scss 等预编译器request 并发次数限制　为什么使用第三方框架? 只要熟悉vue或react即可快速上手,学习成本低 一套代码可在多端编译运行(微信,支付宝,h5,RN)  支付宝小程序暂不完善组件化开发，完美解决组件隔离，组件嵌套，组件通信等问题 支持使用第三方 npm 资源使小程序可支持 Promise，解决回调烦恼可使用 Generator Fu-nction / Class / Async Function 等特性，提升开发效率 对小程序本身的优化，如生命周期的补充，性能的优化等等支持样式编译器: Scss/Less，模板编译器，代码编译器：Babel/Typescript。    第三方框架对比 wepy mpvue taro　　在这里我通过对目前已开源的三种常用小程序框架做一个综合对比, 还有一个叫nanchi的基于react的小程序转译框架,由于没来的及研究暂不做比较;WEPY https://tencent.github.io/wepy/document.html　　腾讯团队开源的一款类vue语法规范的小程序框架,借鉴了Vue的语法风格和功能特性,支持了Vue的诸多特征，比如父子组件、组件之间的通信、computed属性计算、wathcer监听器、props传值、slot槽分发，还有很多高级的特征支持：Mixin混合、拦截器等;WePY发布的第一个版本是2016年12月份，也就是小程序刚刚推出的时候，到目前为止，WePY已经发布了52个版本, 最新版本为1.7.2; MpVue http://mpvue.com/mpvue/#-html　　美团团队开源的一款使用 Vue.js 开发微信小程序的前端框架。使用此框架，开发者将得到完整的 Vue.js 开发体验，同时为 H5 和小程序提供了代码复用的能力。mpvue在发布后的几天间获得2.7k的star,上升速度飞起,截至目前为止已经有13.7k的star;Taro https://taro.aotu.io/ 　　京东凹凸实验室开源的一款使用 React.js 开发微信小程序的前端框架。它采用与 React 一致的组件化思想，组件生命周期与 React 保持一致，同时支持使用 JSX 语法，让代码具有更丰富的表现力，使用 Taro 进行开发可以获得和 React 一致的开发体验。,同时因为使用了react的原因所以除了能编译h5, 小程序外还可以编译为ReactNative;Star  　           生命周期　　同为vue规范的mpvue和wepy的生命周期和各种方法不尽相同　　wepy　　wepy生命周期基本与原生小程序相同,再此基础上糅合了一些vue的特性; 对于WePY中的methods属性，因为与Vue中的使用习惯不一致，非常容易造成误解，这里需要特别强调一下：WePY中的methods属性只能声明页面wxml标签的bind、catch事件，不能声明自定义方法，这与Vue中的用法是不一致的。　　import wepy from 'wepy';\r\n\r\nexport default class MyPage extends wepy.page {\r\n// export default class MyComponent extends wepy.component {\r\n    customData = {}  // 自定义数据\r\n\r\n    customFunction ()　{}  //自定义方法\r\n\r\n    onLoad () {}  // 在Page和Component共用的生命周期函数\r\n\r\n    onShow () {}  // 只在Page中存在的页面生命周期函数\r\n\r\n    config = {};  // 只在Page实例中存在的配置数据，对应于原生的page.json文件\r\n\r\n    data = {};  // 页面所需数据均需在这里声明，可用于模板数据绑定\r\n\r\n    components = {};  // 声明页面中所引用的组件，或声明组件中所引用的子组件\r\n\r\n    mixins = [];  // 声明页面所引用的Mixin实例\r\n\r\n    computed = {};  // 声明计算属性（详见后文介绍）\r\n\r\n    watch = {};  // 声明数据watcher（详见后文介绍）\r\n\r\n    methods = {};  // 声明页面wxml中标签的事件处理函数。注意，此处只用于声明页面wxml中标签的bind、catch事件，自定义方法需以自定义方法的方式声明\r\n\r\n    events = {};  // 声明组件之间的事件处理函数\r\n}　　mpvue　　mpvue 除了 Vue 本身的生命周期外，还兼容了小程序生命周期，这部分生命周期钩子的来源于微信小程序的 Page， 除特殊情况外，不建议使用小程序的生命周期 钩子。 1Vue\r\n 3 beforeCreate\r\n 4 created\r\n 5 beforeMount\r\n 6 mounted\r\n 7 beforeUpdate\r\n 8 updated\r\n 9 activated\r\n10 deactivated\r\n11 beforeDestroy\r\n12 destroyed\r\n13 app 部分\r\n15 onLaunch，初始化\r\n16 onShow，当小程序启动，或从后台进入前台显示\r\n17 onHide，当小程序从前台进入后台\r\n18 page 部分\r\n20 onLoad，监听页面加载\r\n21 onShow，监听页面显示\r\n22 onReady，监听页面初次渲染完成\r\n23 onHide，监听页面隐藏\r\n24 onUnload，监听页面卸载\r\n25 onPullDownRefresh，监听用户下拉动作\r\n26 onReachBottom，页面上拉触底事件的处理函数\r\n27 onShareAppMessage，用户点击右上角分享\r\n28 onPageScroll，页面滚动\r\n29 onTabItemTap, 当前是 tab 页时，点击 tab 时触发 （mpvue 0.0.16 支持）简单示例new Vue({\r\n  data: {\r\n    a: 1\r\n  },\r\n  created () {\r\n    // `this` 指向 vm 实例\r\n    console.log('a is: ' + this.a)\r\n  },\r\n  onShow () {\r\n    // `this` 指向 vm 实例\r\n    console.log('a is: ' + this.a, '小程序触发的 onshow')\r\n  }\r\n})\r\n// => \"a is: 1\" taro与react生命周期完全相同class Clock extends Component {\r\n  constructor (props) {\r\n    super(props)\r\n    this.state = { date: new Date() }\r\n  }\r\n\r\n  componentDidMount() {\r\n\r\n  }\r\n\r\n  componentWillUnmount() {\r\n\r\n  }\r\n\r\n  render () {\r\n    return (\r\n      <View>\r\n        <Text>Hello, world!</Text>\r\n        <Text>现在的时间是 {this.state.date.toLocaleTimeString()}.</Text>\r\n      </View>\r\n    )\r\n  }\r\n}列表渲染在列表渲染上三者也分别有不同的应用方法wepy当需要循环渲染WePY组件时(类似于通过wx:for循环渲染原生的wxml标签)，必须使用WePY定义的辅助标签<repeat><template>\r\n    <!-- 注意，使用for属性，而不是使用wx:for属性 -->\r\n    <repeat for=\"{{list}}\" key=\"index\" index=\"index\" item=\"item\">\r\n        <!-- 插入<script>脚本部分所声明的child组件，同时传入item -->\r\n        <child :item=\"item\"></child>\r\n    </repeat>\r\n</template>\r\n\r\n<script>\r\n    import wepy from 'wepy';\r\n    // 引入child组件文件\r\n    import Child from '../components/child';\r\n\r\n    export default class Index extends wepy.component {\r\n        components = {\r\n            // 声明页面中要使用到的Child组件的ID为child\r\n            child: Child\r\n        }\r\n\r\n        data = {\r\n            list: [{id: 1, title: 'title1'}, {id: 2, title: 'title2'}]\r\n        }\r\n    }\r\n</script>mpvue使用v-for与vue一致,只是需要注意一点，嵌套列表渲染，必须指定不同的索引！<!-- 在这种嵌套循环的时候， index 和 itemIndex 这种索引是必须指定，且别名不能相同，正确的写法如下 -->\r\n<template>\r\n    <ul v-for=\"(card, index) in list\">\r\n        <li v-for=\"(item, itemIndex) in card\">\r\n            {{item.value}}\r\n        </li>\r\n    </ul>\r\n</template>taro的列表循环用法基本与react相同,有一点需要注意,在 React 中，JSX 是会编译成普通的 JS 的执行，每一个 JSX 元素，其实会通过 createElement 函数创建成一个 JavaScript 对象（React Element），因此实际上你可以这样写代码 React 也是完全能渲染的：const list = this.state.list.map(l => {\r\n  if (l.selected) {\r\n    return <li>{l.text}</li>\r\n  }\r\n}).filter(React.isValidElement)但是 Taro 中，JSX 会编译成微信小程序模板字符串，因此你不能把 map 函数生成的模板当做一个数组来处理。当你需要这么做时，应该先处理需要循环的数组，再用处理好的数组来调用 map 函数。例如上例应该写成：const list = this.state.list\r\n  .filter(l => l.selected)\r\n  .map(l => {\r\n    return <li>{l.text}</li>\r\n  })事件处理mpvue目前全支持小程序的事件处理器,引入了 Vue.js 的虚拟 DOM ，在前文模版中绑定的事件会被挂在到 vnode 上，同时 compiler 在 wxml 上绑定了小程序的事件，并做了相应的映射，所以你在真实点击的时候通过 runtime 中 handleProxy 通过事件类型分发到 vnode 的事件上，同 Vue 在 WEB 的机制一样，所以可以做到无损支持。同时还顺便支持了自定义事件和 $emit 机制// 事件映射表，左侧为 WEB 事件，右侧为 小程序 对应事件\r\n{\r\n    click: 'tap',\r\n    touchstart: 'touchstart',\r\n    touchmove: 'touchmove',\r\n    touchcancel: 'touchcancel',\r\n    touchend: 'touchend',\r\n    tap: 'tap',\r\n    longtap: 'longtap',\r\n    input: 'input',\r\n    change: 'change',\r\n    submit: 'submit',\r\n    blur: 'blur',\r\n    focus: 'focus',\r\n    reset: 'reset',\r\n    confirm: 'confirm',\r\n    columnchange: 'columnchange',\r\n    linechange: 'linechange',\r\n    error: 'error',\r\n    scrolltoupper: 'scrolltoupper',\r\n    scrolltolower: 'scrolltolower',\r\n    scroll: 'scroll'\r\n}踩坑注意(官方文档)：列表中没有的原生事件也可以使用例如 bindregionchange 事件直接在 dom 上将bind改为@ @regionchange,同时这个事件也非常特殊，它的 event type 有 begin 和 end 两个，导致我们无法在handleProxy 中区分到底是什么事件，所以你在监听此类事件的时候同时监听事件名和事件类型既 <map @regionchange=\"functionName\" @end=\"functionName\" @begin=\"functionName\"><map>小程序能力所致，bind 和 catch 事件同时绑定时候，只会触发 bind ,catch 不会被触发，要避免踩坑。事件修饰符.stop 的使用会阻止冒泡，但是同时绑定了一个非冒泡事件，会导致该元素上的 catchEventName 失效！.prevent 可以直接干掉，因为小程序里没有什么默认事件，比如submit并不会跳转页面.capture 支持 1.0.9.self 没有可以判断的标识.once 也不能做，因为小程序没有 removeEventListener, 虽然可以直接在 handleProxy 中处理，但非常的不优雅，违背了原意，暂不考虑其他 键值修饰符 等在小程序中压根没键盘，所以。。。wepy事件绑定区别于vue,根据原生小程序事件提供了语法优化绑定事件 bindtap=\"click\" 替换为 @tap=\"click\"，取消冒泡原catchtap=\"click\"替换为@tap.stop=\"click\"。捕获监听事件 capture-bind:tap=\"click\" 替换为 @tap.capture=\"click\"，中断捕获监听capture-catch:tap=“click\"替换为 @tap.capture.stop=\"click\"。Taro 元素的事件处理和 DOM 元素的很相似。但是有一点语法上的不同:Taro 事件绑定属性的命名采用驼峰式写法，而不是小写。 如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串 (DOM 元素的写法)。 例如，传统的微信小程序模板：<button onclick=\"activateLasers\">\r\n  Activate Lasers\r\n</button>Taro 中稍稍有点不同：<button onClick={this.activateLasers}>\r\n  Activate Lasers\r\n</button>在 Taro 中另一个不同是你不能使用 catchEvent 的方式阻止事件冒泡。你必须明确的使用 stopPropagation。例如，阻止事件冒泡你可以这样写：class Toggle extends React.Component {\r\n  constructor (props) {\r\n    super(props)\r\n    this.state = {isToggleOn: true}\r\n  }\r\n\r\n  onClick = (e) => {\r\n    e.stopPropagation()\r\n    this.setState(prevState => ({\r\n      isToggleOn: !prevState.isToggleOn\r\n    }))\r\n  }\r\n\r\n  render () {\r\n    return (\r\n      <button onClick={this.onClick}>\r\n        {this.state.isToggleOn ? 'ON' : 'OFF'}\r\n      </button>\r\n    )\r\n  }\r\n} request请求wepy对wx.request做了接受参数的修改,值得一提的是它提供了针对全局的intercapter拦截器// 原生代码:\r\n\r\nwx.request({\r\n    url: 'xxx',\r\n    success: function (data) {\r\n        console.log(data);\r\n    }\r\n});\r\n\r\n// WePY 使用方式, 需要开启 Promise 支持，参考开发规范章节\r\nwepy.request('xxxx').then((d) => console.log(d));\r\n\r\n// async/await 的使用方式, 需要开启 Promise 和 async/await 支持，参考 WIKI\r\nasync function request () {\r\n   let d = await wepy.request('xxxxx');\r\n   console.log(d);\r\n}拦截器import wepy from 'wepy';\r\n\r\nexport default class extends wepy.app {\r\n    constructor () {\r\n        // this is not allowed before super()\r\n        super();\r\n        // 拦截request请求\r\n        this.intercept('request', {\r\n            // 发出请求时的回调函数\r\n            config (p) {\r\n                // 对所有request请求中的OBJECT参数对象统一附加时间戳属性\r\n                p.timestamp = +new Date();\r\n                console.log('config request: ', p);\r\n                // 必须返回OBJECT参数对象，否则无法发送请求到服务端\r\n                return p;\r\n            },\r\n\r\n            // 请求成功后的回调函数\r\n            success (p) {\r\n                // 可以在这里对收到的响应数据对象进行加工处理\r\n                console.log('request success: ', p);\r\n                // 必须返回响应数据对象，否则后续无法对响应数据进行处理\r\n                return p;\r\n            },\r\n\r\n            //请求失败后的回调函数\r\n            fail (p) {\r\n                console.log('request fail: ', p);\r\n                // 必须返回响应数据对象，否则后续无法对响应数据进行处理\r\n                return p;\r\n            },\r\n\r\n            // 请求完成时的回调函数(请求成功或失败都会被执行)\r\n            complete (p) {\r\n                console.log('request complete: ', p);\r\n            }\r\n        });\r\n    }\r\n}taro对request进行了二次封装,可以使用Taro.request(OBJECT)发起网络请求，支持 Promise 化使用。 import Taro from '@tarojs/taro'\r\n\r\nTaro.request({\r\n  url: 'http://localhost:8080/test',\r\n  data: {\r\n    foo: 'foo',\r\n    bar: 10\r\n  },\r\n  header: {\r\n    'content-type': 'application/json'\r\n  }\r\n})\r\n  .then(res => console.log(res.data))mpvue没有对request做特殊优化,与原生相同,可以自己根据需要进行封装状态管理wepy 可引用Redux和Mbox,目前wepy的脚手架内已经集成了redux,选择需要即可;mpVue使用vuextaro使用Redux如何选择适合自己的项目如果只需要做一个微信小程序则根据自己的擅长框架选择mpvue或taro如果是当前老项目想像向程序迁移同时老项目又是使用vue开发,建议使用mpvue或wepy如果是老项目使用react开发且需要部分迁移小程序,建议使用taro如果是新项目且新项目需要同时支持微信小程序和支付宝小程序, 建议使用原生开发,因为目前框架的转译支付宝小程序支持并不是很好,且出了问题不好定位修改, 但如果是小demo不涉及太多逻辑的项目都可以使用框架作为尝鲜; 但如果是涉及太多交互逻辑的则不建议使用框架转译,由于支付宝小程序在视图层基本与小程序一致所以建议手动更改替换部分方法和全局替换一些属性或文件名,如wxml替换为axml这种, 手动转换时间比大概是四比一; 当然如果人手足够一端开发一个是最好的..."}
{"title": "微信小程序之：云开发初体验--致我的第一个小程序 ", "author": "Rolan", "pub_time": "2018-10-19 00:36", "content": "背景：一直关注微信小程序的发展，看着小程序一步步完善，一步步壮大，心里痒痒，也想做一个自己的微信小程序，但是苦于只会前端，不会服务端，所以想法一直被卡着。现在小程序有了云开发，很轻松实现后端功能，写后端跟写前端没啥区别，真的是前端小伙伴们的福音啊。经过几个晚上的熬夜奋战，我的第一个微信小程序正式上线啦。小程序名字： 杭州地铁通二维码：欢迎小伙伴们体验，欢迎吐槽。现在还只是初版，功能还不完善，后面会继续更新的。 闲话少说，进入正题。小程序云开发是什么？开发者可以使用云开发开发微信小程序、小游戏，无需搭建服务器，即可使用云端能力。(云端说白了也就是服务端啦，说的那么高大上，对新手朋友可不太友好。)小程序·云开发提供了三个基础能力： 数据库 、 存储 和 云函数 。数据库 ：json数据库，就理解为往里面存的是json，取出来的也是json。存储 ：就是把你的图片、音频和视频之类的资源文件，存储到里面，帮你生成链接，直接拿链接就可以用，就好像一个网盘一样。云函数 ：这个云函数，就是服务端的接口，你调用这个函数，也就是调用接口。云函数可以在客户端写，也可以在云开发控制台写，写完之后同步一下，两端就都有了。在云函数里，你可以进行计算，也可以操作数据库，把想要的结果以同步或者异步的方式返回给客户端。每个用户最多可拥有两套开发环境，两套环境是互相独立的，一般是创建一个test环境用于开发，一个release环境用于发布。这里有小坑，后面说。云开发怎么用？在创建工程时，选择快速创建云开发模板，直接就拥有了云开发能力， 模板里已经配置好了云服务对接模块的路径，如下图：￼在app.js里配置当前的环境ID，配置完毕，就可以进行开发了。1.创建并编写云函数：右键云函数模块文件夹->新建Node.js云函数： ￼比如，我创建了一个获取用户收藏列表的云函数，函数功能就是从数据库从读取用户收藏列表，并把结果返回给小程序。注意：app.js里虽然指定了当前环境，但这里的代码是在云端运行的，还是要重新指定读的是哪个环境的数据库。￼上面是异步查询，并返回，所以用的是 await。用await的好处是，可以把异步代码像同步一样去写，这在阮一峰的ES6入门里有讲。2.云函数上传并部署创建完云函数后，还需要右键点击云函数，进行上传并部署，注意：微信开发工具不支持批量上传，每个云函数都要单独点击上传，这里有点坑。上传部署完后，就可以直接调用了，云函数调用和接口返回处理，其中，参数是放在data对象里的。3.获取用户唯一身份标识：openId以前没有云服务时，开发者用自己的服务器对接小程序，使用微信用户id时，需要自己调用接口进行鉴权，来判断用户身份。而现在这些都已经被云服务给做了，每次调用接口，微信会自动鉴权，而且每个接口都会自带openId，使用起来非常方便。云函数里的微信openId的获取，和参数的获取： ￼到此，这些就是云函数的使用过程，是不是很简单，又很方便。最后：上面说过，云服务有两个环境，两个环境互相独立，目前微信不支持环境间数据同步，那在test里的一些数据，就要手动去同步到release环境，这个有点烦。还有一点是：如果开发完要上线了，那要把环境从test切到release环境。切换环境时，需要把app.js里云服务初始化环境切换到release，云函数里如果有数据库调用，也要指定数据环境。而且切换时，用的是环境ID，不是环境的名字，文档里写的是用名字，坑了我20分钟。"}
{"title": "微信小程序跳H5页面 ", "author": "Rolan", "pub_time": "2018-10-19 00:42", "content": "主页面：index.wxml主页面：index.js↑跳转到另一个wxml页面→recharge.wxmlrecharge.wxmlweb-view中设置跳转h5的链接，可以加上需要的参数：tips：1.首先，web-view组件的属性src，正如你说看到的，这个就是设置网页链接的，但是需要特别注意的是web-view的src必须配置https协议的链接；2.其次，就是web-view组件只要配置了链接，它是铺满全屏且自动跳转的，所以这也就是为什么我这边需要先写一个navigator按钮，点击操作之后再让它跳转的原因；3.最后，web-view跳转的接口域名，需要配置在小程序开发设置的业务域名列表中。"}
{"title": "万字解析小程序（2）：如何保证大海上可以看到“小船”？ ", "author": "Rolan", "pub_time": "2018-10-22 00:01", "content": "每一个小程序，都需要回答一个问题——你的用户是谁？换句新潮的说法就是：“你是在玩儿微信里的公域流量还是私域流量？”如何判断公域还是私域？根据用户的使用场景。如果用户的使用场景是“吃喝玩乐上班上课”，那就是在玩儿公域流量。如果户的使用场景是“公众号 朋友圈 聊天”，那就是玩儿私域流量。姜太公公观点：本文将讨论小程序下的公域流量和私域流量的核心差别。并且在明天文章中探讨小程序中公域流量和私域流量的玩儿法。大海上看小船淘宝店主想多卖货，过去怎么办？需要买直通车，需要冲击金钻，需要提高淘宝搜索排名。这面向的是“公域流量”。现在怎么办？搞粉丝群，搞社群，把“公域流量”拉出一部分到自己的“私域流量”。为什么要搞私域流量？在选择爆炸的情况下，用户的每次选择都是站在一个茫茫的大海上。海上满满的都是船。用户会看到离他近的船，或者体量大的船。小船的被看到的机会，很少。私域流量的存在带来了什么？天崩地裂，大海被拆分成很多“浅水湖”。我是一艘小小船，用户在“大海”上看不到我，我就开进他身边的“浅水湖”。每日优鲜，玩儿的是公域流量。干死了无数生鲜电商，成为了用户在海上可以看的到的大船。而社区团购生鲜，玩儿的是私域流量，通过一个个宝妈建立的微信群，拼团买生鲜。公域流量是中心化的，这种模式下火的是“规模经济”。赢家因为规模增大带来了经济效益的提高。规模增大后，成本分摊得更低，获客成本更低。所谓赢家通吃。私域流量去中心化的，这一次，“规模效应”失效了。正所谓 场下格斗没套路，乱拳打死老师傅。微信中的“关系”形成了天然的壁垒。导致了去中心化。大海，因为这些关系的存在，变成了“浅水湖”。如何建立私域，需要和用户建立关系。比如建立公众号，成立社群，或者直接和用户的朋友建立关系。建立关系的目的是为了掌握住“私域的入口”。越强的关系，越强的互动，私域流量的质量越好截然不同的玩儿法微信中的公域流量和私域流量，玩儿法完全不同。因为两种流量模式下，用户 形成一个“行为”的方式完全不同。Fogg模型阐述了如何让行为发生。Fogg模型认为一次行为的发生需要具备三个要素，缺一不可。这三个要素是： 动机，成本，触发点。举一个例子，一家饭馆想吸引用户走进来吃饭。这个行为的发生需要如下条件：动机：顾客想吃饭成本：顾客兜里有50块钱，这家饭馆人均消费30元。顾客有“支付的能力”触发点：顾客走到饭馆旁边，看到饭馆“吸引人的招牌”要完成这次行为，三个要素缺一不可。公域流量 和 私域流量的区别在于，这三个要素出现的顺序不同。公域流量是“动机”驱动行为，私域流量是“触发点”驱动行为。公域流量下，用户首先有了一个“动机”，然后打开了一个软件。用户想听歌，于是打开某易云音乐APP。用户记得它的位置在手机第2屏的第3排，然后轻松的找到，然后点开。私域流量下，用户通过“群”“聊天”“公众号”的触发点，获得了一个动机。好友发给我一个“毛衣”拼团链接，看着还挺实惠的。天气真的变冷了，我也需要一件。两者行为的驱动点完全不同。所以，给小程序开发者的建议是：如果你是玩公域流量，你需要降低“主动触发”下的用户摩擦。在用户有一个动机的时候，帮助她迅速完成行为。做到用户所想即所得，让用户快速找到你的软件。用户心理想要的是，don’t make think，don’t make wait。用户找到你的小程序很便捷，就搞好小程序；如果小程序做不到，就将小程序作为引流工具，把用户像APP沉淀，通过APP形成肌肉记忆。如果你是玩私域流量，你需要降低“被动触发”下对用户的打扰。Emmm，这，真的有点复杂哦！具体如何做，看万字解析（3）。总结一下啦微信开放了自己的社交关系，将流量划分为公域流量和私域流量。私域流量是去中心化的，导致“规模效应”失效。私域流量更多是被动触发，公域流量是主动触发。如果你是玩公域流量，你需要降低“主动触发”下的用户摩擦。如果你是玩私域流量，你需要降低“被动触发”下对用户的打扰。相关阅读万字解析小程序（1）：小程序 PK APP = 无解 ？#专栏作家#姜太公公，微信号公众号：grandpa_jiang，人人都是产品经理专栏作家。产品老流氓，终身学习者。致力于研究产品方法论，解决小白PM的疑难杂症。本文原创发布于人人都是产品经理。未经许可，禁止转载题图来自 Pexels，基于 CC0 协议"}
{"title": "node.js 抓取网页内容（针对微信小程序云开发） ", "author": "Rolan", "pub_time": "2018-10-22 00:48", "content": "最近在研究微信小程序的云开发功能。云开发最大的好处就是不需要前端搭建服务器，可以使用云端能力，从零开始写出来一个能上线的微信小程序，避免了买服务器的开销，对于个人来尝试练手微信小程序从前端到后台的开发，还是一个不错的选择。可以做到一天就能上线一个微信小程序。云开发的优点云开发为开发者提供完整的云端支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。云开发目前提供三大基础能力支持：云函数：在云端运行的代码，微信私有协议天然鉴权，开发者只需编写自身业务逻辑代码数据库：一个既可在小程序前端操作，也能在云函数中读写的 JSON 数据库存储：在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理好了，介绍了这么多关于云开发的知识，感性的同学可以去研究研究。官方文档地址：https://developers.weixin.qq....网页内容抓取小程序是关于答题的，所以题目的来源是一个问题。上网搜，一个题目一个题目粘贴是一种方法，但是这样的重复工作，估计粘个10左右就想放弃了。所以想到了网页抓取。正好把之前学的node捡起来。必备工具：Cheerio。一个类似于服务器端JQuery的包。主要用它来分析和过滤抓取来的内容。node的fs模块。这个是node自带的模块，用来读写文件的。此处用来将解析好的数据写入json文件。Axios（非必须）。用来抓取网站的HTML网页。因为我要的数据是从网页上点击一个button后获取渲染的，所以直接访问这个网址是抓取不到的。无奈只能将想要的内容复制出来，存成字符串，去解析这个字符串。接下来就可以用npm init来初始化一个node项目，一路回车后，即可生成一个package.json文件。然后npm install --save axios cheerio安装cheerio和axios包。关键的是用cheerio来实现一个类似jquery的功能。只需将抓取到的内容cheerio.load(quesitons)一下即可，之后就可以按照jquery的操作取dom，组装你想要的数据了。最后用fs.writeFile将数据保存到json文件中，大功告成。具体代码如下：let axios = require(\"axios\");\r\n\r\nlet cheerio = require(\"cheerio\");\r\n\r\nlet fs = require(\"fs\");\r\n\r\n// 我的html结构大致如下，有很多条数据\r\nconst questions = `<li id=\"q1\" style=\"display: list-item;\">\r\n      <div class=\"questionWrapper\">\r\n        <div class=\"question\">举头望明月，__________。</div>\r\n        <div class=\"answer\" value=\"0\">\r\n          回首白云低\r\n        </div>\r\n        <div class=\"answer\" value=\"1\">\r\n          低头思故乡\r\n        </div>\r\n        <div class=\"answer\" value=\"0\">\r\n          当春乃发生\r\n        </div>\r\n        <div class=\"answer\" value=\"0\">\r\n          红掌拨清波\r\n        </div>\r\n      </div>\r\n    </li>\r\n    <li id=\"q2\">\r\n      <div class=\"questionWrapper\">\r\n        <div class=\"question\">__________，却话巴山夜雨时。</div>\r\n        <div class=\"answer\" value=\"1\">\r\n          何当共剪西窗烛\r\n        </div>\r\n        <div class=\"answer\" value=\"0\">\r\n          在天愿做比翼鸟\r\n        </div>\r\n        <div class=\"answer\" value=\"0\">\r\n          世味年来薄似纱\r\n        </div>\r\n        <div class=\"answer\" value=\"0\">\r\n          两岸青山相对出\r\n        </div>\r\n      </div>\r\n    </li>\r\n    ..........\r\n    `;\r\n    \r\nconst $ = cheerio.load(quesitons);\r\n\r\nvar arr = [];\r\n\r\nfor (var i = 0; i < 300; i++) {\r\n   var obj = {};\r\n   obj.quesitons = $(\"#q\" + i).find(\".question\").text();\r\n   obj.A = $($(\"#q\" + i).find(\".answer\")[0]).text();\r\n   obj.B = $($(\"#q\" + i).find(\".answer\")[1]).text();\r\n   obj.C = $($(\"#q\" + i).find(\".answer\")[2]).text();\r\n   obj.D = $($(\"#q\" + i).find(\".answer\")[3]).text();\r\n   obj.index = i + 1;\r\n   obj.answer =\r\n     $($(\"#q\" + i).find(\".answer\")[0]).attr(\"value\") == 1\r\n       ? \"A\"\r\n       : $($(\"#q\" + i).find(\".answer\")[1]).attr(\"value\") == 1\r\n         ? \"B\"\r\n         : $($(\"#q\" + i).find(\".answer\")[2]).attr(\"value\") == 1\r\n           ? \"C\"\r\n           : \"D\";\r\n   arr.push(obj);\r\n}\r\n\r\nfs.writeFile(\"poem.json\", JSON.stringify(arr), err => {\r\n   if (err) throw err;\r\n   console.log(\"json文件已成功保存！\");\r\n});保存到json后的文件格式如下，这样就可以通过json文件上传到云端服务器了。注意事项微信小程序云开发的数据库，上传json文件的数据格式需要注意一下，之前一直提示格式错误，后来才发现，JSON 数据不是数组，而是类似 JSON Lines，即各个记录对象之间使用 n 分隔，而非逗号。所以还需要对node写出来的json文件做一个小处理之后才能上传成功。"}
{"title": "万字解析小程序（3）：流量升级触发的“礼物经济” ", "author": "Rolan", "pub_time": "2018-10-29 00:06", "content": "本文观点：流量升级的原因：微信社交能力的开放，将渠道集中式的“公域流量”转化成用户为中心的“私域流量”。流量升级的结果：私域流量去中心化，导致了“赢家通吃”模式的失效。礼物经济的启示：礼物具有极强的“外部性”。互惠是一种方式，而不是目的。流量升级的原因2017年6月13日，我写了一篇“唱衰小程序”的文章。在小程序初期，有很多人的看法，是和我相同的。认为“小程序 PK APP”，胜算并不大。1年的时间，我明白了1件事情，擂台搭错了，你在旁边磕一吨焦糖瓜子儿，也等不出输赢。看小程序这个赛道，不该看 “小程序 PK APP”，也不该看“微信 PK Android”，而是看“微信 PK 智能手机”。为什么？移动浪潮的兴起，是因为“智能手机”的发展，带来了流量红利。小程序浪潮的兴起，是因为“微信”社交能力的开放，带来的流量升级。1. 追忆移动浪潮智能手机的出现，大大的提高了用户的终端保有量。它太简单便携，人手一部。可是换一个角度想，如果智能手机没有出现，世界会怎样？2018年，可能会有“9毽键盘”、“大屏”电脑，专供于三四线城市，老年人，小镇青年。没有智能手机，可能人手一部电脑。智能手机最性感的点，不在于让一些不触网的人触网，而在于流量的重新洗牌。这一点，只有它可以做到。流量迁移：流量从一个地方转移到另一个地方；流量洗牌：流量池结构打散，重排。人生海海，我们大部分时间在拼“定位”。一亩三分地，种了玉米就不能种高粱。你需要找到你的差异化优势，才能赢得竞争。可是某些浪潮下，这一亩三分地迅速洗牌，种了的玉米被全部拔了下来。要知道，乱世出英雄，混乱是阶梯。——姜太公公智能手机的洗牌，在于“使用场景”的洗牌，因为LBS，移动性等带来的随时随地的场景。这大大拓宽了整体的使用频次和使用时间。在这波使用场景的浪潮下，产生了各种场景解决方案的公司，比如：吃饭、出行、打发时间……微信的洗牌，在于“用户”结构的洗牌。这导致了用户接触信息、使用信息的方式的完全颠覆。微信社交能力的开放，带来了“用户”结构从渠道集中式的公域流量转化成用户为中心的私域流量。所以小程序的价值不在于小程序是什么？而在于微信开放了自己的终端价值，这个开放带来了什么？2. 为什么当初会错判？我们当初为啥会比较“小程序 PK APP”？为了形成“短平快”的判断，我们经常会贴标签。比如：实习生小姑娘一脸花痴的说“我的idol太帅了，简直是行走的荷尔蒙，我要给idol生孩子”  你说：“小鲜肉就是长得好看，实力都不行”。拜托，人家idol都特么42岁了好么，见了面，你都得叫人家一声大哥。（这个case并不是发生在我身上的哦，不要瞎想）“标签”，帮助我们迅速定义未知事物，却模糊了事物的全貌。如果牛在你心中的标签只有“黑白色”，那我问你是否见过牛尾巴是“666”的？你就不会知道，站在你眼前的这一只就是。标签化思考导致我们无法看到事物的全貌。在看小程序赛道时，很多人同样用了标签化思考，导致使用了错误的擂台。为了快速定义“小程序”，我们给它贴了一个“类似app”的标签。原来安卓、苹果手机上使用“微博APP”，现在微信中使用“微博小程序”。这样的“标签”，遮盖了什么全貌呢？为了更好的说明，我先来拆解下移动浪潮的全貌：应用层：用户使用的东西属于应用层。“APP”属于应用层。系统层：指操作系统。“android系统”，“iOS系统”属于系统层。应用的实现依赖于系统层。同一个应用，可能有“android版本”、“iOS版本”终端：“智能手机”是终端。终端带来了流量，流量和价值直接相关。对应到小程序赛道，这个全貌是什么呢？小程序浪潮下的终端是“微信”，开发者原来抢的是“移动手机”里的用户，现在抢的是“微信”里的用户。终端带来了流量，流量和价值直接相关。小程序能力开放前，“微信”里的用户你是很难碰到的。“微信”和“移动手机”在终端价值上，是一个级别的。万物皆有裂痕，那是风吹过来的地方。不要找风口上的猪，而是要看风里有什么能力。——姜太公公小结移动浪潮的兴起，是因为“智能手机”的发展，带来了流量红利。小程序浪潮的兴起，是因为“微信”社交能力的开放，带来的流量升级。流量升级的结果每一个小程序，都需要回答一个问题：“你是在玩儿微信里的公域流量还是私域流量？”如何判断公域还是私域？这里提供一个判断标准——根据用户的使用场景。如果用户的使用场景是“吃喝玩乐上班上课”，那就是在玩儿公域流量。如果用户的使用场景是“公众号 朋友圈 聊天”，那就是玩儿私域流量。小程序的流量升级，是因为出现了私域流量。私域流量的作用是什么呢？引起的后果是什么呢？NO.1 “赢家通吃”模式失效淘宝店主想多卖货，过去怎么办？需要买直通车，需要冲击金钻，需要提高淘宝搜索排名。这面向的是“公域流量”。现在怎么办？搞粉丝群，搞社群，把“公域流量”拉出一部分到自己的“私域流量”。为什么要搞私域流量？在选择爆炸的情况下，用户的每次选择都是站在一个茫茫的大海上。海上满满的都是船，用户会看到离他近的船，或者体量大的船。小船的被看到的机会，很少。私域流量的存在带来了什么？天崩地裂，大海被拆分成很多“浅水湖”。我是一艘小小船，用户在“大海”上看不到我，我就开进他身边的“浅水湖”。每日优鲜，玩儿的是公域流量。干死了无数生鲜电商，成为了用户在海上可以看的到的大船。而社区团购生鲜，玩儿的是私域流量，通过一个个宝妈建立的微信群，拼团买生鲜。公域流量是中心化的，这种模式下火的是“规模经济”。赢家因为规模增大带来了经济效益的提高，规模增大后，成本分摊得更低，获客成本更低。所谓赢家通吃。私域流量去中心化的，这一次，“规模效应”失效了。正所谓 场下格斗没套路，乱拳打死老师傅。微信中的“关系”形成了天然的壁垒，导致了去中心化。大海，因为这些关系的存在，变成了“浅水湖”。NO.2 用户行为的“驱动力”不再是“需求”Fogg模型阐述了如何让行为发生。Fogg模型认为一次行为的发生需要具备三个要素，缺一不可，这三个要素是： 动机、成本、触发点。举一个例子，一家饭馆想吸引用户走进来吃饭，这个行为的发生需要如下条件：动机：顾客想吃饭成本：顾客兜里有50块钱，这家饭馆人均消费30元。顾客有“支付的能力”触发点：顾客走到饭馆旁边，看到饭馆“吸引人的招牌”要完成这次行为，三个要素缺一不可。公域流量和私域流量的区别在于，这三个要素出现的顺序不同。公域流量是“动机”驱动行为，私域流量是“触发点”驱动行为。公域流量下，用户首先有了一个“动机”，然后打开了一个软件。用户想听歌，于是打开某易云音乐APP。用户记得它的位置在手机第2屏的第3排，然后轻松的找到，然后点开。私域流量下，用户通过“群”“聊天”“公众号”的触发点，获得了一个动机。好友发给我一个“毛衣”拼团链接，看着还挺实惠的。天气真的变冷了，我也需要一件。两者行为的驱动点完全不同。如果你是玩公域流量，你需要降低“主动触发”下的用户摩擦。在用户有一个动机的时候，帮助她迅速完成行为。做到用户所想即所得，让用户快速找到你的软件。用户心理想要的是，don’t make think，don’t make wait。如果你是玩私域流量，你需要降低“被动触发”下对用户的打扰。Emmm，这，真的有点复杂哦！会在第3节中重点讲哦！NO.3 流量池结构变为“沙漏”提到“流量池”，最容易想到什么？没错，用户分层。公域流量，流量池的结构是上图这种“鸡尾酒”型。用户是分层的，稳定的，忠实用户 、老用户、新用户各占有稳定的比例。做好这杯鸡尾酒，需要调好用户分配比例，讲的是“精细化运营”。 私域流量，流量池的结构是“沙漏”型。用户是动态的，流动的。小程序中，留存率20%是一个坎儿，而一个普通app，留存率动辄40%，50%，可见微信中的私域流量留存之低。私域流量做不了鸡尾酒，因为“底是漏的”。APP，强调的是转化率，强调的是一节节，分子小于分母的比例。转化率永远是小于1的，如果做到0.9，已经可以封神了。小程序中，强调的是分享，强调的是一层层，分子大于分母的裂变K值。K值大于1才算及格，1.1的100次方=13780 ，但是0.9的100次方=0.000027。分享带来了流量的复利，解决了留存的问题。分享，是整个私域流量池模型成立的根基。小结私域流量的作用是什么呢？引起的后果是什么呢？NO.1 “赢家通吃”模式失效NO.2 用户行为的“驱动力”不再是“需求”NO.3 公域流量池的结构是“鸡尾酒”型，私域流量池的结构是“沙漏”型。“礼物经济”给小程序的启示上文提到了私欲流量池结构变为“沙漏”。这里就不得不重点讲一下分享，你以为我要讲用户分享的18大驱动力？你以为我要讲裂变的起点是“人民币”和“社交币”？不，我们站的高一点，玩儿的大一点的。私域流量的分享其实在做的是“礼物经济”。礼物经济指的是提供商品或服务者并没有明确的预期回馈对象，也没有预期回馈的内容，有许多分享行为出自于非制式的习惯。同时，礼物的施与受之间已转换成一种未明确规定的义务，形成送礼者与收礼者之间的隐晦关系。礼物经济也被认为是一种债务经济，在这种经济中，交易者的目标是尽可能获得最多的礼物债务人，而不像在商品经济中以获取最大利润为目的。——百度百科从礼物经济的3大特点中，我们可以获得针对于小程序流量的玩法儿启示。1. 礼物经济中“互惠”是媒介，但不是目的互惠是一种语言。小明分享了一个“原价999，团购价9块9”的拼团链接给姜太公公。拼团成功后，小明和公公各自省了900元。请问，小明潜意识里，是希望不久的将来，姜太公公也帮助他省900元钱么？不会，小明对于姜太公公给他的回报没有预期。互惠，是一种媒介，是礼物经济中语言。就好像，见面问一句“你吃了没”。实际上，对方吃了啥，根本不care。对小程序开发者的启示：要让“互惠”成为一种沟通的方式，不要把互惠看的太重，否则会本末倒置。小程序的各种玩儿法“拼 抢 坎 送 比”，都是一种沟通的媒介。2. 交换礼物目的是——增加礼物的往来“礼物和商品交易的一个重要不同之处是，礼物在双方之间形成了情感纽带，商品交易却并不会带来任何必要的联系。我进入一家五金店，付钱给店员购买一根锯条然后离开，我可能再也不会和这名店员见面。疏离感是商品交易模式的基本原则，我们不想被打扰，所以如果这个店员一直不想我谈家里的事儿，我会换一家店，因为我只想买一个金条”—— 摘取自《分享经济的爆发》和商品销售不同，礼物赠予是要在双方建立亲密关系。当礼物在群体里流通，形成了一系列相互交织的关系网络，出现了一种去中心化的内聚力。礼物经济在于关系的维护，通过赠送礼物，强化了双方的关系。如果破坏了双方的关系，就不能称为礼物，比如：什么样的礼物会破坏朋友圈的关系？打卡、广告、利己分享。比如：什么样的礼物会破坏朋友的关系？没完没了集call。对小程序开发者的启示：当小程序的某种裂变玩儿法，用户已经麻木甚至厌恶时，这种玩儿法就已经跳出了礼物经济，它不能对用户的关系起到正向的作用。3. 礼物具有“外部性”礼物的商品价值和消费价值在很大程度上是无关紧要的。礼物的价值，通过“送”而达成。礼物的价值不在于礼物本身。一个没有送出去的礼物，没有价值。礼物这种东西，具有很强的外部性。回到互联网。小程序需要具有“外部性”，用户通过分享，感知到价值。用户没有分享，感知不到价值。只有这样，分享才能成为必备操作。拼多多：用户分享前，感受到这是一个卖低价商品的卖场。用户分享后，哇塞好便宜，感觉自己赚到了人民币。黑咔：用户分享前，感受到这是一个图片处理工具。用户分享后，哇塞好有趣大家一起玩，感觉自己赚到了社交币。对小程序开发者的启示：用户通过分享，“才能”感知到小程序的核心价值。“才能”这两个字儿很重要。小结私域流量的分享其实在做的是“礼物经济”，从礼物经济的特点中，我们可以获得针对于小程序的3大启示。总结这篇文章写的有点难哦，感谢你能看完，本文观点回顾：流量升级的原因：微信社交能力的开放，将渠道集中式的“公域流量”转化成用户为中心的“私域流量”。流量升级的结果：私域流量去中心化，导致了“赢家通吃”模式的失效。礼物经济的启示：礼物具有极强的“外部性”。互惠是一种方式，而不是目的。相关阅读万字解析小程序（1）：小程序 PK APP = 无解 ？万字解析小程序（2）：如何保证大海上可以看到“小船”？#专栏作家#姜太公公，微信号公众号：grandpa_jiang，人人都是产品经理专栏作家。产品老流氓，终身学习者。致力于研究产品方法论，解决小白PM的疑难杂症。本文原创发布于人人都是产品经理。未经许可，禁止转载题图来自 Pexels，基于 CC0 协议"}
{"title": "微信小程序：动画（Animation） ", "author": "Rolan", "pub_time": "2018-10-29 00:30", "content": "简单总结一下微信动画的实现及执行步骤。一、实现方式官方文档是这样说的：①创建一个动画实例 animation。②调用实例的方法来描述动画。③最后通过动画实例的 export 方法导出动画数据传递给组件的 animation 属性。因为小程序是数据驱动的，给这句话加上数字标注分为三步：前两步是定义一个动画并设置都要干什么，然后把这个设置好的“规则”扔给界面上的某个元素，让它按照这个规则执行。当然如果有多个元素的animation=\"{{ani}}\"，也都会执行这个动画规则。二、用例子说话新建一个小程序，把没用的删掉修改一下，做个简单例子，上图代码如下：index.wxml，一个helloworld，一个按钮<view class=\"container\">\r\n  <view class=\"usermotto\" animation=\"{{ani}}\">\r\n    <text class=\"user-motto\">{{motto}}</text>\r\n  </view>\r\n  <button bindtap='start'>动画</button>\r\n</view>index.wxss， 为了看着方便加了个边框.usermotto {\r\n  margin-top: 100px;\r\n  border: solid;\r\n}index.jsPage({\r\n  data: {\r\n    motto: 'Hello World',\r\n  },\r\n  start:function(){\r\n    var animation = wx.createAnimation({\r\n      duration: 4000,\r\n      timingFunction: 'ease',\r\n      delay: 1000\r\n    });\r\n    animation.opacity(0.2).translate(100, -100).step()\r\n    this.setData({\r\n      ani:  animation.export()\r\n    })\r\n  }\r\n}) 三、相关参数及方法简单介绍一下例子中的几个参数和方法（其他的详见官方文档）：      duration: 动画持续多少毫秒      timingFunction: “运动”的方式，例子中的 'ease'代表动画以低速开始，然后加快，在结束前变慢        delay: 多久后动画开始运行      opacity(0.2) 慢慢变透明      translate(100, -100) 向X轴移动100的同时向Y轴移动-100      step(): 一组动画完成，例如想让上例中的HelloWorld向右上方移动并变透明后，再次向左移动50可以继续写 animation.translateX( -50).step() , 作用就是向右上方移动和变透明是同时进行， 这两种变化完成之后才会进行向左运行的一步。"}
{"title": "megalo -- 网易考拉小程序解决方案 ", "author": "Rolan", "pub_time": "2018-10-29 00:33", "content": "megalo 是基于 Vue 的小程序框架（没错，又是基于 Vue 的小程序框架），但是它不仅仅支持微信小程序，还支持支付宝小程序，同时还支持在开发时使用更多 Vue 的特性。背景对于用户而言，小程序能提供更好的体验，但对于开发者而言，要让一个应用跑在多个平台上，则需要写多套代码。如何提高小程序开发效率让很多开发者都感到头疼。业界也有相关的解决方案，如 taro 和 mpvue，二者都是基于 react 和 vue 的开发模式实现，让开发者能够以他们熟知的 react 或 vue 模式来开发小程序，提高开发效率。mpvue 的发布给了我们很多启发，更早的时候，我们基于 RegularJS（网易自研的前端框架）开发了一个名为 mpregular 的小程序框架。在 mpregular 的开发和实际使用过程中，我们发现如果小程序框架所支持的特性只是原框架的子集（例如不支持 filter、模版复杂表达式等），开发效率会大打折扣。所以，我们在方案上做了很多尝试，目的是支持更多的特性，减少小程序与 H5 开发之前的差异。目前 mpregular 已经在考拉的小程序业务中大量应用，相关业务的开发同学纷纷表示，学习成本变低，跨端业务（H5 和小程序）的开发效率提升近一倍。方案经过一段时间验证后，我们决定把这套方案用 vue 再实现一次，一是为了适应技术栈的变更升级，二是为社区做一点微小的工作，于是就便有了 megalo。特性支持更多模版语法特性相比于其他小程序开发模式，由于支持更多特性，megalo 更贴近 Vue 原生的开发模式。从表格可以看到，megalo 最大的特点之一是，支持更多的 Vue 语法特性。这意味着，如果你有一个需求是要把现有的 Vue 代码迁移到小程序上，不需要太多改动。因为你的代码中可能大量使用 filter、scoped-slot、复杂表达式插值。基本语法支持 vue 的基本模版语法，包括 v-for 、 v-if 。class 和 style 的绑定方式没有限制，官方的用法都支持。<!-- v-if & v-for -->\r\n<div v-for=\"(item, i) in list\">\r\n  <div v-if=\"isEven(i)\">{{ i }} - {{ item }}</div>\r\n</div>\r\n\r\n<!-- style & class -->\r\n<div :class=\"classObject\"></div>\r\n<div :class=\"{ active: true }\"></div>\r\n<div :class=\"[activeClass, errorClass]\"></div>\r\n<div :style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"></div>\r\n<div :style=\"styleObject\"></div>\r\n<div :style=\"[baseStyles, overridingStyles]\"></div>\r\n复制代码slot & scoped-slot支持 slot 和 scoped-slot。<div>\r\n  <Container>\r\n    <Card>\r\n      <div slot=\"head\"> {{ title }} </div>\r\n      <div> I'm body </div>\r\n      <div slot=\"foot\"> I'm footer </div>\r\n    </Card>\r\n  </Container>\r\n  <List :list=\"list\">\r\n    <span slot-scope=\"scopeProps\">{{ scopeProps.item.label }}</span>\r\n  </List>\r\n<div>\r\n复制代码复杂表达式 & filter可以在模版里面写复杂表达式、调用实例上的方法，当然也可以用更简洁的 filter 语法，跟平时用 Vue 开发一样。<div>\r\n  <div>{{ message.toUpperCase() }}</div>\r\n  <div>{{ toUpperCase( message ) }</div>\r\n  <div>{{ message | toUpperCase }}</div>\r\n</div>\r\n复制代码v-html要使用 v-html 需要添加插件 @megalo/vhtml-plugin ，并引入模版解析库 octoparse ，在页面入口安装一下插件：import Vue from 'vue'\r\nimport VHtmlPlugin from '@megalo/vhtml-plugin'\r\n\r\nVue.use(VHtmlPlugin)\r\n复制代码利用 v-html 指令然后就可以在小程序中渲染 html 了。<div v-html=\"'<h1>megalo</h1>'\"></div>\r\n复制代码更好的数据更新性能小程序的官方明确说明，在调用 setData 更新数据时如果数据量过大或频率更高，会引发性能问题。megalo 在框架底层已经帮开发者对此进行优化，每次数据发生变化时，megalo 只会将视图中要展示的、且发生变化的数据进行更新，将 setData 的数据更新量最小化，同时对更新数据频率进行了限制。像下面这段代码，如果视图只需要展示 user.name 这个字段的话，在进行数据同步时只会将 user.name 这个字符串更新到视图层，其余字段是不会同步到小程序的对象上的。<div>{{ user.name }}</div>\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      user: {\r\n        name: 'kaola',\r\n        age: 3,\r\n        favorite: [\r\n          'encalyptus',\r\n          'sleeping'\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}\r\n</script>\r\n复制代码支持更多平台今年以来，各大流量平台都在小程序领域有所动作，蚂蚁金服成立小程序事业部，百度、今日头条也纷纷推出自己的小程序。megalo 目前已经支持微信和支付宝小程序，百度小程序等平台的支持也在计划当中。微信和支付宝小程序使用使用 megalo 开发非常简单，只需在常见的 Vue 项目 webpack 构建配置上配置 @megalo/target 并引入 @magalo/template-compiler 即可。如果需要编译成支付宝小程序，只需要设置 platform: 'alipay' 。const { createMegaloTarget } = require('@megalo/target');\r\nmodule.exports = {\r\n  target: createMegaloTarget( {\r\n    compiler: require('@megalo/template-compiler'),\r\n    platform: 'wechat'\r\n  } )\r\n  // 其他 webpack 配置，如 vue-loader 等\r\n};\r\n复制代码接着，就可以像开发 Vue 应用一样去开发小程序。示例可以参考 megalo-demo 。如果想用 typescript 进行开发，可以参考 megalo-ts-simple 。实现小程序在结构上主要有 Service(JavascriptCore) 和 View(WebView) 两部分组成（微信和支付宝小程序有着类似的结构，下文均以微信小程序为例，并简称为小程序），分别运行在独立的环境上，之间不具备共享数据通道，二者的通信方式是将数据封装在 js 脚本后传递。Page 实例就在 Service 中，通过 setData 方法将数据传递到 View。View 则通过事件绑定将视图层触发的事件传递给 Service。Service 层中无法操作视图层的 DOM 节点。实际开发中，小程序的逻辑和模版需要写在 .js 和 .wxml 两个文件中，分别在 Service 和 View 中执行。如果要将在浏览器端的 Vue 放到小程序中跑，需要将 .vue 文件中的 template 片段转换成 .wxml 文件，并对 Vue 的 runtime 部分改造，将其中的 DOM 操作移除，通过小程序的 Service 中的页面实例上的 API 与 View 进行通信。最终的运行效果是，当 Vue 的 vm 上数据发生更新时，会重新渲染出 vdom，在的 patch 阶段，框架不在去操作 DOM，而是通过 Page 上的 setData 方法将变化的数据更新到视图层，完成 Vue 和 小程序的视图更新，这就是 megalo 底层所做的工作。megalo 的实现，主要分成以下四个部分，下面本文将对每个部分进行介绍。生命周期小程序中，每一个页面（Page）是一个实例，页面的生命周期钩子有很多，但和实例创建的两个关键生命周期分别是 onLoad 和 onReady ，它们分别在「 页面加载，实例初始化后 」和「 初次页面渲染完成 」时触发。Vue 的实例要和小程序实例建立起联系，则需要在小程序 Page 实例创建好以后，即在 onLoad 的钩子函数里，去初始化对应的 Vue 根实例，将页面实例 page 挂载到 Vue 实例的 $mp 上，此时也会触发 Vue 的生命周期钩子 created 。在页面初次渲染完成后，则会调用 $mount 方法，与在浏览器中挂载 DOM 节点不同，这里会将 Vue 实例上的数据初始化到视图层中。由此，Vue 实例就与小程序的 Page 实建立起了联系。除了这两个生命周期钩子以外，像小程序的 onShow 、 onHide 等生命周期钩子在触发时，也会尝试触发 Vue 实例上的同名钩子函数，实现两种实例间生命周期的绑定。在小程序页面退出销毁时，会触发 onUnload 钩子，此时 Vue 的实例也会跟着销毁。模版转换小程序有它特有的模版语法和文件名后缀，所以在构建阶段，我们会将 .vue 文件中的 template 部分提取出来并转换成对应的 .wxml 文件。标签名、语法都会进行相应的转换，如图所示。这一部分是在构建阶段完成的，这意味着，megalo 不支持 render 函数的写法。在构建阶段除了将模版转换成 .wxml 以外，还需要对模版中的每个节点进行转换，并在生产的 render 函数中加入相关的节点标记信息，数据映射和事件代理需要这些信息。数据映射由于无法直接操作视图层的 DOM，所以我们只能利用 page.setData 这个方法完成数据到视图层的映射。最简单暴力的方法，是将 Vue 实例上的所有数据统统收集起来，通过调用 page.setData 方法更新 Page 实例的数据，这个方法会将数据挂载到 Page 实例上，同时也会把数据传递给视图层。但是，这种粗暴的更新方式有两个弊端：i. 全量更新 vm 上的数据是无法区分哪些数据是视图层需要的，冗余无用的数据会被更新到 page 实例上。像下图这个例子，视图层只需要展现两个字符串，如果 vm 上还存在两个大数组，它们也会被无脑同步到 page 上。ii. 同步到 page 实例上的数据其实就是原始数据，并不是视图层实际要展示的数据，所以展示数据的格式化与转换需要依赖小程序模版的解析能力，导致一些 Vue 支持的模版语法无法支持，例如 filter、复杂表达式、传递 class 对象等。当然以上两个弊端不会对功能开发造成影响，但在实际的业务开发中，会让开发体验不一致，尤其是 h5 代码迁移到小程序时，对效率影响颇大。为了解决这个问题，megalo 采用另一种方式，即将 render 时生成的 vnode 上的数据更新到视图，vnode 的数据就是已经处理好的展示数据，根据 vnode 构造每个节点的数据结构，再同步到视图层。例如以下这段代码，在构建阶段 megalo 会对每个节点进行标记，使 render 时生成的 vnode 和模版中每个插值能够对应上。<!-- 编译前的 Vue 模版 .vue -->\r\n<div :class=“classObj”>\r\n  {{ date | format( 'YYYY' ) }}\r\n</div>\r\n\r\n<!-- 编译后的小程序模版 .wxml -->\r\n<view class=\"{{ node_1.class }}\">\r\n  {{ node_1.text }}\r\n</view>\r\n复制代码以这种方式实现的数据映射，只有视图层需要的两个字符串数据会被同步到小程序的 Page 实例上，其余数据则被认为与视图无关则不会进行同步。export default {\r\n  data() {\r\n    return {\r\n      classObj: {\r\n        'kaola': true\r\n      },\r\n      date: new Date(),\r\n      users: {\r\n        // big object\r\n      }\r\n    }\r\n  }\r\n}\r\n复制代码如下图所示，Vue 渲染出来的 vnode 会被以特定的数据结构映射到 page 上，再同步到小程序视图层。以这种方式实现的数据映射，可以更好地支持 Vue 的模版语法，且更大限度地减少更新视图时传输的数据量，从框架层面规避 setData 的性能问题。事件代理小程序视图触发事件后，会将 event 对象通知到 Page 实例，那么我们只需要将视图层中所有的事件都代理到 page.proxy 这个方法中，然后再靠这个方法从 Vue 的实例树上找到对应的 vm和 handler 做事件处理。为了实现这一目的，在构建阶段对模版进行编译时，除了要将事件监听方法转换为 proxy 以外，还需要通过 data- 在元素上标记对应的组件 compid 和节点 nodeid。<!-- 编译前的 Vue 模版 .vue -->\r\n<div @click=\"onClick\"></div>\r\n\r\n<!-- 编译后的小程序模版 .wxml -->\r\n<view bindtap=\"proxy\" data-compid=\"0\" data-nodeid=\"0\"></view>\r\n复制代码事件触发时，proxy 方法会从 event 对象上获取对应的 id 信息和事件类型，进而从 Vue 的根 vm 开始查找，最终在 vnode 上找到对应的 handler 并执行事件处理，完成小程序事件到 Vue 实例的事件代理。现在与未来目前，megalo 已经逐步在考拉的小程序应用开发中投入使用，但 megalo 的数据映射方案早已通过 mpregular 在考拉的大量小程序应用中得到了验证。现在，megalo 支持 typescript 开发，支持支付宝小程序。百度智能小程序的支持也在计划之内，同时，我们还计划开发一个兼容个平台的 UI 组件库、API 库，尝试将跨 H5 和各小程序平台的应用开发之间的差异最小化，提升开发效率。"}
{"title": "微信小程序国密算法实现库sm-crypto ", "author": "Rolan", "pub_time": "2018-10-29 00:43", "content": "国密算法是国家密码局制定标准的一系列算法，主要有SM1，SM2，SM3，SM4，密钥长度和分组长度均为128位。其中：SM1 为对称加密。其加密强度与AES相当。该算法不公开，调用该算法时，需要通过加密芯片的接口进行调用。SM2为非对称加密，基于ECC。该算法已公开。由于该算法基于ECC，故其签名速度与秘钥生成速度都快于RSA。ECC 256位（SM2采用的就是ECC 256位的一种）安全强度比RSA 2048位高，但运算速度快于RSA。SM3 消息摘要。可以用MD5作为对比理解。该算法已公开。校验结果为256位。SM4 无线局域网标准的分组数据算法。对称加密，密钥长度和分组长度均为128位。sm-crypto可以在微信小程序中实现SM2、SM3、SM4国密算法。使用安装 sm-crypto从小程序基础库版本 2.2.1 或以上、及开发者工具 1.02.1808300 或以上开始，小程序支持使用 npm 安装第三方包。npm install --save miniprogram-sm-crypto\r\nsm2获取密钥对const sm2 = require('miniprogram-sm-crypto').sm2;\r\n\r\nlet keypair = sm2.generateKeyPairHex();\r\n\r\npublicKey = keypair.publicKey; // 公钥\r\nprivateKey = keypair.privateKey; // 私钥\r\n加密解密const sm2 = require('miniprogram-sm-crypto').sm2;\r\nconst cipherMode = 1; // 1 - C1C3C2，0 - C1C2C3，默认为1\r\n\r\nlet encryptData = sm2.doEncrypt(msgString, publicKey, cipherMode); // 加密结果\r\nlet decryptData = sm2.doDecrypt(encryptData, privateKey, cipherMode); // 解密结果\r\n签名验签const sm2 = require('miniprogram-sm-crypto').sm2;\r\n\r\n// 纯签名 + 生成椭圆曲线点\r\nlet sigValueHex = sm2.doSignature(msg, privateKey); // 签名\r\nlet verifyResult = sm2.doVerifySignature(msg, sigValueHex, publicKey); // 验签结果\r\n\r\n// 纯签名\r\nlet sigValueHex2 = sm2.doSignature(msg, privateKey, {\r\n    pointPool: [sm2.getPoint(), sm2.getPoint(), sm2.getPoint(), sm2.getPoint()], // 传入事先已生成好的椭圆曲线点，可加快签名速度\r\n}); // 签名\r\nlet verifyResult2 = sm2.doVerifySignature(msg, sigValueHex2, publicKey); // 验签结果\r\n\r\n// 纯签名 + 生成椭圆曲线点 + der编解码\r\nlet sigValueHex3 = sm2.doSignature(msg, privateKey, {\r\n    der: true,\r\n}); // 签名\r\nlet verifyResult3 = sm2.doVerifySignature(msg, sigValueHex3, publicKey, {\r\n    der: true,\r\n}); // 验签结果\r\n\r\n// 纯签名 + 生成椭圆曲线点 + sm3杂凑\r\nlet sigValueHex4 = sm2.doSignature(msg, privateKey, {\r\n    hash: true,\r\n}); // 签名\r\nlet verifyResult4 = sm2.doVerifySignature(msg, sigValueHex4, publicKey, {\r\n    hash: true,\r\n}); // 验签结果\r\n\r\n// 纯签名 + 生成椭圆曲线点 + sm3杂凑（不做公钥推导）\r\nlet sigValueHex5 = sm2.doSignature(msg, privateKey, {\r\n    hash: true,\r\n    publicKey, // 传入公钥的话，可以去掉sm3杂凑中推导公钥的过程，速度会比纯签名 + 生成椭圆曲线点 + sm3杂凑快\r\n});\r\nlet verifyResult5 = sm2.doVerifySignature(msg, sigValueHex5, publicKey, {\r\n    hash: true,\r\n    publicKey,\r\n});\r\n获取椭圆曲线点const sm2 = require('miniprogram-sm-crypto').sm2;\r\n\r\nlet poin = sm2.getPoint(); // 获取一个椭圆曲线点，可在sm2签名时传入\r\nsm3const sm3 = require('miniprogram-sm-crypto').sm3;\r\n\r\nlet hashData = sm3('abc'); // 杂凑\r\nsm4加密const sm4 = require('miniprogram-sm-crypto').sm4;\r\nconst key = [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10];\r\n\r\nlet encryptData = sm4.encrypt([0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10], key); // 加密\r\n解密const sm4 = require('miniprogram-sm-crypto').sm4;\r\nconst key = [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10];\r\n\r\nlet decryptData = sm4.decrypt([0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e, 0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46], key); // 解密\r\n\r\n其他sm-crypto项目地址：https://github.com/wechat-min..."}
{"title": "小程序选人控件 - 仿企业微信实现多层级无规则嵌套 ", "author": "Rolan", "pub_time": "2018-10-30 00:12", "content": "在很多系统中都有选择联系人的需求，市面上也没什么好的参照，产品经理看企业微信的选人挺好用的，就说参照这个做一个吧。。。\r\n\r\n算了，还是试着做吧，企业微信的选人的确做的挺好，不得不佩服。\r\n先看看效果图吧，多层级无规律的嵌套都能搞定\r\n\r\n一、设计解读\r\n\r\n整个界面分为三部分：\r\n\r\n最上面的返回上一层按钮\r\n中间的显示部门、人员的列表\r\n最下面显示和操作已选人员的 footer。\r\n\r\n为什么加一个返回上一层按钮呢？\r\n我也觉得比较丑，但小程序无法直接控制左上角返回键（自定义 Title 貌似可以，没试过），点左上角的返回箭头的话就退出选人控件到上个页面了。\r\n我们的需求是点击一个文件夹，通过刷新当前列表进入下一级目录，感觉像是又进了一个页面，但其实并没有，只是列表的数据变化了。由此实现不定层级、无规律的部门和人员嵌套的支持。\r\n比如先点击了首屏数据的第二个 item，它的 index 是 1 ，就将 1 存入  indexList ；返回上一层时将最后一个元素删除。\r\n当勾选了某个人或部门时，会在底部的框中显示所有已选人员或部门的名字，当文字超过屏幕宽度时可以向右无限滑动，底部 footer 始终保持一行。\r\n最终选择的人以底部 footer 里显示的为准，点击确定时根据业务需要将已选人员数据发送给需要的界面。\r\n二、功能逻辑分析\r\n先看看数据格式\r\n{\r\n  id: TEACHER_ID,\r\n  name: '教师',\r\n  parentId: '',\r\n  checked: false,\r\n  isPeople: false,\r\n  children: [\r\n    {\r\n      id: TEACHER_DEPARTMENT_ID,\r\n      name: '部门',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n    {\r\n      id: TEACHER_SUBJECT_ID,\r\n      name: '学科',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n    {\r\n      id: TEACHER_GRADECLASS_ID,\r\n      name: '年级班级',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n  ]\r\n}\r\n复制代码所有的数据组成一个数据树，子节点嵌套在父节点下。\r\nid,  name 不说了，parentId 指明它的父节点，children 包含它的所有子节点，checked 用来判断勾选状态，isPeople 判断是部门还是人员，因为两者的图标不一样。\r\n注意：\r\n本控件采用了数据分步加载的模式，除了最上层固定的几个分类，其他的每层数据都是点击具体的部门后才去请求服务器加载本部门下的数据的，然后再拼接到原始数据树上。这样可以提高加载速度，提升用户体验。\r\n我也试了一次性把所有数据都拉下来，一是太慢，得三五秒，二是数据量太大的话（我这里应该是超过1000，阈值多少没测过），setData() 的时候就会报错：\r\n\r\n超过最大长度了。。。所以只能分步加载数据。\r\n当然如果你的数据量小，几十人或几百人，也可以选择一次性加载。\r\n这个控件逻辑上还是比较复杂的，要考虑的细节太多……下面梳理一下主要的逻辑点\r\n主要逻辑点\r\n1. 需要一个数组存储所有被点击的部门在当前列表的索引 index ，这里用 indexList 表示\r\n点击某个部门进入下一层目录时，将被点击部门的 index 索引 push  进 indexList  中。点击返回上一层按钮时，删除  indexList 中最后一个元素。\r\n2. 要动态的更新当前列表 currentList\r\n每进入新的一层，或返回上一层，都需要刷新 currentList 来实现页面的更新。知道下一层数据很容易，直接取被点击 item 的 children 赋值给 currentList 即可。\r\n但如何还原上一层的数据呢？\r\n第一点记录的 indexList 就发挥作用了，原始数据树为 originalList，循环遍历 indexList ，根据索引依次取出每层的 currentList 直到 indexList 的最后一个元素，就得到了返回上一层需要显示的数据。\r\n3. 每一次勾选或取消选中都要更新原始的数据树 originalList\r\n页面是根据每个 item 的 checked 属性判断是否选中的，所以每次改变勾选状态都要设置被改变的 item 的 checked 属性，然后更新 originalList。这样即使返回上一层了，再进到当前层级选中状态还会被保留，否则刷新 currentList 后已选状态将丢失。\r\n4. 列表中选择状态的改变与底部 footer 的双联动\r\n我们期望的效果是，选中currentList 列表的某一项，底部 footer 会自动添加被选人的名字。取消选中，底部 footer 也会自动删除。\r\n也可以通过 footer 来删除已选人，点击 footer 中人名，会将此人从已选列表中删除，currentList 列表中也会自动取消勾选状态。\r\n嗯，这个功能比较耗性能，每一次都需要大量的计算。考虑到性能和速度因素，本次只做了从 footer 删除只更新 currentList 的勾选状态。\r\n什么意思呢？假如有两层，A 和 B，B 是 A 的下一层数据，即 A 是 B 的父节点。在 A 中选中了一个部门 校长室，点击下一层到 B，在 B 中又选了两个人 张三 和 李四，这时底部 footer 里显示的应该是三个： 校长室、 张三 、 李四。此时点击 footer 的 张三 ， footer 会把 张三 删除，中间列表中 张三 会被置为未选中状态，这没问题。但点击 footer 的 校长室 , 在 footer 中是把  校长室 删除了，但再返回到上一层时，中间列表中的 校长室 依然是勾选状态，因为此时没有更新原始数据树 originalList。如果觉得这是个 bug, 可以加个更新 originalList 的操作。这样就要遍历  originalList 的每个元素判断与本次删除的 id 是否相等，然后改变 checked 值，如果数据量很大，会非常慢。我做了妥协……\r\n关键的逻辑就这四块了，当然还有很多小细节，直接看代码吧，注释写的也比较详细。\r\n三、代码\r\n目录结构：\r\n\r\nfooter 文件夹下是抽离出的 footer 组件，userSelect 是选人控件的主要逻辑。把这几个文件复制过去就可以用了。\r\n把 userSelect.js 里网络请求的代码替换为你的请求代码，注意数据的字段名是否一致。\r\nuserSelect 的代码\r\n\r\nuserSelect.js\r\n\r\n\r\nimport API from '../../../utils/API.js'\r\nimport ArrayUtils from '../../../utils/ArrayUtils.js'\r\nimport EventBus from '../../../components/NotificationCenter/WxNotificationCenter.js'\r\n\r\nlet TEACHER_ID = 'teacher';\r\nlet TEACHER_DEPARTMENT_ID = 't_department';\r\nlet TEACHER_SUBJECT_ID = 't_subject';\r\nlet TEACHER_GRADECLASS_ID = 't_gradeclass';\r\nlet STUDENT_ID = 'student';\r\nlet PARENT_ID = 'parent'\r\n\r\nlet TEACHER = {\r\n  id: TEACHER_ID,\r\n  name: '教师',\r\n  parentId: '',\r\n  checked: false,\r\n  isPeople: false,\r\n  children: [\r\n    {\r\n      id: TEACHER_DEPARTMENT_ID,\r\n      name: '部门',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n    {\r\n      id: TEACHER_SUBJECT_ID,\r\n      name: '学科',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n    {\r\n      id: TEACHER_GRADECLASS_ID,\r\n      name: '年级班级',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n  ]\r\n}\r\nlet STUDENT = {\r\n  id: STUDENT_ID,\r\n  name: '学生',\r\n  parentId: '',\r\n  checked: false,\r\n  isPeople: false,\r\n  children: []\r\n}\r\nlet PARENT = {\r\n  id: PARENT_ID,\r\n  name: '家长',\r\n  parentId: '',\r\n  checked: false,\r\n  isPeople: false,\r\n  children: []\r\n}\r\nlet ORIGINAL_DATA = [\r\n  TEACHER, STUDENT, PARENT\r\n]\r\n\r\nPage({\r\n  data: {\r\n    currentList: [], //当前展示的列表\r\n    selectList: [],  //已选择的元素列表\r\n    originalList: [], //最原始的数据列表\r\n    indexList: [],  //存储目录层级的数组，用于准确的返回上一层\r\n    selectList: [],  //已选中的人员列表\r\n  },\r\n\r\n  onLoad: function (options) {\r\n    wx.setNavigationBarTitle({\r\n      title: '选人控件'\r\n    })\r\n    this.init();\r\n  },\r\n\r\n  init(){\r\n    //用户的单位id\r\n    this.unitId = getApp().globalData.userInfo.unitId;\r\n    //用户类型\r\n    this.userType = 0;\r\n    //上次选中的列表，用于判断是不是取消选中了\r\n    this.lastTimeSelect = []\r\n\r\n    this.setData({\r\n      currentList: ORIGINAL_DATA, //当前展示的列表\r\n      originalList: ORIGINAL_DATA, //最原始的数据列表\r\n    })\r\n  },\r\n\r\n  clickItem(res){\r\n    console.log(res)\r\n    let index = res.currentTarget.id;\r\n    let item = this.data.currentList[index]\r\n\r\n    console.log(\"item\", item)\r\n\r\n    if (!item.isPeople) {\r\n      //点击教师，下一层数据是写死的，不用请求接口\r\n      if (item.id === TEACHER_ID) {\r\n        this.userType = 2;\r\n        this.setData({\r\n          currentList: item.children\r\n        })\r\n      } else if (item.id === TEACHER_SUBJECT_ID) {\r\n        if (item.children.length === 0){\r\n          this._getTeacherSubjectData()\r\n        }else{\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      } else if (item.id === TEACHER_DEPARTMENT_ID) {\r\n        if (item.children.length === 0) {\r\n          this._getTeacherDepartmentData()\r\n        } else {\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      } else if (item.id === TEACHER_GRADECLASS_ID) {\r\n        if (item.children.length === 0) {\r\n          this._getTeacherGradeClassData()\r\n        } else {\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      } else if (item.id === STUDENT_ID) {\r\n        this.userType = 1;\r\n        if (item.children.length === 0) {\r\n          this._getStudentGradeClassData()\r\n        } else {\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      } else if (item.id === PARENT_ID) {\r\n        this.userType = 3;\r\n        if (item.children.length === 0) {\r\n          this._getParentGradeClassData()\r\n        } else {\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      } else{\r\n        //children的长度为0时，请求服务器\r\n        if(item.children.length === 0){\r\n          this._getUserByGroup(item)\r\n        }else{\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      }\r\n\r\n      //将当前的索引存入索引目录中。索引多一个表示目录多一级\r\n      let indexes = this.data.indexList\r\n      indexes.push(index)\r\n      //是目录不是具体的用户\r\n      this.setData({\r\n        indexList: indexes\r\n      })\r\n      //清空上次选中的元素列表，并设置上一层的选中状态给lastTimeSelect\r\n      this.setLastTimeSelectList();\r\n    }\r\n  },\r\n\r\n\r\n  //返回按钮\r\n  goBack() {\r\n    let indexList = this.data.indexList\r\n    if (indexList.length > 0) {\r\n      //返回时删掉最后一个索引\r\n      indexList.pop()\r\n      if (indexList.length == 0) {\r\n        //indexList长度为0说明回到了最顶层\r\n        this.setData({\r\n          currentList: this.data.originalList,\r\n          indexList: indexList\r\n        })\r\n      } else {\r\n        //循环将当前索引的对应数组赋值给currentList\r\n        let list = this.data.originalList\r\n        for (let i = 0; i < indexList.length; i++) {\r\n          let index = indexList[i]\r\n          list = list[index].children\r\n        }\r\n        this.setData({\r\n          currentList: list,\r\n          indexList: indexList\r\n        })\r\n      }\r\n      //清空上次选中的元素列表，并设置上一层的选中状态给lastTimeSelect\r\n      this.setLastTimeSelectList();\r\n    }\r\n  },\r\n\r\n  //清空上次选中的元素列表，并设置上一层的选中状态给lastTimeSelect\r\n  setLastTimeSelectList(){\r\n    this.lastTimeSelect = []\r\n    this.data.currentList.forEach(item => {\r\n      if (item.checked) {\r\n        this.lastTimeSelect.push(item)\r\n      }\r\n    })\r\n  },\r\n\r\n  //获取教师部门数据\r\n  _getTeacherDepartmentData() {\r\n    this._commonRequestMethod(2, 'department')\r\n  },\r\n\r\n  //请求教师的学科数据\r\n  _getTeacherSubjectData(){\r\n    this._commonRequestMethod(2, 'subject')\r\n  },\r\n\r\n  //请求教师的年级班级\r\n  _getTeacherGradeClassData() {\r\n    this._commonRequestMethod(2, 'gradeclass')\r\n  },\r\n\r\n  //请求学生的年级班级\r\n  _getStudentGradeClassData() {\r\n    this._commonRequestMethod(1, 'gradeclass')\r\n  },\r\n\r\n  //请求家长的年级班级\r\n  _getParentGradeClassData() {\r\n    this._commonRequestMethod(3, 'gradeclass')\r\n  },\r\n\r\n  //根据部门查询人\r\n  _getUserByGroup(item){\r\n    let params = {\r\n      userType: this.userType,\r\n      unitId: this.unitId,\r\n      groupType: item.type,\r\n      groupId: item.id\r\n    }\r\n    console.log('params', params)\r\n    getApp().get(API.selectUserByGroup(), params, result => {\r\n      console.log('result', result)\r\n      let list = this.transformData(result.data.data, item.id)\r\n      this.setData({\r\n        currentList: list\r\n      })\r\n      this.addList2DataTree()\r\n      //清空上次选中的元素列表，并设置上一层的选中状态给lastTimeSelect。写在这里防止异步请求时执行顺序问题\r\n      this.setLastTimeSelectList();\r\n    })\r\n  },\r\n\r\n  //通用的请求部门方法\r\n  _commonRequestMethod(userType, groupType){\r\n    wx.showLoading({\r\n      title: '',\r\n    })\r\n    let params = {\r\n      userType: userType,\r\n      unitId: this.unitId,\r\n      groupType: groupType\r\n    }\r\n    console.log('params', params)\r\n    getApp().get(API.selectUsersByUserGroupsTree(), params, result => {\r\n      console.log('result', result)\r\n      wx.hideLoading()\r\n      let data = result.data.data\r\n      this.setData({\r\n        currentList: data\r\n      })\r\n      this.addList2DataTree();\r\n      //清空上次选中的元素列表，并设置上一层的选中状态给lastTimeSelect。写在这里防止异步请求时执行顺序问题\r\n      this.setLastTimeSelectList();\r\n    })\r\n  },\r\n\r\n  //将请求的数据转化为需要的格式\r\n  transformData(list, parentId){\r\n    //先将数据转化为固定的格式\r\n    let newList = []\r\n    for(let i=0; i<list.length; i++){\r\n      let item = list[i]\r\n      newList.push({\r\n        id: item.id,\r\n        name: item.realName,\r\n        parentId: parentId,\r\n        checked: false,\r\n        isPeople: true,\r\n        userType: item.userType,\r\n        gender: item.gender,\r\n        children: []\r\n      })\r\n    }\r\n    return newList;\r\n  },\r\n\r\n  //将当前列表挂载在原数据树上, 目前支持5层目录，如需更多接着往下写就好\r\n  addList2DataTree(){\r\n    let currentList = this.data.currentList;\r\n    let originalList = this.data.originalList;\r\n    let indexes = this.data.indexList\r\n    switch (indexes.length){\r\n      case 1: \r\n        originalList[indexes[0]].children = currentList\r\n        break;\r\n      case 2:\r\n        originalList[indexes[0]].children[indexes[1]].children = currentList\r\n        break;\r\n      case 3:\r\n        originalList[indexes[0]].children[indexes[1]].children[indexes[2]].children = currentList\r\n        break;\r\n      case 4:\r\n        originalList[indexes[0]].children[indexes[1]].children[indexes[2]].children[indexes[3]].children = currentList\r\n        break;\r\n      case 5:\r\n        originalList[indexes[0]].children[indexes[1]].children[indexes[2]].children[indexes[3]].children[indexes[4]].children = currentList\r\n        break;\r\n    }\r\n\r\n    this.setData({\r\n      originalList: originalList\r\n    })\r\n    console.log(\"originalList\", originalList)\r\n  },\r\n\r\n  //选框变化回调\r\n  checkChange(res){\r\n    console.log(res)\r\n    let values = res.detail.value\r\n    let selectItems = []\r\n    //将值取出拼接成 id，name 格式\r\n    values.forEach(value => {\r\n      let arrs = value.split(\",\")\r\n      selectItems.push({id: arrs[0], name: arrs[1]})\r\n    })\r\n    console.log(\"selectItems\", selectItems)\r\n    console.log(\"lastTimeSelect\", this.lastTimeSelect)\r\n    \r\n    //将本次选择的与上次选择的比对，本次比上次多说明新增了，本次比上次少说明删除了，找出被删除的那条数据，在footer中也删除\r\n    if (selectItems.length > this.lastTimeSelect.length){\r\n      //将 selectList 与 selectItems 拼接并去重\r\n      let newList = this.data.selectList.concat(selectItems)\r\n      newList = ArrayUtils.checkRepeat(newList)\r\n      this.setData({\r\n        selectList: newList\r\n      })\r\n    }else{\r\n      //找出取消勾选的item，从selectList中删除\r\n      //比对出取消勾选的是哪个元素\r\n      let diffItem = {}\r\n      this.lastTimeSelect.forEach(item => {\r\n        let flag = false;\r\n        selectItems.forEach(item2 => {\r\n          if(item.id === item2.id){\r\n            flag = true\r\n          }\r\n        })\r\n        if(!flag){\r\n          diffItem = item\r\n          console.log(\"diff=\", item)\r\n        }\r\n      })\r\n      //找出被删除的元素在 selectList 中的位置\r\n      let list = this.data.selectList\r\n      let delIndex = 0;\r\n      for(let i=0; i<list.length; i++){\r\n        if (list[i].id === diffItem.id){\r\n          delIndex = i;\r\n          break;\r\n        }\r\n      }\r\n      //从list中删除这个元素\r\n      list.splice(delIndex, 1)\r\n      this.setData({\r\n        selectList: list\r\n      })\r\n    }\r\n    console.log(\"selectList\", this.data.selectList)\r\n    //更新 currentList 选中状态并重新挂载在数据树上，以保存选择状态\r\n    this.updateCurrentList(this.data.currentList, this.data.selectList)\r\n  },\r\n\r\n  //footer点击删除回调\r\n  footerDelete(res){\r\n    console.log(res)\r\n    this.setData({\r\n      selectList: res.detail.selectList\r\n    })\r\n\r\n    console.log('selectList', this.data.selectList)\r\n    this.updateCurrentList(this.data.currentList, res.detail.selectList)\r\n  },\r\n\r\n  //点击 footer 的确定按钮提交数据\r\n  submitData(res){\r\n    let selectList = this.data.selectList\r\n    //通过 WxNotificationCenter 发送选择的结果通知\r\n    EventBus.postNotificationName(\"SelectPeopleDone\", selectList)\r\n    //将选择结果存入 app.js 的 globalData\r\n    getApp().globalData.selectPeopleList = selectList\r\n    //返回\r\n    wx.navigateBack({\r\n      delta: 1\r\n    })\r\n    console.log(\"selectdone\", selectList)\r\n  },\r\n\r\n  //更新 currentList 并将更新后的列表挂载在数据树上\r\n  updateCurrentList(currentList, selectList){\r\n    let newList = []\r\n    currentList.forEach(item => {\r\n      let flag = false;\r\n      selectList.forEach(item2 => {\r\n        if (item.id === item2.id) {\r\n          flag = true\r\n        }\r\n      })\r\n      if (flag) {\r\n        item.checked = true\r\n      } else {\r\n        item.checked = false\r\n      }\r\n      newList.push(item)\r\n    })\r\n    this.setData({\r\n      currentList: newList\r\n    })\r\n    this.addList2DataTree()\r\n    this.setLastTimeSelectList()\r\n  }\r\n})\r\n复制代码\r\nuserSelect.wxml\r\n\r\n<view class='container'>\r\n  <view class='btn-wrapper'>\r\n    <button bindtap='goBack'>返回上一层</button>\r\n  </view>\r\n\r\n  <view class='people-wrapper'>\r\n    <scroll-view scroll-y class='scrollview'>\r\n      <checkbox-group bindchange=\"checkChange\">\r\n        <view class='item' wx:for='{{currentList}}' wx:key='{{item.id}}'>\r\n          <checkbox checked='{{item.checked}}' value='{{item.id + \",\" + item.name}}'>\r\n          </checkbox>\r\n          <view id='{{index}}' class='item-content' bindtap='clickItem'>\r\n            <image class='img' wx:if='{{!item.isPeople}}' src='../../../assets/file.png'></image>\r\n            <image class='avatar' wx:if='{{item.isPeople}}' src='../../../assets/avatar.png'></image>\r\n            <text class='itemtext'>{{item.name}}</text>\r\n          </view>\r\n        </view>\r\n      </checkbox-group>\r\n      <view class='no-data' wx:if='{{currentList.length===0}}'>暂无数据</view>\r\n    </scroll-view>\r\n  </view>\r\n  <view class='footer'>\r\n    <footer list='{{selectList}}' binddelete='footerDelete' bindsubmit=\"submitData\"/>\r\n  </view>\r\n</view>\r\n复制代码\r\nuserSelect.wxss\r\n\r\n.container {\r\n  width: 100%;\r\n  height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  padding: 20rpx;\r\n  overflow-x: hidden;\r\n  box-sizing: border-box;\r\n  background-color: #fff;\r\n}\r\n\r\n.btn-wrapper {\r\n  width: 100%;\r\n  padding: 0 20rpx;\r\n  box-sizing: border-box;\r\n}\r\n\r\n.btn {\r\n  font-size: 24rpx;\r\n  width: 100%;\r\n}\r\n\r\n.people-wrapper {\r\n  width: 100%;\r\n  margin-top: 10rpx;\r\n  margin-bottom: 100rpx;\r\n}\r\n\r\n.scrollview {\r\n  width: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n.item {\r\n  width: 100%;\r\n  display: flex;\r\n  flex-direction: row;\r\n  align-items: center;\r\n  padding: 30rpx 0;\r\n  margin: 0 20rpx;\r\n  border-bottom: 1rpx solid rgba(7, 17, 27, 0.1);\r\n}\r\n\r\n.item-content {\r\n  width: 100%;\r\n  display: flex;\r\n  flex-direction: row;\r\n  align-items: center;\r\n  margin-left: 20rpx;\r\n}\r\n\r\n.itemtext {\r\n  font-size: 36rpx;\r\n  color: #333;\r\n  margin-left: 20rpx;\r\n  text-align: center;\r\n}\r\n\r\n.img {\r\n  width: 50rpx;\r\n  height: 40rpx;\r\n}\r\n\r\n.avatar {\r\n  width: 50rpx;\r\n  height: 50rpx;\r\n}\r\n\r\n.footer {\r\n  position: absolute;\r\n  left: 0;\r\n  bottom: 0;\r\n  width: 100%;\r\n}\r\n\r\n.no-data{\r\n  width: 100%;\r\n  font-size: 32rpx;\r\n  text-align: center;\r\n  padding: 40rpx 0;\r\n}\r\n复制代码\r\nuserSelect.json\r\n\r\n{\r\n  \"usingComponents\": {\r\n    \"footer\": \"footer/footer\"\r\n  }\r\n}\r\n复制代码footer 的代码\r\n\r\nfooter.js\r\n\r\n\r\nComponent({\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    list: {\r\n      type: Array\r\n    }\r\n  },\r\n\r\n  /**\r\n   * 组件的初始数据\r\n   */\r\n  data: {\r\n    \r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n    delete(res){\r\n      console.log(res)\r\n      let index = res.currentTarget.id\r\n      let list = this.data.list\r\n      list.splice(index,1)\r\n      this.setData({list: list})\r\n      this.triggerEvent(\"delete\", {selectList: list})\r\n    },\r\n\r\n    /**\r\n     * 点击确定按钮\r\n     */\r\n    confirm(){\r\n      this.triggerEvent(\"submit\", \"\")\r\n    }\r\n  }\r\n})\r\n复制代码\r\nfooter.wxml\r\n\r\n<view class='container'>\r\n  <view class='scroll-wrapper'>\r\n    <scroll-view scroll-x style='scroll'>\r\n      <text id='{{index}}' class='text' wx:for='{{list}}' wx:key='{{index}}' bindtap='delete'>{{item.name}}</text>\r\n    </scroll-view>\r\n  </view>\r\n  <text class='btn' bindtap='confirm'>确定</text>\r\n</view>\r\n复制代码\r\nfooter.wxss\r\n\r\n.container {\r\n  width: 100%;\r\n  height: 100rpx;\r\n  display: flex;\r\n  flex-direction: row;\r\n  padding: 20rpx;\r\n  box-sizing: border-box;\r\n  background-color: #fff;\r\n  align-items: center;\r\n  overflow-x: hidden;\r\n  white-space: nowrap;\r\n  border-top: 2rpx solid rgba(7, 17, 27, 0.1)\r\n}\r\n\r\n.scroll-wrapper {\r\n  flex: 1;\r\n  overflow-x: hidden;\r\n  white-space: nowrap;\r\n}\r\n\r\n.scroll {\r\n  width: 100%;\r\n\r\n}\r\n\r\n.text {\r\n  font-size: 32rpx;\r\n  color: #333;\r\n  padding: 40rpx 20rpx;\r\n  margin-right: 10rpx;\r\n  background-color: #f5f5f5;\r\n}\r\n\r\n.btn {\r\n  padding: 10rpx 20rpx;\r\n  background-color: rgb(26, 173, 25);\r\n  border-radius: 10rpx;\r\n  font-size: 32rpx;\r\n  color: #fff;\r\n}\r\n复制代码\r\nfooter.json\r\n\r\n{\r\n  \"component\": true,\r\n  \"usingComponents\": {}\r\n}\r\n复制代码再补一个用到的 ArrayUtils 的代码\r\nexport default{\r\n\r\n  /**\r\n     * 给数组去重\r\n     */\r\n  checkRepeat(list) {\r\n    let noRepList = [list[0]]\r\n    for (let i = 0; i < list.length; i++) {\r\n      let repeat = false\r\n      for (let j = 0; j < noRepList.length; j++) {\r\n        if (noRepList[j].id === list[i].id) {\r\n          repeat = true\r\n          break\r\n        }\r\n      }\r\n      if (!repeat) {\r\n        noRepList.push(list[i])\r\n      }\r\n    }\r\n    return noRepList\r\n  },\r\n\r\n  //删除list中id为 delId 的元素\r\n  deleteItemById(list, delId){\r\n    for (let i = 0; i < list.length; i++) {\r\n      if (list[i].id == delId) {\r\n        list.splice(i, 1)\r\n        return list;\r\n      }\r\n    }\r\n    return list;\r\n  }\r\n\r\n}\r\n复制代码由于时间紧张，还没有把这个控件单独从项目中抽出来写个 Demo，有时间了会给 github 地址的。\r\n代码还有很多可以优化的地方，比如有几个方法太长了，不符合单一职责原则等等，不想改了，以后再优化吧。。\r\n水平有限，各位大侠请轻喷~\r\n有问题或发现 Bug 请在评论区留言，毕竟刚写完就分享出来了，还没经过严格的测试。不过应该没什么大的问题。。。有些细节可能没注意到。\r\n关注下面的标签，发现更多相似文章作者：solocoder链接：https://juejin.im/post/5bd3ec0551882528382d8028"}
{"title": "小程序·云开发初级FAQ ", "author": "Rolan", "pub_time": "2018-10-30 00:23", "content": "之前参加过小程序·云开发相关的分享, 在团队内进行了推广, 感觉官方的宣传不够直接, 还是太玄乎了, 这是收集了猫眼娱乐前端工程师的问题, 和相关答疑, 部分问题是和小程序·云开发的同学沟通过的结论主要面向初级前端工程师, 快速了解云开发是怎么回事, 不涉及复杂代码有小程序开发经验理解 server 端基础, 并有少量node.js server端经验1. 小程序云开发是什么?官方文档, 不用着急点, 下面FAQ未提及的可以进来看主要提供两种能力1.1 提供持久存储持久存储是指删除微信或更换手机后, 用户重新打开我们的小程序, 仍旧能让用户看到自己的信息主要通过两种存储容器类mangodb的 数据库存储 , 比如用户提交的文章文件存储 , 比如用户上传的照片1.2 提供简化的server端编程环境云函数简单解释: 在小程序端写上函数名 + 参数, 就能调用远端的一个函数为什么不直接写到小程序端, 而要绕弯子要这样? 最常见的原因是:有些业务逻辑涉及 保密信息 , 不能写在小程序上, 比如: 价格计算, 交易流程有些操作需要 更高的权限 , 比如: 管理员可以删除所有用户的数据.桥接到第三方接口, 小程序https接口域名数量超限, 或者第三方接口不是https接口.2. 直接操作数据库会不会有安全问题云开发的数据库和传统数据库有些区别, 他会自动给每个数据表增加一个 创建人字段 + 表权限设置 , 后续的操作都会基于这些约束, 一般的策略是每个用户只能修改自己创建的信息, 比如自己发的文章每个用户只能读取其他用户的信息, 但不能修改, 比如其他人发的文章每个用户只能读取公共信息, 但不能修改, 比如公告信息, 一般会允许通过管理端修改3. 直接操作文件存储会不会有安全风险类似上一个数据库的权限, 通过 文件创建人 + 文件夹权限设置文件的操作使用服务端生成的唯一ID, 不会被穷举4. 别人会不会调用我的云函数不会, 云函数的网络协议是私有的, 并且有加上数字签名验证这套机制是在微信app内部实现的, 除非微信这套机制被攻破5.云函数是用js写么, 运行环境是什么?是js, 运行环境是nodejs 8.9, 支持async await关键字目前还不支持修改运行环境, 未来应该会支持自选环境6. 使用了云开发, 是不是就不能使用自己的服务端了不是, 两个可以并存, 就当是看起来不一样的异步调用就好// 云开发相关api\r\nwx.cloud.xxxx()\r\n\r\n// 自有服务\r\nwx.request()\r\n复制代码由于是nodejs的运行环境, 所以云函数可以使用http tcp模块, 这样就能通过云函数转发请求到任意域名, 不受小程序端的请求域名限制7. 典型的云函数是什么样的?// 小程序端, 调用\r\nwx.cloud.callFunction({\r\n    name: 'foo',\r\n    data: { a: 1, b: 2 },\r\n    success: function(res) {\r\n        console.log(res.result)\r\n    }\r\n)\r\n\r\n// 云函数, 声明\r\n// cloudfunctionRoot/functions/foo/index.js\r\nexports.main = async function(e, ctx) {\r\n    return e.a + e.b\r\n}\r\n复制代码函数名和目录名对应, 根路径在project.config.json中定义, 详细参考官方文档中的\"我的第一个云函数\"8. 云函数还有什么特殊能力?直接获取用户的openId// index.js\r\nexports.main = (event, context) => {\r\n  return event.userInfo\r\n}\r\n复制代码如要获取用户头像 昵称等信息, 还是需要在小程序端进行授权才行9. 云函数需要我们考虑服务器运维的工作么不需要, 只要开发好上传就行, 运行环境是独立 封闭的, 类 CentOS 7 的环境10. 开发时和线上环境有隔离么提供1个生产环境, 和1个开发环境, 存储和云函数都是独立的这意味着多个开发者并行开发协作可能会有些小麻烦, 同时只能有一套代码在开发环境, 这就只能通过一些工作流程约定, 比如收敛上传权限, 每日自动部署. 应用类似git-flow的分支策略11. 云开发是否提供有定位 地理信息 支付相关业务的支持暂时没有, 这方面的需求还是很强的, 毕竟小程序是提倡线下扫码, 扫码后还是期望能够获取到附近的相关信息, 简单的比如城市 区划, 详细的比如商家小程序云开发的同学目前还在收集这方面的需求12. 什么版本的基础库支持云开发基础库 2.2.3 之后开始支持, 但对于旧版本可以加个配置也能支持app.json/game.json{\r\n  \"cloud\": true\r\n}\r\n复制代码13. 费用呢目前免费, 正在调研计费策略, 可能是按照调用量, 存储量计费netwjx曹宇   https://juejin.im/post/5bcd5df7518825780d09b145"}
{"title": "微信小程序多层嵌套循环，三级数组遍历 ", "author": "Rolan", "pub_time": "2018-10-30 00:32", "content": "数据：三层嵌套index.wxml 页面<!-- 菜单标签 -->\r\n<view class='menu_label'>\r\n    <view class='label_ul'>\r\n        <view wx:for=\"{{ menuList }}\" wx:key='' class=\"{{ label_index == index ? 'label_lis' : 'label_li' }}\" bindtap='menuList' id=\"{{ index }}\">{{ item.title }}</view>\r\n    </view>\r\n</view>\r\n\r\n<!-- 图书内容 -->\r\n<view class='book_sec'>\r\n    <view class='book_ul' wx:for=\"{{ bookUl }}\" wx:key='' wx:for-item=\"secUl\"  wx:if=\"{{ label_index == index }}\" id=\"{{ index }}\">\r\n        <view class='book_li' wx:for='{{ secUl.bookSec }}' wx:key='' wx:for-item=\"secLi\">\r\n            <view class='book_ol'>\r\n                <view class='book_ol_li' wx:for='{{ secLi.bookList }}' wx:key='' wx:for-item=\"item\">\r\n                    <view class='book_free b'>免费阅读</view>\r\n                    <image src='{{ item.img }}'></image>\r\n                    <view class='book_people b'>100006人在读</view>\r\n                </view>\r\n            </view>\r\n        </view>\r\n    </view>\r\n</view>\r\n\r\n\r\nindex.js页面Page({\r\n        /**\r\n         * 页面的初始数据\r\n         */\r\n        data: {\r\n            menuList: [\r\n                { title: '全部' },\r\n                { title: '文学' },\r\n                { title: '技术类' },\r\n                { title: '社会科学' },\r\n                { title: '设计' },\r\n                { title: '技术类' },\r\n                { title: '社会科学' },\r\n            ],\r\n            label_index: 0,\r\n            bookUl: [\r\n                {\r\n                    bookSec: [\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img1_icon.png' },\r\n                                { img: '../../img/img2_icon.png' },\r\n                                { img: '../../img/img3_icon.png' },\r\n                            ]\r\n                        },\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img4_icon.png' },\r\n                                { img: '../../img/img5_icon.png' },\r\n                            ]\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    bookSec: [\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img6_icon.png' },\r\n                                { img: '../../img/img5_icon.png' },\r\n                                { img: '../../img/img4_icon.png' }\r\n                            ]\r\n                        },\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img7_icon.png' }\r\n                            ]\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    bookSec: [\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img7_icon.png' },\r\n                                { img: '../../img/img2_icon.png' },\r\n                                { img: '../../img/img1_icon.png' },\r\n                            ]\r\n                        },\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img3_icon.png' },\r\n                                { img: '../../img/img4_icon.png' },\r\n                                { img: '../../img/img6_icon.png' }\r\n                            ]\r\n                        }\r\n                    ]\r\n                },\r\n            ]\r\n            \r\n            /**\r\n             * 菜单点击切换内容\r\n             */\r\n        \r\n            menuList: function (e) {\r\n                let that = this;\r\n                // console.log(e);\r\n                var id = e.target.id;\r\n                \r\n                that.setData({\r\n                    label_index: id\r\n                })\r\n            } \r\n        },\r\n    })\r\n\r\n如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 <input/> 中的输入内容，<switch/> 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。wx:key 的值以两种形式提供1）字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。2）保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如：当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。最后效果图作者：MRZYD原文：https://segmentfault.com/a/1190000016818075"}
{"title": "小程序tabbar这套方案全搞定！ ", "author": "Rolan", "pub_time": "2018-10-31 00:12", "content": "关于微信小程序的tarbar，相信你们都不会陌生 在实现小程序微信原装的tabbar却比较呆板，不够精致，往往不符合自己的要求这个时候怎么办呢这套方案接着！先简单的来说一下主要思想:自定义字体图标组件以及tabbar组件，在tabbar中引用自定义字体图标组件。先说一下这套方案的优点：图片换成字体,体积小,请求减少,性能提高自己定义tabbar,能够从细节各方面达到自己的要求，精确到1像素组件可以根据自己的条件来更换tabbar图标（比如你点进一个页面想把这个页面的tabbar样式自己更换） 总而言之就是自由性很大，精准性良好，能够去随心所欲的打造你的专属tabbar!实现这套方案核心还是自定义组件那就从这开始聊：一个自定义组件由 json wxml wxss js 4个文件组成。一个页面要引用一个组件时只需要在该页面的json配置下添加如下{\r\n//声明引用一个组件 配置好你的组件引用路径\r\n  \"usingComponents\": {\r\n    \"icon\": \"../../components/icon/index\"\r\n  }\r\n}\r\n复制代码然后再页面上添加组件的标签即可。//这样就能够在你的页面中添加组件\r\n<icon type=\"\" color=\"\" size=\"\"/>\r\n复制代码如果对于组件的定义仍有疑惑的可以参考这份文档： 官方关于自定义组件的文档OK 下面我们正式来讲这份方案：先定义字体图标组件，在阿里图标库里面挑选好你所需要的字体选择下载代码。 这里我选择的是其中的_fontclass方案，把iconfont.css内的内容拷贝到你创建的icon目录下的index.wxss3. 将该目录下index.json添加{  \r\n//声明这一组文件设为自定义组件\r\n  \"component\": true,\r\n  \"usingComponents\": {}\r\n}\r\n复制代码在index.wxml中定义该组件的结构<!-- 注意style里面的分号！ -->\r\n<text class=\"iconfont icon-{{type}}\" style=\"color:{{color}}; font-size:{{size}}rpx\" ></text>\r\n复制代码在js里面配置他的属性//这里定义了3个自定义属性他们通过{{}}与wxml中的数据连接起来\r\n Component({\r\n  properties: {\r\n    type: {\r\n      type: String,\r\n      value: ''\r\n    },\r\n    color: {\r\n      type: String,\r\n      value: '#000000'\r\n    },\r\n    size: {\r\n      type: Number,\r\n      value: '45'\r\n    }\r\n  }\r\n})\r\n复制代码到此，字体图标组件搞定。现在开始第二步，搞定tabbar组件。首先做在json中添加配置{\r\n  \"component\": true,\r\n  //声明对字体图标组件的引用\r\n  \"usingComponents\": {\r\n    \"icon\": \"../../components/icon/index\"\r\n  }\r\n}\r\n复制代码写wxml结构<view class=\"weibo-tabbar\" >\r\n//绑定回首页事件，此处的data-hi中的数据是为了传递到e.currentTarget.dataset.hi\r\n//通过这个数据我们可以用来判断是否处于首页，然后在js中配置可以阻扰原地跳转\r\n    <view class=\"item-left\"  bindtap=\"goHome\" data-hi=\"{{isIndex}}\">\r\n            <icon type=\"shouye\" color=\"{{isIndex?'#000000':'#b1b1b1'}}\" size=\"45\"/>\r\n            <text class=\"1\" style=\"color:{{isIndex?'#000000':'#b1b1b1'}}\">首页</text>\r\n    </view>\r\n    <block wx:if=\"{{isInner}}\">\r\n        <view class=\"item-right\" style=\"color:#b1b1b1\" bindtap=\"goShare\">\r\n        <icon type=\"fenxiang\" color=\"gray\" size=\"45\"/>\r\n            <text class=\"2\">分享</text>\r\n        </view>\r\n    </block>\r\n    <block wx:else>\r\n        <view class=\"item-right\"  bindtap=\"goInfo\" data-hi=\"{{isIndex}}\">\r\n        <icon type=\"wode\" color=\"{{isIndex?'#b1b1b1':'#000000'}}\" size=\"45\"/>\r\n            <text class=\"2\" style=\"color:{{isIndex?'#b1b1b1':'#000000'}}\">我的</text>\r\n        </view>\r\n    </block>\r\n</view>\r\n复制代码再配置js属性及方法const app = getApp();\r\nComponent({\r\n  properties: {\r\n    isIndex: { // 是否主页            \r\n      type: Boolean,\r\n      value: false,\r\n    },\r\n    isInner: { //是否内部页面\r\n      type: Boolean,\r\n      value: false,\r\n    },\r\n  },\r\n  data: {\r\n    // 这里是一些组件内部数据\r\n    someData: {}\r\n  },\r\n  methods: {\r\n    // 这里是一个自定义方法\r\n    goHome: (e) => {\r\n      // 判断是否为主页面防止原地跳转\r\n      if(!e.currentTarget.dataset.hi){\r\n        wx.redirectTo({\r\n          url: \"/pages/index/index\"\r\n        })\r\n      }\r\n    },\r\n    goShare: function () {\r\n    },\r\n    goInfo: (e) => {\r\n        if(e.currentTarget.dataset.hi){\r\n        wx.redirectTo({\r\n          url: \"/pages/info/info\"\r\n        })\r\n      }\r\n    }\r\n  }\r\n})\r\n复制代码配置样式wxss.weibo-tabbar {\r\n    bottom: 0;\r\n    height: 97rpx;\r\n    padding: 12rpx 0rpx;\r\n    display: flex;\r\n    width: 100%;\r\n    position: fixed;\r\n    background: #ffffff;\r\n    box-sizing: border-box;\r\n}\r\n//产生优雅的0.5px边框\r\n.weibo-tabbar::after {\r\n    content: \"\";\r\n    position: absolute;\r\n    width: 200%;\r\n    height: 200%;\r\n    top: 0;\r\n    left: 0;\r\n    border-top: 1rpx solid rgba(177, 177, 177, 0.4);\r\n    transform: scale(0.5);\r\n    transform-origin: 0 0;\r\n  }\r\n  //这里用flex布局，移动端flex布局确实很爽\r\n  .weibo-tabbar .item-left, .item-right{\r\n   //这里有一处坑，若不不设置他的层级变大的话\r\n   //你是点不到这个item按钮的，当然也不会产生触碰事件\r\n    z-index: 999;\r\n    width: 50%;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    flex-direction: column;\r\n    font-size: 20rpx;\r\n    color: #b1b1b1;\r\n}\r\n.shouye, .wode {\r\n    height: 45rpx;\r\n    width: 45rpx;\r\n}\r\n复制代码到此你只需要在你的页面优雅的添加一行，就能在你的页面中产生tabbar//此处isIndex是给组件的属性传输值，别属性不添加即为默认属性值\r\n<tabbar isIndex=\"true\"></tabbar>\r\n复制代码结果：哇，看了半天就出这么一个小东西！其实大道至简掌握这套方案能够适配你需要的所有tabbar他的颜色、大小、位置都可以自己掌控，重要的是这个解决方案。最后强调一下里面的一些坑按钮的样式层级z-index要提高属性值与{{}}传输的把握style=\"color:{{color}}; font-size:{{size}}\" 注意里面的;号"}
{"title": "微信小程序之animation底部弹窗动画（两种方法） ", "author": "Rolan", "pub_time": "2018-10-31 00:26", "content": "简单分享一下常用的底部弹窗层或下拉框弹出层（代码需要修改）的内容弹窗的动画效果，这里分享的是点击按钮后底部弹窗的动画效果。第一种方式是动态设置显示区域的高度，第二种方法是动态设置显示区域的移动的位置（使用到 transform:translateY ）；（一）实现效果简单说明一下，两种方法实现的效果是一样的，只有点击按钮才能出发弹窗（指定位置），弹窗弹出后，只有点击背景灰色区域弹窗才能收回，点击弹窗内容区域（粉红色部分是不能收回弹窗的），自己可以自定义粉红色部分右上角关闭按钮。（二）实现分析第一种动态设置高度的方法是：需要一个容器为背景色（灰色区域），一个容器为弹窗内容（粉红色区域），两者是独立的，实现的原理是一样的；粉红色区域的话，就是设置好绝对位置（在屏幕的底部）和默认内容的区域样式，动态设置内容区域的高度，比如弹出：一开始高度为0（隐藏了），通过animation设置的动画时间，将高度从0到指定高度，内容慢慢就会显示了，然后保留最后一帧的动画样式就行了；收缩也是一样的道理。第二种动态设置位置的方法是：需要一个容器为背景色（灰色区域），一个容器为弹窗内容（粉红色区域），两者是独立的，实现的原理是一样的；粉红色区域的话，就是设置好绝对位置（在屏幕的底部）和默认内容的区域样式，比如弹出：一开始粉红色区域的位置平移在屏幕外（隐藏了），通过animation设置的动画时间，将粉红色区域从屏幕外平移到屏幕内（默认设置在屏幕底部的位置），内容慢慢就会显示了，然后保留最后一帧的动画样式就行了；收缩也是一样的道理。 代码也有注释哈。（三）实现代码第一种动态设置高度方法实现：1、wxml代码：<button catchtap='clickPup'>点击底部动画弹窗</button>\r\n\r\n<!-- 底部弹窗动画的内容 -->\r\n<view class='pupContent {{click? \"showContent\": \"hideContent\"}} {{option? \"open\": \"close\"}}' hover-stop-propagation='true'>\r\n  <view class='pupContent-top'>测试一下</view>\r\n</view>\r\n<!-- 固定的背景 -->\r\n<view class='pupContentBG {{click?\"showBG\":\"hideBG\"}} {{option?\"openBG\":\"closeBG\"}}' catchtap='clickPup'>\r\n</view>\r\n复制代码2、wxss代码：.pupContentBG {\r\n  width: 100vw;\r\n  height: 100vh;\r\n  position: fixed;\r\n  top: 0;\r\n}\r\n\r\n.pupContent {\r\n  width: 100%;\r\n  background: pink;\r\n  position: absolute;\r\n  bottom: 0;\r\n  box-shadow: 0 0 10rpx #333;\r\n  height: 0;\r\n  z-index: 999;\r\n}\r\n\r\n/* 设置显示的背景 */\r\n\r\n.showBG {\r\n  display: block;\r\n}\r\n\r\n.hideBG {\r\n  display: none;\r\n}\r\n\r\n/* 弹出或关闭动画来动态设置内容高度 */\r\n\r\n@keyframes slideBGtUp {\r\n  from {\r\n    background: transparent;\r\n  }\r\n\r\n  to {\r\n    background: rgba(0, 0, 0, 0.1);\r\n  }\r\n}\r\n\r\n@keyframes slideBGDown {\r\n  from {\r\n    background: rgba(0, 0, 0, 0.1);\r\n  }\r\n\r\n  to {\r\n    background: transparent;\r\n  }\r\n}\r\n\r\n/* 显示或关闭内容时动画 */\r\n\r\n.openBG {\r\n  animation: slideBGtUp 0.5s ease-in both;\r\n  /* animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。 */\r\n}\r\n\r\n.closeBG {\r\n  animation: slideBGDown 0.5s ease-in both;\r\n  /* animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。 */\r\n}\r\n\r\n/* 设置显示内容 */\r\n\r\n.showContent {\r\n  display: block;\r\n}\r\n\r\n.hideContent {\r\n  display: none;\r\n}\r\n\r\n/* 弹出或关闭动画来动态设置内容高度 */\r\n\r\n@keyframes slideContentUp {\r\n  from {\r\n    height: 0;\r\n  }\r\n\r\n  to {\r\n    height: 800rpx;\r\n  }\r\n}\r\n\r\n@keyframes slideContentDown {\r\n  from {\r\n    height: 800rpx;\r\n  }\r\n\r\n  to {\r\n    height: 0;\r\n  }\r\n}\r\n\r\n/* 显示或关闭内容时动画 */\r\n\r\n.open {\r\n  animation: slideContentUp 0.5s ease-in both;\r\n  /* animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。 */\r\n}\r\n\r\n.close {\r\n  animation: slideContentDown 0.5s ease-in both;\r\n  /* animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。 */\r\n}\r\n\r\n复制代码3、js代码：data: {\r\n    click: false, //是否显示弹窗内容\r\n    option: false, //显示弹窗或关闭弹窗的操作动画\r\n  },\r\n\r\n  // 用户点击显示弹窗\r\n  clickPup: function() {\r\n    let _that = this;\r\n    if (!_that.data.click) {\r\n      _that.setData({\r\n        click: true,\r\n      })\r\n    }\r\n\r\n    if (_that.data.option) {\r\n      _that.setData({\r\n        option: false,\r\n      })\r\n\r\n      // 关闭显示弹窗动画的内容，不设置的话会出现：点击任何地方都会出现弹窗，就不是指定位置点击出现弹窗了\r\n      setTimeout(() => {\r\n        _that.setData({\r\n          click: false,\r\n        })\r\n      }, 500)\r\n\r\n\r\n    } else {\r\n      _that.setData({\r\n        option: true\r\n      })\r\n    }\r\n  },\r\n\r\n复制代码第二种动态平移内容区域位置方法实现：相对于第一种代码修改的部分：只修改的了粉红色区域的高度和粉红色区域弹出和收回的动画效果：/* 弹出或关闭动画来动态设置内容高度 */\r\n\r\n@keyframes slideContentUp {\r\n  from {\r\n    transform: translateY(100%); /*设置为正数则底部弹出来，负数则相反*/\r\n  }\r\n\r\n  to {\r\n    transform: translateY(0%);\r\n  }\r\n}\r\n\r\n@keyframes slideContentDown {\r\n  from {\r\n    transform: translateY(0%);\r\n  }\r\n\r\n  to {\r\n    transform: translateY(100%);\r\n  }\r\n}\r\n复制代码参考资料：CSS3（三）Animation 入门详解微信小程序CSS3动画下拉菜单感谢阅读。"}
{"title": "微信小程序裁剪图片成圆形 ", "author": "Rolan", "pub_time": "2018-10-12 10:00", "content": "前言最近在开发小程序，产品经理提了一个需求，要求微信小程序换头像，用户剪裁图片必须是圆形，也在github上看了一些例子，一般剪裁图片用的都是方形，所以自己打算写一个小组件，可以把图片剪裁成圆形，主要思路就是使用canvas绘图，把剪裁的图片绘制成圆形，另外剪裁图片的窗口还可以移动放大缩小，这个功能就用了微信组件movable-view，好了，该说的也说完了，下面咱们开始撸代码。movable-view组件可移动的视图容器，在页面中可以拖拽滑动\r\n会有好多个属性，在这里不一一介绍，只说我们能用到的就可以。\r\n我们用到的属性主要有：direction：movable-view的移动方向，属性值有all、vertical、horizontal、nonescale：是否支持双指缩放，默认缩放手势生效区域是在movable-view内scale-min\t定义缩放倍数最小值scale-max\t定义缩放倍数最大值bindchange\t拖动过程中触发的事件，event.detail = {x: x, y: y, source: source}，其中source表示产生移动的原因，值可为touch（拖动）、touch-out-of-bounds（超出移动范围）、out-of-bounds（超出移动范围后的回弹）、friction（惯性）和空字符串（setData）bindscale\t缩放过程中触发的事件，event.detail = {x: x, y: y, scale: scale}，其中x和y字段在2.1.0之后开始支持返回主要用到的就是这几个值另外使用movable-view的时候必须在外边加一个movable-area的父元素，不然的话没有移动区域。movable-view 的可移动区域，属性只有：scale-area\t当里面的movable-view设置为支持双指缩放时，设置此值可将缩放手势生效区域修改为整个movable-area，是个boolean值，默认false截取区域的移动已经说完了，详情请看developers.weixin.qq.com/miniprogram…canvas绘图画布。该组件是原生组件可以绘制图像，分享朋友圈生成海报就经常用到这个属性，就简单的说下：在wxml中必须要有canvas这个标签，才可以绘制图像，而且要有canvas-id属性，代表canvas 组件的唯一标识符，还有许多API我就不一一介绍了，底下用的API代码当中都会用注释。详情请看微信小程序画布APIhttps://developers.weixin.qq.com/miniprogram/dev/api/canvas/wx.canvasGetImageData.html代码实现首先是选择图片wxml就是初始化一个按钮点击的时候选择图片，而且需要引入我们封装的截取图片组件，并把图片作为参数传进去，封装组件方法请看我另一篇文章juejin.im/post/5afcee…index.wxmlTip: 必须把canvas放到引入剪裁组件的wxml中，否则绘制不成功，因为canvas是原生组件脱离在 WebView 渲染流程外。<view class=\"container\">\r\n  <button wx:if=\"{{!imgSrc}}\" bindtap=\"getImgurl\"> 选择图片 button>\r\n  <view class=\"clip-box\" wx:if=\"{{imgSrc}}\">\r\n      <ClipImg imgSrc=\"{{imgSrc}}\">ClipImg>\r\n  view>\r\nview>\r\n<canvas canvas-id=\"myCanvas\" style=\"position:absolute; width:100%;height:100%;border: 1px solid red;left: -9999px; top: -9999px;\">canvas>\r\n复制代码index.json引入截取图片的组件{\r\n    \"component\": true,\r\n    \"usingComponents\": {\r\n        \"ClipImg\": \"../../component/clipImg/clipImg\"\r\n    }\r\n}\r\n复制代码index.js上传图片显示const app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    imgSrc: ''\r\n  },\r\n  //选择图片\r\n  getImgurl: function () {\r\n    wx.chooseImage({\r\n      count: 1, // 默认9\r\n      sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\r\n      sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n      success:  (res) => {\r\n        // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\r\n        const tempFilePaths = res.tempFilePaths;\r\n        //启动上传等待中...  \r\n        wx.showToast({  \r\n          title: '正在上传...',  \r\n          icon: 'loading',  \r\n          mask: true,  \r\n          duration: 1000 \r\n        }) \r\n        this.setData({\r\n          imgSrc: res.tempFilePaths\r\n        })\r\n      }\r\n    })\r\n  },\r\n  onLoad: function () {\r\n  }\r\n})\r\n复制代码接下来就是剪裁图片组件的封装首先是页面布局，也就是clipImg.wxml<view class=\"clip\">\r\n    <image class=\"head-img\" style=\"width:{{cropperW}}rpx;height:{{cropperH}}rpx\" src=\"{{imageUrl}}\">image>\r\n    <movable-area scale-area style=\"width:{{cropperW}}rpx;height:{{cropperH}}rpx\">\r\n        <movable-view bindchange=\"move\" bindscale=\"scale\" direction=\"all\" scale scale-min=\"0.5\" scale-max=\"1.8\">\r\n        movable-view>\r\n    movable-area>\r\n    <view class=\"btn\">\r\n        <text bindtap=\"cancel\">取消text>\r\n        <text bindtap=\"getImageInfo\">保存text>\r\n    view>\r\nview>\r\n复制代码大概就是这个样子上边的圆就是截取就是截取框。然后就是clipImg.js文件主要就是对图片截取的一些操作Component({\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    imgSrc: {\r\n      type: 'String',\r\n      value: ''\r\n    }\r\n  },\r\n\r\n  /**\r\n   * 组件的初始数据\r\n   * imageUrl string 初始化图片\r\n   * cropperW string 缩小图宽度\r\n   * cropperH  string 缩小图高度,\r\n   * img_ratio string  图片比例,\r\n   * IMG_W string 原图高度,\r\n   * IMG_H string 原图高度,\r\n   * left string 图片距离左边距离,\r\n   * top string 图片距离上边距离,\r\n   * clipW number 默认截取框\r\n   */\r\n  data: {\r\n    imageUrl: '',\r\n    cropperW: '',\r\n    cropperH: '',\r\n    img_ratio: '',\r\n    IMG_W: '',\r\n    IMG_H: '',\r\n    left: '',\r\n    top: '',\r\n    clipW: 200\r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n    //点击取消\r\n    cancel: function () {\r\n      var myEventDetail = {} // detail对象，提供给事件监听函数\r\n      var myEventOption = {} // 触发事件的选项\r\n      this.triggerEvent('myevent', myEventDetail, myEventOption)\r\n    },\r\n    //拖拽事件\r\n    move: function ({ detail }) {\r\n      this.setData({\r\n        left: detail.x * 2,\r\n        top: detail.y * 2\r\n      })\r\n    },\r\n    //缩放事件\r\n    scale: function ({ detail }) {\r\n      console.log(detail.scale)\r\n      this.setData({\r\n        clipW: 200 * detail.scale\r\n      })\r\n    },\r\n    //生成图片\r\n    getImageInfo: function () {\r\n      wx.showLoading({\r\n        title: '图片生成中...',\r\n      })\r\n      const img_ratio = this.data.img_ratio;\r\n      //要截取canvas的宽\r\n      const canvasW = (this.data.clipW / this.data.cropperW) * this.data.IMG_W\r\n      //要截取canvas的高\r\n      const canvasH = (this.data.clipW / this.data.cropperH) * this.data.IMG_H\r\n      //要截取canvas到左边距离\r\n      const canvasL = (this.data.left / this.data.cropperW) * this.data.IMG_W\r\n      //要截取canvas到上边距离\r\n      const canvasT = (this.data.top / this.data.cropperH) * this.data.IMG_H\r\n      // 将图片写入画布\r\n      const ctx = wx.createCanvasContext('myCanvas');\r\n      //绘制图像到画布\r\n      ctx.save(); // 先保存状态 已便于画完圆再用        \r\n      ctx.beginPath(); //开始绘制  \r\n      ctx.clearRect(0, 0, 1000, 1000)\r\n      //先画个圆      \r\n      ctx.arc(this.data.clipW / 2, this.data.clipW / 2, this.data.clipW / 2, 0, 2 * Math.PI, false)\r\n      ctx.clip();//画了圆 再剪切  原始画布中剪切任意形状和尺寸。一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内    \r\n      ctx.drawImage(this.data.imageUrl, canvasL, canvasT, canvasW, canvasH, 0, 0, this.data.clipW, this.data.clipW); // 推进去图片        \r\n      ctx.restore(); //恢复之前保存的绘图上下文 恢复之前保存的绘图上下午即状态 可以继续绘制\r\n      ctx.draw(true, () => {\r\n        // 获取画布要裁剪的位置和宽度   \r\n        wx.canvasToTempFilePath({\r\n          x: 0,\r\n          y: 0,\r\n          width: this.data.clipW,\r\n          height: this.data.clipW,\r\n          destWidth: this.data.clipW,\r\n          destHeight: this.data.clipW,\r\n          quality: 0.5,\r\n          canvasId: 'myCanvas',\r\n          success: (res) => {\r\n            wx.hideLoading()\r\n            /**\r\n             * 截取成功后可以上传的服务端直接调用\r\n             * wx.uploadFile();\r\n             */\r\n            //成功获得地址的地方\r\n            wx.previewImage({\r\n              current: '', // 当前显示图片的http链接\r\n              urls: [res.tempFilePath] // 需要预览的图片http链接列表\r\n            })\r\n          }\r\n        })\r\n      })\r\n    }\r\n  },\r\n  ready: function () {\r\n    this.setData({\r\n      imageUrl: this.data.imgSrc[0]\r\n    })\r\n    //获取图片宽高\r\n    wx.getImageInfo({\r\n      src: this.data.imageUrl,\r\n      success: (res) => {\r\n        console.log('图片信息', res);\r\n        //图片实际款高\r\n        const width = res.width;\r\n        const height = res.height;\r\n        //图片宽高比例\r\n        const img_ratio = width / height\r\n        this.setData({\r\n          img_ratio,\r\n          IMG_W: width,\r\n          IMG_H: height,\r\n        })\r\n        if (img_ratio >= 1) {\r\n          //宽比较大，横着显示\r\n          this.setData({\r\n            cropperW: 750,\r\n            cropperH: 750 / img_ratio,\r\n          })\r\n        } else {\r\n          //竖着显示\r\n          this.setData({\r\n            cropperW: 750 * img_ratio,\r\n            cropperH: 750\r\n          })\r\n        }\r\n      } \r\n    })\r\n  }\r\n})\r\n复制代码到现在为止一个截取图片就完成了，可能会有些问题，比如截取的图片的框没有居中，自己可以再次封装这个组件，因为现在已经适合我们公司自己项目了。我们来预览下。另外这个组件支持双指放大截取框来截取图片，不过微信开发者工具不能展示，自己可以把代码下载下来，在自己手机上扫码查看效果。另外我把项目放到了github上边，希望小哥哥小姐姐们多多点赞，多多支持。使用的时候直接把component里边的组件直接引进去就行，有什么疑问可以在github底下留言问我，谢谢。点赞的小哥哥小姐姐最可爱，哈哈哈。。。项目地址github.com/Mr-MengBo/i…"}
{"title": "微信小程序如何开发跑马灯效果？ ", "author": "Rolan", "pub_time": "2018-10-15 00:06", "content": "跑马灯效果比较常见，一般做电商类的小程序，都会用到，所以代码君今天特地写一篇文章，来教一下大家，如何去实现跑马灯效果，下面是代码君实现的效果，可以先看一下！跑马灯效果的制作制作方式很简单，先方上代码，后面会对代码详细讲解一、wxml界面的实现<!-- 跑马灯效果  -->\r\n    <view class=\"example\">\r\n      <view class=\"marquee_box\">\r\n        <view class=\"marquee_text\" style=\"{{orientation}}:{{marqueeDistance}}px;font-size: {{size}}px;\">\r\n          <image src=\"{{adUrl}}\" class='ad-image' />{{text}}\r\n        </view>\r\n      </view>\r\n    </view>\r\n复制代码界面布局很简单，一个底部背景容器，加入一个广播图片和对应的跑马灯文字二、wxss样式.example {\r\n  display: block;\r\n  width: 100%;\r\n  height: 70rpx;\r\n  background-color: #f2f2f2;\r\n  line-height: 70rpx;\r\n}\r\n\r\n.marquee_box {\r\n  width: 100%;\r\n  position: relative;\r\n}\r\n\r\n.marquee_text {\r\n  white-space: nowrap;\r\n  position: absolute;\r\n  top: 0;\r\n  display: flex;\r\n  flex-direction: row;\r\n}\r\n\r\n.ad-image {\r\n  width: 40rpx;\r\n  height: 40rpx;\r\n  margin-right: 10rpx;\r\n  margin-top: 15rpx;\r\n}\r\n复制代码样式就这些，这里代码君要带着大家回顾一下以前教程里讲解的内容文字居中css样式要如何设置？只需要将属性height与line-height设置成一样高度即可display属性none:此元素不会被显示block：两个元素自动换行inline：两个元素靠在一起inherit：继承父类flex：多栏多列三、xxx.jsPage({\r\n  data: {\r\n     text: '51淘甄貨,一个可以省钱的购物平台',\r\n    marqueePace: 1,//滚动速度\r\n    marqueeDistance: 0,//初始滚动距离\r\n    size: 14,\r\n    orientation: 'left',//滚动方向\r\n    interval: 20, // 时间间隔\r\n    adUrl: '../../images/ic_home_msg.png',\r\n  },\r\n  onShow: function () {\r\n    // 页面显示\r\n    var that = this;\r\n    var length = that.data.text.length * that.data.size;//文字长度\r\n    var windowWidth = wx.getSystemInfoSync().windowWidth;// 屏幕宽度\r\n    that.setData({\r\n      length: length,\r\n      windowWidth: windowWidth,\r\n    });\r\n    that.runMarquee();// 水平一行字滚动完了再按照原来的方向滚动\r\n  },\r\n runMarquee: function () {\r\n    var that = this;\r\n    var interval = setInterval(function () {\r\n      //文字一直移动到末端\r\n      if (-that.data.marqueeDistance < that.data.length) {\r\n        that.setData({\r\n          marqueeDistance: that.data.marqueeDistance - that.data.marqueePace,\r\n        });\r\n      } else {\r\n        clearInterval(interval);\r\n        that.setData({\r\n          marqueeDistance: that.data.windowWidth\r\n        });\r\n        that.runMarquee();\r\n      }\r\n    }, that.data.interval);\r\n  }\r\n})\r\n复制代码js里面需要讲解的比较多1. setInterval 计时器如何使用？setInterval(function(){\r\nconsole.log(\"interval\")\r\n},1000)\r\n复制代码这个方法是微信小程序的api，直接使用即可，和正常的定时器一样，setInterval需要传入两个参数，一个是回调的方法，另一个是每隔多久执行一次，在此项目中，我们用的是字段参数interval，值设置为202. settimeout和setinterval()这两个都是腾讯提供的API，他们有什么区别吗？settimeout隔一段时间执行函数且执行一次，场景是我们可能希望一个任务隔一段时间后再执行etinterval()函数是 每 隔一段时间便执行，就是会一直循环执行，如果想停止的话可以使用clearinterval3.跑马灯实现原理第一步：计算跑马灯文字长度第二步：每隔一段时间，移动一点距离，产生移动第三步：当移出屏幕，重置跑马灯的距离为屏幕宽度，然后就可以继续循环第一步操作了根据代码君说的这几步，读者可以去一一对照代码，方法函数runMarquee里面的代码逻辑就是执行以上三步，在此代码君就不过多解释了总结以上就是跑马灯效果的整个流程，原理也不是很难，一个计时器，轻松就可以实现，如果还想学习更多教程，关注《代码集中营》公众号获取最新教程"}
{"title": "微信小程序及各种平台对接常用可逆加密算法aes256 ", "author": "Rolan", "pub_time": "2018-10-15 00:21", "content": "不同程序之间经常会交换数据,我们经常采用的套路是:假设要传输的信息是json,我们假设其为json_data,通过http传递信息为json_data_encode=json_data&sign=md5(json_data+key)接收方通过验证sign就知道内容有没有被篡改.但是,这样json_data作为明码传送会让我们不太开心,所以今天的我们要介绍的aes256出马了,他是一强度很高的可逆加密算法!aes256加密出来的内容是二进制的,不好通过http协议传输,所以我们再配合上base64转成ascii码加密前,aes256要求字节数必须是32字节的倍数,所以使用pkcs7进行填充可以解决问题..介绍完原理,直接贴代码写了3个版本,openresty及python和php的...请查收local aes = require 'resty.aes' local base64_encode = ngx.encode_base64 local base64_decode = ngx.decode_base64 local key = \"a12e93c9edadeaa47eb1aeabe27dabef\" local iv = \"a12e93c9edadeaa4\" -- AES 128 CBC with IV and no SALT local cipher = aes.cipher(256,\"cbc\") local aes_256_cbc_with_iv = aes:new(key,nil,cipher,{iv=iv}) local function decrypt(input)     input = base64_decode(input)     input = aes_256_cbc_with_iv:decrypt(input)     -- 取最后一个字符的ascii值     --local padding = string.byte(input,-1)     --return string.sub(input,-padding)     return input end local function pkcs7_padding(text)     local text_length = string.len(text)     local amount_to_pad = 32 - (text_length % 32)     if amount_to_pad == 0 then         amount_to_pad = 32     end     local pad = string.char(amount_to_pad) return text .. string.rep(pad,amount_to_pad) end local function encrypt (text)     text = pkcs7_padding(text)     text = aes_256_cbc_with_iv:encrypt(text)     return base64_encode(text) end print(decrypt(encrypt('linbc')))接着是python版本的#!/usr/bin/env python# -*- coding: utf-8 -*-import base64from Crypto.Cipher import AESimport binasciiimport StringIOclass PKCS7Encoder(object):    '''    RFC 2315: PKCS#7 page 21    Some content-encryption algorithms assume the    input length is a multiple of k octets, where k > 1, and    let the application define a method for handling inputs    whose lengths are not a multiple of k octets. For such    algorithms, the method shall be to pad the input at the    trailing end with k - (l mod k) octets all having value k -    (l mod k), where l is the length of the input. In other    words, the input is padded at the trailing end with one of    the following strings:             01 -- if l mod k = k-1            02 02 -- if l mod k = k-2                        .                        .                        .          k k ... k k -- if l mod k = 0    The padding can be removed unambiguously since all input is    padded and no padding string is a suffix of another. This    padding method is well-defined if and only if k < 256;    methods for larger k are an open issue for further study.    '''    def __init__(self, k=16):        self.k = k    ## @param text The padded text for which the padding is to be removed.    # @exception ValueError Raised when the input padding is missing or corrupt.    def decode(self, text):        '''        Remove the PKCS#7 padding from a text string        '''        nl = len(text)        val = int(binascii.hexlify(text[-1]), 16)        if val > self.k:            raise ValueError('Input is not padded or padding is corrupt')        l = nl - val        return text[:l]    ## @param text The text to encode.    def encode(self, text):        '''        Pad an input string according to PKCS#7        '''        l = len(text)        output = StringIO.StringIO()        val = self.k - (l % self.k)        for _ in xrange(val):            output.write('%02x' % val)        return text + binascii.unhexlify(output.getvalue())# 使用256位的AES，Python会根据传入的Key长度自动选择，长度为16时使用128位的AESkey = 'a12e93c9edadeaa47eb1aeabe27dabef'mode = AES.MODE_CBC#iv = '1234567812345678'  # AES的CBC模式使用IViv = 'a12e93c9edadeaa4'  # AES的CBC模式使用IVencoder = PKCS7Encoder()text = \"This is for test.\"def encrypt(data):    encryptor = AES.new(key, AES.MODE_CBC, iv)    padded_text = encoder.encode(data)    encrypted_data = encryptor.encrypt(padded_text)    return base64.b64encode(encrypted_data)def decrypt(data):    cipher = base64.b64decode(data)    decryptor = AES.new(key, AES.MODE_CBC, iv)    plain = decryptor.decrypt(cipher)    return encoder.decode(plain)#encrypted_text = encrypt(text)encrypted_text = 'MD1ZOvuyvut4VEed4rf+8YKaOHyECJK/RWLcfVsJwjAEZp8Hhi1zi7oH3PLSygjFCAxCRJqMBzm/qhreznkg34Vgbho+zwprTgl4M0c0lRkvLzWzXmSYG8pcqth1qnbNSwQeS3MPuofgVXR0SGMTIzicCXDlmwQV9uvIJekgES2LMse4pVndcrftI9f6UbIiT085DhAaiV9yGsV3r4FES+LnwP9ZNi58TButNC9owyKh9RuRn7z04LfNy++7iLjzk/HurOkBkJewHSchLER+pK94qhg6Lj8mW7dl+y5j3wbXY9SodNK+S8LDRYCa1JyZ/w8rffUK8YCY+jCT3ZmV8G5vdUENTqsrB4jX87C+XQCY9WEG+VQ5MK5XlhhvMPZyn2NLZUi6gW1HjqE6i/uefzq/LFl47cL2Hmr/cLbfI5rF+d1hMAIZGNnRxjYkVVvipEwRSlkD47ZVFLiWRKPusB7Lke3mnGJ1O+5eQnREL7Q/xpRT+3JuCcOqZIZJFFrJXMj9CXsJGMXxFkfnKT3UAhOi/lRA65Vwt1BEswHuZzLLHquyEYQMc3cOW1vy1Fv4zpYkjHYmxB1g50gwVryrEW2kY58sDdxwDYua3jLwERk='clean_text = decrypt(encrypted_text)print \"encrypted_text:\", encrypted_textprint \"clean_text: \", clean_text再来个php版本的<?php//function aes256EcbPkcs7PaddingEncrypt($key, $data) {//    $padding = 16 - (strlen($data) % 16);//    $data .= str_repeat(chr($padding), $padding);//    return mcrypt_encrypt(MCRYPT_RIJNDAEL_256, hash('SHA256', $key, true), $data, MCRYPT_MODE_ECB);//}////function aes256EcbPkcs7PaddingDecrypt($key, $data) {//    $data = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, hash('SHA256', $key, true), $data, MCRYPT_MODE_ECB);//    $padding = ord($data[strlen($data) - 1]); //    return substr($data, 0, -$padding); //}$txt=\"MD1ZOvuyvut4VEed4rf+8YKaOHyECJK/RWLcfVsJwjAEZp8Hhi1zi7oH3PLSygjFCAxCRJqMBzm/qhreznkg34Vgbho+zwprTgl4M0c0lRkvLzWzXmSYG8pcqth1qnbNSwQeS3MPuofgVXR0SGMTIzicCXDlmwQV9uvIJekgES2LMse4pVndcrftI9f6UbIiT085DhAaiV9yGsV3r4FES+LnwP9ZNi58TButNC9owyKh9RuRn7z04LfNy++7iLjzk/HurOkBkJewHSchLER+pK94qhg6Lj8mW7dl+y5j3wbXY9SodNK+S8LDRYCa1JyZ/w8rffUK8YCY+jCT3ZmV8G5vdUENTqsrB4jX87C+XQCY9WEG+VQ5MK5XlhhvMPZyn2NLZUi6gW1HjqE6i/uefzq/LFl47cL2Hmr/cLbfI5rF+d1hMAIZGNnRxjYkVVvipEwRSlkD47ZVFLiWRKPusB7Lke3mnGJ1O+5eQnREL7Q/xpRT+3JuCcOqZIZJFFrJXMj9CXsJGMXxFkfnKT3UAhOi/lRA65Vwt1BEswHuZzLLHquyEYQMc3cOW1vy1Fv4zpYkjHYmxB1g50gwVryrEW2kY58sDdxwDYua3jLwERk=\";$txt=base64_decode($txt);$key=\"a12e93c9edadeaa47eb1aeabe27dabef\";$iv ='a12e93c9edadeaa4';$module = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_CBC, '');mcrypt_generic_init($module, $key, $iv);$data = mdecrypt_generic($module, $txt);mcrypt_generic_deinit($module);mcrypt_module_close($module);$padding = ord($data[strlen($data) - 1]); $result = substr($data, 0, -$padding); echo $result;exit();?>php果然是...很省事的语言..看他多简短啊."}
{"title": "小程序国际化实现机制 ", "author": "Rolan", "pub_time": "2018-10-15 00:34", "content": "需求可手动设置使用语言根据不同的语言显示不同的语言文字（目前是支持中英文，如需其他语言，可直接配置即可） 如果没有配置相应语言的信息，则使用默认的数据 国际化分为文字和图片（有的图片上有文字信息）两类 限制因素小程序2m的限制所以图片网络化\" style=\"margin: 20px 0px; font-family: \"PingFang SC\", \"Hiragino Sans GB\", \"Helvetica Neue\", \"Microsoft Yahei\", \"WenQuanYi Micro Hei\", sans-serif; font-weight: 500; line-height: 40px; color: rgb(44, 62, 80); text-rendering: optimizeLegibility; font-size: 21px; background-color: rgb(249, 249, 245);\">因小程序2M的限制，所以图片网络化地图上的图片（如markers、controls、polyline等），不能使用网络图片，只能使用本地图片；所以图片的话分为本地图片和网络图片两种实现机制目录结构信息res │ resUtils.js │ ├─values │ img.js │ strings.js│ ├─values_en │ img.js │ strings.js │└─values_zh_CN strings.js values中是默认的是数据配置，values_en是英文坏境下的配置，values_zh_CN中文简体环境下的配置 后面如果需要配置其他的语言（如zh_TW，中文繁体，台湾地区），只需要新建文件名 values_zh_TW即可 resUtils.js是国际化的核心代码位置，这个文件会根据不同的语言来引用引用对应的文件； 首次如果没有设置过语言，或跟从当前手机的语言环境，后面如果设置过语言的话，跟从设置的语言来（暂定，具体的需求还未出） 具体配置文字国际化，直接在对应的环境下strings.js中添加要用的文字信息，文件会自动导出module.exports = {  LOGIN_STATUS_INVALID: '登录失效',  LOGIN_LOG_AGAIN: '请重新登录',}module.exports = {  LOGIN_STATUS_INVALID: 'Login status invalid',  LOGIN_LOG_AGAIN: 'Log in again',}图片国际化（分为本地和网络图片两种）； 网络图片直接调用getImg('drawableName.png')，即可； 本地图片，使用绝对路径即可/** * 默认环境图片配置 * @author Shirley.jiang  */const ICON_URL = 'https://***';let env = 'zh_CN';let getImg = (name) => {  return ICON_URL + '/' + env + '/' + name;}module.exports = {  IC_BTN_PHONE: getImg('btn_phone.png'), // 网络图片  ICON_LOCATION: '/imgs/icon_location.png', // 本地图片}/** * en环境图片配置 * @author Shirley.jiang  */const ICON_URL = 'https://***';let env = 'en';let getImg = (name) => {  return ICON_URL + '/' + env + '/' + name;}module.exports = {  IC_CHANGE_LANGUAGE: getImg('ic_change_language.png')};使用方式const resUtils = require('../../res/resUtils.js'); // 引入resUtils.strings.LOGIN_STATUS_INVALID; // 文字调用resUtils.imgs.IC_CHANGE_LANGUAGE； // 图片调用注意事项因wxml 文件不能应用js文件，所以数据全部通过data进行中转 data的加载比生命周期要早，导致切换语言的时候，data数据没有更新；所以在Page和Component中的ready方法之后，手动setData一次（因未找到更好的解决方案，暂定这种方式） 附带[resUtils.js]代码const localStorage = require('../utils/LocalStorage.js');/*** 国际化* @author Shirley.jiang*/class ResUtils {  static mInstance;  mStrings = {};  mImgs = {};  mEnv;  static getInstance() {    if (!ResUtils.mInstance) {      ResUtils.mInstance = new ResUtils();    }    return ResUtils.mInstance;  }  init(env) {      this.mEnv = env;      this.initStrings();          this.initImgs();  }   /**   * 引用字符配置   */  initStrings() {       this.mStrings = {};       let strings;       let defaultStrings;       try {      strings = require('./values_' + this.mEnv + '/strings.js');   } catch (err) { }       try {      defaultStrings = require('./values/strings.js');   } catch (err) { }       // 初始化默认的数据   for (let key in defaultStrings) {             if (!defaultStrings.hasOwnProperty(key)) {                   continue;       }             this.mStrings[key] = defaultStrings[key];   }       // 如果当前语言文件中定义的有，则直接覆盖   for (let key in strings) {             if (!this.mStrings.hasOwnProperty(key)) {                   continue;       }             this.mStrings[key] = strings[key];    }  }     /**   * 引用图片配置   */  initImgs() {       this.mImgs = {};       let imgs;       let defaultImgs;       try {      imgs = require('./values_' + this.mEnv + '/img.js');    } catch (err) { }       try {      defaultImgs = require('./values/img.js');    } catch (err) { }       // 初始化默认的数据   for (let key in defaultImgs) {             if (!defaultImgs.hasOwnProperty(key)) {                   continue;       }             this.mImgs[key] = defaultImgs[key];    }        // 如果当前语言文件中定义的有，则直接覆盖    for (let key in imgs) {              if (!this.mImgs.hasOwnProperty(key)) {                    continue;        }              this.mImgs[key] = imgs[key];    }  }     /**   * 切换语言   * @param {string} env 语言值   */  changeLanguage(env) {    localStorage.setEnv(env);        this.init(env);  }}/*** zh_CN 中文* zh_TW 中文繁体(台湾)* en 英文环境*/let env = localStorage.getEnv();ResUtils.getInstance().init(env);module.exports = ResUtils.getInstance();感谢《小程序开发一群》的Shirley.jiang投稿。"}
{"title": "小程序产品设计中的坑 ", "author": "Rolan", "pub_time": "2018-10-16 00:01", "content": "本文系统地罗列了微信小程序在产品设计上的出现的问题，并提出了相应的建议。资质不是所有功能都可以做，根据不同主体，会有不同的开放类目。主体分为「非个人主体」「个人主体」「海外主体」。有些类目需要有资质，比如社交类（包括社区、笔记等），都要 ICP 证。如果做了功能提交审核，发现的话会被拒绝，要求添加相关分类。官方文档： 小程序开放的服务类目对策：做服务端开关，审核时把功能隐藏（暂时貌似没有程序静态检查，只有人工审核），审核后再打开，但要承担被下架的风险。虚拟支付18年5月，由于苹果公司要求，iOS的小程序虚拟商品支付被禁止，即内容付费、工具服务类等，不包括外卖、电商这些；如果被发现，会屏蔽支付接口。对策：加入实体商品的性质，比如购买课程变成购买课程+书，加入收货地址等信息。模版消息推送可以给用户推送模版消息，会在「服务通知」里提醒，对留存比较有帮助（唤起用户）。有次数和时间限制，两种方式可以获得下发次数：支付：每次支付有 3 条下发次数，可以在 7 天内推送。提交表单：每次提交有 1 条下发次数，可以在 7 天内推送。官方文档： 模版消息大部分小程序都没有支付，主要靠提交表单，即需要用 <form/> 组件，让用户手动触发确认。常见做法会把 <form/> 伪装成一个列表项、某个按钮等，用户在使用过程中就获得了下发次数，但有违规风险。Tab bar 的 action button有的产品想要在 tab bar 加上 action button，比如：发布内容、新建文章等。但小程序原生 tab bar 目前不支持跳转新页面，只支持在当前打开页面。而如果自己实现 tab bar，性能会很差（切换 tab 时卡顿、页面闪烁）。有种做法，依然用原生 tab bar，但把 icon 素材做成 action button 的样式，然后在当前打开页面，列出一些选项让用户选择，再进入子页面。比如可以参考「美篇」的开始创作，先让用户选择文字、图片、视频，然后再进入文章编辑的子页面。自定义导航栏例如「知乎热榜」小程序，搜索框在导航栏。怎么做到的？其实是微信版本 6.6.0 后支持的特性，navigationStyle 可以设置为 custom，设置后顶栏就消失了，页面会自动顶到最顶部。所以「知乎热榜」那个搜索栏不是属于顶栏，而是属于页面内容，这下就好理解了。 ​​​​官方文档： 全局配置 – windowWebview小程序中可以使用 webview 组件，直接把 mobile web 套到小程序里，比如「多抓鱼」就是以 webview 为主的。好处：节省工作量，已有的 mobile web 不用重复开发。不需要等审核，随时部署更新。直接兼容一些小程序不支持的原生标签，比如 <pre/>。坏处：一个页面里只能有一个 <webview/> 组件，不能有其它。比如想用原生的 <button/> 来调起支付、分享，就不可以。只有绑定为业务域名的 url 才能跳转，不可以随便打开什么网页，上限 20 个。其它杂七杂八绑定的服务器域名，需要国内 ICP 备案，所以想做个 dribbble 客户端，直接利用 dribbble API 是不行的，只能想办法用自己服务器做数据转发。小程序之间可以互相跳转，但必须绑定在同一公众号下，而且具体跳转的是哪个小程序、哪个页面，要手动配置小程序 AppID 和路径。不能长按别二维码，也没办法下载 app。如果需要绑定手机号，可以使用小程序的 获取手机号 接口，调的是微信绑定了的手机号，很方便。作者：刘英滕链接：https://www.jianshu.com/p/f36e0aceed98本文由 @刘英滕 授权发布于人人都是产品经理，未经作者许可，禁止转载。题图来自Unsplash，基于CC0协议"}
{"title": "mp-redux：解耦小程序中的业务与视图，让测试更容易 ", "author": "Rolan", "pub_time": "2018-10-16 00:34", "content": "项目地址：点我，欢迎star和issue\r\nmp-redux\r\n一个用于小程序和轻量级H5应用的状态管理工具， 使用方法是一个简化版本的Redux。之所以是适用于轻量级应用，主要是因为没有实现组件间的数据共享。因此不适合于复杂，庞大的前端应用。\r\n是否你需要使用它？\r\n如果你也和我有同样的困惑，那么你就该尝试一下：\r\n\r\n代码耦合严重，业务代码重复，往往改一处就会引起诸多功能也要跟着修改\r\n业务逻辑都写在视图逻辑层，但是有苦于没有办法将业务代码剥离\r\n代码越来越臃肿不堪\r\n对老代码不敢碰，会影响很多业务逻辑\r\n\r\n为什么借鉴redux\r\n\r\n用为redux是框架无关的，所以具有更好的可移植性，当然我这里在内部还是做了一些\"猥琐\"处理来兼容多平台\r\n单一数据源，让状态更容易被跟踪\r\n将业务逻辑与视图层分离，让代码更清晰，耦合更低\r\n状态都应该放在页面的根容器去管理，分发到各个子组件。以便更好的控制业务逻辑\r\n业务逻辑都放入model中，而model都是纯函数，让测试更加容易\r\n\r\n如何使用？\r\n拷贝 /mp-redux/index.js文件到项目中引入即可。开包即用。\r\n为什么没有使用npm?\r\n懒\r\napi使用方法\r\n\r\n在系统入口我们必须初始化store\r\n\r\n  const mpState = require('./mp-redux/index.js');\r\n  const userInfo = require('./model/userinfo.js');\r\n  const logs = require('./model/logs.js');\r\n\r\n  mpState.createStore({\r\n    logs, // 这些model 就是redux的reduce，必须是纯函数，并且需要返回一个纯对象\r\n    userInfo // 这些model 就是redux的reduce，必须是纯函数，并且需要返回一个纯对象\r\n  }, 'onShow') // 第二个参数是劫持的生命周期函数，这是为了解决不同平台的差异性问题导致的。后期会考虑优化\r\n复制代码\r\n创建model\r\n\r\n  // model 就是数据模型，是根据业务而来的\r\n  // model/userinfo.js\r\n  const actions = require('./../action/logs.js'); // 这里同样采用了redux的action机制\r\n\r\n  const initState = {\r\n    logs: []\r\n  }\r\n\r\n  module.exports = function (state = initState, action = {}) {\r\n    const newState = { ...state };\r\n    switch (action.type) {\r\n      case actions.addLogs:\r\n        const now = new Date();\r\n        newState.logs.push({\r\n          time: now.getHours() + \":\" + now.getMinutes() + \":\" + now.getSeconds(),\r\n          value: action.data\r\n        });\r\n        return newState;\r\n      case actions.clearLogs:\r\n        newState.logs = [];\r\n        return newState;\r\n      default:\r\n        return newState;\r\n    }\r\n  }\r\n  // action/userinfo.js\r\n  module.exports = {\r\n    addLogs: 'LOGS_ADD',\r\n    clearLogs: 'LOGS_CLEAR'\r\n  }\r\n复制代码\r\n在Page中使用\r\n\r\n  // 使用connect来注入需要订阅的状态，并且mp-redux会在页面对象中自动注入dispatch方法 \r\n  const mpState = require('./../../mp-redux/index.js');\r\n  const util = require('../../utils/util.js');\r\n  const logActions = require('./../../action/logs.js');\r\n\r\n  Page(mpState.connect((state) => {\r\n    return {\r\n      userInfo: state.userInfo.userInfo,\r\n      logs: state.logs.logs\r\n    }\r\n  },\r\n  { // 在这里所有的业务数据都保存在store中，所以页面如果只有业务数据的话，是不需要data属性的。\r\n    clearLogs() {\r\n      this.dispatch({ // 通过dispatch方法来发出action，从而更新store中的数据\r\n        type: logActions.clearLogs\r\n      })\r\n    }\r\n  }))\r\n复制代码\r\n更容易被测试的业务代码\r\n从上面我们将业务数据声明到model中，而所有的业务数据更新以及业务数据更新的逻辑都在model中完成(参考/model/logs.js)。而model都是纯函数，因此业务代码更加容易被测试。\r\n\r\n  // 不要吐槽，，，，，，我第一次写测试用例。(-_-)\r\n  const actions = require('./../action/logs.js');\r\n  const model = require('./../model/logs.js');\r\n\r\n  test('1. init logs data', () => {\r\n    expect(model()).toEqual({\r\n      logs: []\r\n    })\r\n  })\r\n\r\n  test('2. add new log into empty logs', () => {\r\n    const newState = model(undefined, {\r\n      type: actions.addLogs,\r\n      data: \"Test new log\"\r\n    });\r\n\r\n    expect({\r\n      value: newState.logs[0].value,\r\n      len: newState.logs.length\r\n    }).toEqual({\r\n      value: \"Test new log\",\r\n      len: 1\r\n    });\r\n  })\r\n\r\n  test('3. add new log into logs', () => {\r\n    const newState = model({logs: [{time: '00:00:00', value: 'the first log'}]}, {\r\n      type: actions.addLogs,\r\n      data: \"the second log\"\r\n    });\r\n\r\n    expect({\r\n      log1: newState.logs[0].value,\r\n      log2: newState.logs[1].value,\r\n      len: newState.logs.length\r\n    }).toEqual({\r\n      log1: \"the first log\",\r\n      log2: \"the second log\",\r\n      len: 2\r\n    });\r\n  })\r\n\r\n  test('4. clear all logs', () => {\r\n    const newState = model({ logs: [\r\n      { time: '00:00:00', value: 'log1' }, \r\n      { time: '00:00:00', value: 'log2' }\r\n      ] }, {\r\n        type: actions.clearLogs\r\n      });\r\n\r\n    expect({\r\n      len: newState.logs.length\r\n    }).toEqual({\r\n      len: 0\r\n    });\r\n  })\r\n复制代码因为互联网产品都是toC业务，UI基本上每天都在变化，但是业务的变化其实是很小的。我们通过将业务建模，在前端构建业务数据模型。而这些模型是可以预知的。因此也就可测试。\r\n而对于一些互联网产品，前端测试是一件非常繁琐而复杂的事情。因此这个简单的方案大大的降低了前端代码变动引起的风险，而增加的工作量也并不是很大。可以一定程度上降低业务代码的回归测试成本。作者：YaHuiLiang(Ryou)链接：https://juejin.im/post/5bbb315d6fb9a05cf039ffed来源：掘金"}
{"title": "在小程序开发中使用 npm ", "author": "Rolan", "pub_time": "2018-10-17 00:11", "content": "微信小程序在 2.2.1 版本后增加了对 npm 包加载的支持，使得小程序支持使用 npm 安装第三方包。1. 在小程序中加载 npm 包npm install miniprogram-datepicker --production\r\nnode_modules可以 在小程序根目录下，也可以存在于小程序根目录下的各个子目录中。但是不可以 在小程序根目录外。使用--production选项，可以减少安装一些业务无关的 npm 包，从而减少整个小程序包的大小。2. 构建 npm 包在微信小程序开发工具的「工具」菜单下点击「构建 npm」命令，进行 npm 包的构建，此构建可以将 npm 包构建成在小程序中可加载使用的包。node_modules 目录不会参与编译、上传和打包中，所以小程序想要使用 npm 包必须走一遍“构建 npm”的过程，在最外层的 node_modules 的同级目录下会生成一个 miniprogram_npm 目录，里面会存放构建打包后的 npm 包，也就是小程序真正使用的 npm 包。构建打包分为两种：小程序 npm 包会直接拷贝构建文件生成目录下的所有文件到 miniprogram_npm 中；其他 npm 包则会从入口 js 文件开始走一遍依赖分析和打包过程（类似 webpack）。寻找 npm 包的过程和 npm 的实现类似，从依赖 npm 包的文件所在目录开始逐层往外找，直到找到可用的 npm 包或是小程序根目录为止。构建完成后还需要确认项目已勾选了「使用 npm 模块」。3.使用npm包js 中引入 npm 包：const package = require('packageName')\r\n使用 npm 包中的自定义组件：{\r\n    \"usingComponents\": {\r\n      \"datepicker\": \"miniprogram-datepicker\"\r\n    }\r\n}\r\nminiprogram-datepicker组件运行效果其他微信小程序npm支持文档：https://developers.weixin.qq...."}
{"title": "9块钱部署一个小程序 ", "author": "Rolan", "pub_time": "2018-10-17 00:11", "content": "小程序制作和部署从本质上是和其他的网站是一样的，需要域名、服务器空间和数据库。域名就是你们家的地址，服务器空间就是你们家房子，数据库就是你们家的保险柜。但是小程序和网站又有不同，小程序的前端部分是需要通过微信开发工具上传到微信的服务器上，就是说你们家的装潢都在微信的服务器上。当然你也可以把小程序的全部代码上传到自己的服务器上去。小程序的制作流程第一步：注册小程序https://mp.weixin.qq.com/按步骤注册小程序，获取appId和appSecret。第二步：微信开发工具你可以下微信的demo，了解小程序的前端和后端的开发结构。小程序前端包括的js,json,wxml,wxss.对应到网页就是js,html,css。微信开发里面有很多坑，先说个简单的微信授权吧，其他的以后说。第三步：微信的后台处理购买主机建站会获得一个可用的无备案的域名。但是里面的空间不能用ci框架，ci框架需要配置nginx来做路由设置。9块钱购买的空间里面不支持设置nginx。而且这个空间会隔几个小时让你输入密码，如果你是开发做实验，这个空间是足够的。如果你是自己开发，你可能要买一些好的服务器空间。可以自己操作里面的nginx。第四步：微信的提交体验和开发版点击微信开发者工具的上传按钮可以把你的版本上传到线上作为体验版本。然后可以提交审核变成线上版本。总结：开发部署练习9块钱就行！"}
{"title": "尝试解决微信小程序分页最后setData数据太大限制的问题 ", "author": "Rolan", "pub_time": "2018-10-17 00:43", "content": "前些天，突然接到用户的大量反馈，我们的小程序频繁出现闪退，崩溃的现象。如图，于是马上着手追查问题，首先确定了导致闪退的页面。是在一个有长列表的页面，当上拉加载更多，翻页翻多几页的时候就导致闪退了。经过重重排查（时间问题，这里就不详细描述排查的方法了，大多数用的都是缩小范围排除法啦），最后终于确定了问题所在，原来是在列表中，同事最近新加上的css3动画所致，这里的列表是循环渲染的一个组件，组件中的一个弹窗的弹出和收起，使用动画，但是这里没有加上wx:if,导致了循环渲染该动画，所以翻页翻着翻着就挂掉了。 确定了问题，就很好办了，加上条件判断，只有需要的时候，才渲染弹出弹窗。真机调试，暴力狂刷数据，发现闪退的现象不再出现了，闪退问题解决，然而高兴不到三分钟，又出问题了，发现翻页到十几页的时候，再也刷不动后面的数据了，明明是还有更多数据的。再在开发工具上看查看数据，结果控制台报了这么一个错在真机上为：这是什么问题呢，查看官方文档，发现是有这样的限制的回顾我们的代码，这里的分页加载数据，上拉加载，数据是放在一个for循环里去加载，数据源是一个数组对象。在加载下一页数据时，将下一页的数据拼到当前数组后面。这里是常规的做法。可以看看代码：这里可以看到，每次获取新的一页，都要重新setData新的数组，仔细想想，当这个数组到后面越来越大的时候，很容易就超出了单次设置数据超过1024kb的限制了。那么怎么解决这个问题呢，这里官方文档里面其实有提到一个注意点，既然这里是支持改变数组的某一项，那么分页的问题，可以改变为一个二维数组，还是直接看代码吧。这里的方法则暂时摆脱了单次设置数据多大的问题。当然，要是单页的数据过多，还是会出现问题的。最合适的还是对数据结构进行精简，前端不必要的数据，可以不传过来前端。写在最后，这次第一次写类似的分享，描述还是有些不清晰，以后可以多尝试这样的总结吧。"}
{"title": "利用云开发优化博客小程序（三）——生成海报功能 ", "author": "Rolan", "pub_time": "2018-10-17 00:52", "content": "欠下的生成海报的功能终于补上了周末花了点时间把小程序版博客中的生成海报的功能给完成了，对于新手的我来说遇到的问题还是挺多的，这里简单记录下坑。首先看下效果图：思路还是比较简单，主要就是利用微信提供的画布 canvas 来动态构造海报。引导用户保存至本地相册，用于分享。主要涉及小程序画布和图片相关的API，若是不太熟悉的话可以优先参考下文档。资源准备首先需要准备构成海报的一些资源，比如文章的首图，标题，需要分享的小程序码。对于文章的首图，是从腾讯云的对象存储中获取，需要在开发设置中配置好 downloadFile合法域名 ,至于为什么转战腾讯云对象存储可以参考 免费的对象存储——七牛云还是腾讯云获取图片可直接通过 wx.getImageInfo ,对应的API还是比较简单的：wx.getImageInfo({\r\n  src: url,\r\n  success (res) {\r\n    console.log(res.path)\r\n  }\r\n})至于小程序码，目前使用的是小程序本身的，暂时没有动态生成，后期会迭代。直接将小程序码上传至云存储上,获取时也比较简单：wx.cloud.downloadFile({\r\n  fileID: fileID\r\n}).then(res => {\r\n  console.log(res.tempFilePath)\r\n})最后，其他需要在海报上展现的内容，根据实际情况进行获取。生成海报资源准备完之后，就需要利用画布进行构造海报了。在wxml添加canvas元素，需要注意的是避免在页面上展示，可以将位置设置在屏幕之外，比如 top:99999rpx\r\n<view class=\"canvas-box\">\r\n  <canvas style=\"width: 600px;height: 970px;\" canvas-id=\"mycanvas\" />\r\nview>然后需要了解下canvas相关API和属性了。优先创建canvas的绘图上下文 CanvasContext 对象,然后通过CanvasContext中的属性进行绘制，最后通过 draw() 将之前在绘图上下文中的描述（路径、变形、样式）画到 canvas 中。具体可以参考下面的代码，结合注释和官方文档很容易理解：var context = wx.createCanvasContext('mycanvas');\r\n    context.setFillStyle('#ffffff');//设置填充色\r\n    context.fillRect(0, 0, 600, 970);//填充一个矩形。用 setFillStyle 设置矩形的填充色\r\n    context.drawImage(postImageLocal, 0, 0, 600, 300); //绘制首图\r\n    context.drawImage(qrcodeLoal, 210, 650, 180, 180); //绘制二维码\r\n    context.setFillStyle(\"#000000\");\r\n    context.setFontSize(20);//设置字体大小\r\n    context.setTextAlign('center');//设置字体对齐\r\n    context.fillText(\"阅读文章,请长按识别二维码\", 300, 895);\r\n    context.setFillStyle(\"#000000\");\r\n    context.beginPath() //分割线\r\n    context.moveTo(30, 620)\r\n    context.lineTo(570, 620)\r\n    context.stroke();\r\n    context.setTextAlign('left');\r\n    context.setFontSize(40);\r\n\r\n    if (title.lengh <= 12) {\r\n      context.fillText(title, 40, 360);//文章标题\r\n    } else {\r\n      context.fillText(title.substring(0, 12), 40, 360);\r\n      context.fillText(title.substring(12, 26), 40, 410);\r\n    }\r\n\r\n    context.setFontSize(20);\r\n    if (custom_excerpt.lengh <= 26) {\r\n      context.fillText(custom_excerpt, 40, 470);//文章描述\r\n    } else {\r\n      context.fillText(custom_excerpt.substring(0, 26), 40, 470);\r\n      context.fillText(custom_excerpt.substring(26, 50) + '...', 40, 510);\r\n    }\r\n\r\n    context.draw();这里需要注意的是填写文字时，画布是不会自动换行的，所以这里需要根据字体大小和字体多少来自行控制换行。在填充完canvas之后，通过 wx.canvasToTempFilePath 来生成图片，并保存在临时路径下，具体代码如下：wx.canvasToTempFilePath({\r\n  canvasId: 'mycanvas',\r\n  success: function(res) {\r\n    var tempFilePath = res.tempFilePath;\r\n    wx.hideLoading();\r\n    console.log(\"海报图片路径：\" + res.tempFilePath);\r\n    that.setData({\r\n      showPosterPopup: true,//展示弹窗\r\n      showPosterImage: res.tempFilePath //对应路径\r\n    })\r\n  },\r\n  fail: function(res) {\r\n    console.log(res);\r\n  }\r\n});到这里，最简单的海报生成完成了，接下来就是涉及交互了。交互样式首先利用zanui的 zan-popup 来实现弹出层，还是比较方便的。具体样式就不贴了，可以直接看我的源码。弹出层中加载生成好的海报图片，通过按钮引导用户保存至本地相册，在保存相册时，需要用户授权本地相册的权限，这里需要做好交互，当用户拒绝之后再次想保存时，让他重新授权。当用户取消时，再次提醒：具体代码如下，供参考：/**\r\n * 保存海报图片\r\n */\r\nsavePosterImage: function() {\r\n  let that = this\r\n  wx.saveImageToPhotosAlbum({\r\n    filePath: that.data.showPosterImage,\r\n    success(result) {\r\n      console.log(result)\r\n      wx.showModal({\r\n        title: '提示',\r\n        content: '二维码海报已存入手机相册，赶快分享到朋友圈吧',\r\n        showCancel: false,\r\n        success: function(res) {\r\n          that.setData({\r\n            showPosterPopup: false\r\n          })\r\n        }\r\n      })\r\n    },\r\n    fail: function(err) {\r\n      console.log(err);\r\n      if (err.errMsg === \"saveImageToPhotosAlbum:fail auth deny\") {\r\n        console.log(\"再次发起授权\");\r\n        wx.showModal({\r\n          title: '用户未授权',\r\n          content: '如需保存海报图片到相册，需获取授权.是否在授权管理中选中“保存到相册”?',\r\n          showCancel: true,\r\n          success: function(res) {\r\n            if (res.confirm) {\r\n              console.log('用户点击确定')\r\n              wx.openSetting({\r\n                success: function success(res) {\r\n                  console.log('打开设置', res.authSetting);\r\n                  wx.openSetting({\r\n                    success(settingdata) {\r\n                      console.log(settingdata)\r\n                      if (settingdata.authSetting['scope.writePhotosAlbum']) {\r\n                        console.log('获取保存到相册权限成功');\r\n                      } else {\r\n                        console.log('获取保存到相册权限失败');\r\n                      }\r\n                    }\r\n                  })\r\n\r\n                }\r\n              });\r\n            }\r\n          }\r\n        })\r\n      }\r\n    }\r\n  });\r\n}到这里，小程序的生成海报功能基本上就完成了。总结其实生成海报的功能还有很多小问题，由于最近项目比较紧匆匆上了，后面找时间会优化。通过生成海报的功能，主要还是学习了画布的API，并通过实战也基本可以上手canvas，至于画布上排版，样式就需要自己耐心了，尤其是一些小地方。程序上线后我才发现，海报上的标题，由于有中英文，所占的字符不同，所以换行的处理过于草率了，导致有英文的标题在位置上存在偏差。后期有空的话再持续改善吧～"}
{"title": "各种小程序的组件机制差异 ", "author": "Rolan", "pub_time": "2018-10-18 00:12", "content": "在蚂蚁金服的开放平台上看到一些贴子，说提供一个工具，一键转换微信小程序为支付宝小程序。我与百度的人交流时，也听到相似的东西。其实都没有这么简单，它们最多是将一些循环条件分支指令改一下名，将一些文件的后缀名改一下，更多的差异点在API与各式的配置对象上，细节是魔鬼，我在娜娜奇的官网也列举了许多相关的东西，但也不能打票说已经很齐全。。。。各种小程序的差异点-文档补充一句，娜娜奇是我们公司的小程序开发框架，以React方式转译成各种小程序与快应用的框架。类似于京东的taro。最近忙于支付宝小程序的开发，我得到许多有关小程序的一手资料，包括自己测试得到的，及从百度，小米快应用与支付宝内部人士提供的。本文将重点说一下小程序的组件机制，之前娜娜奇的组件机制是基于template标签实现的，但百度的template有点BUG，给他们提了，不知现在修了没有。与template机制在快应用又出入太大，于是转向用自定义组件机制开发娜娜奇的组件机制。下面链接有一些相关的测试与说明转换小程序 · Issue #133 · RubyLouvre/anu经测试，使用了自定义组件机制的确是比template实现的简洁一些。但自定义组件机制是一个比较高级的特性，因此兼容性上比template差多了。只能内部推到各方改进了。微信在Component的配置对象提供了一些对象如methods， lifetimes，pageLifetimes，来减少其直辖的配置项。比如说lifetimes收纳了created、attached、ready、moved、detached这些生命周期钩子，pageLifetimes收纳了onShow, onHide这些与页面切换的钩子，methods收纳剩下的方法，另外还有许多配置项。的确，微信小程序独自发布这么久，肯定是最完善的支付宝的自定义组件机制没有properties，只有props，并且作用也不一样，props只是指定默认值，不是规定参数类型。支付宝也没有lifetimes与pageLifetimes对象，生命周期函数的名字也不一样 didMount 、didUpdate 、didUnmount，数量也少了，但从名称来看，支付宝在内部应该运行一个自己的迷你React。其他方面，支付宝没有 dataset， selectComponent，selectAllComponents，getRelationNodes这些东西，但支持了早被React废弃的mixin机制。支付宝没有created这样的钩子是相当麻烦的事，因此积级推动他们加上这个钩子！百度的自定义组件机制与微信的较为相近，但也没有lifetimes与pageLifetimes对象，只有4种生命周期钩子：created，attached，ready，detached。有selectComponent，selectAllComponents。快应用的页面与组件的配置对象都是一样，但它没有构造函数，只是要求我们export一个对象有props对象，用来定义类型与默认值，也有与state相似的data对象，也有三个做了访问限制的private, protected, public对象。生命周期钩子上有onInit、onReady、onDestroy这三个。从组件的设计来看， 微信 > 百度 > 支付宝 > 快应用因此想兼容这么多种小程序，我们必须自己写一个工厂方法，根据不同的平台生成不同的配置项，并且放弃掉一些微信的强大功能了。var hooksName = {\r\n\twx: ['created', 'attached', 'detached'],\r\n\tbu: ['created', 'attached', 'detached'],\r\n\tali: ['didMount', 'didMount', 'didUnmount'],\r\n\tquick: ['onInit', 'onReady', 'onDestroy'],\r\n};\r\n\r\nexport function registerComponent(type, name) {\r\n\tregisterComponents[name] = type;\r\n\tvar reactInstances = (type.reactInstances = []);\r\n\tvar wxInstances = (type.wxInstances = []);\r\n\tvar hooks = [\r\n\t\tfunction created() {\r\n\t\t\tvar instance = reactInstances.shift();\r\n\t\t\tif (instance) {\r\n\t\t\t\tconsole.log('created时为', name, '添加wx');\r\n\t\t\t\tinstance.wx = this;\r\n\t\t\t\tthis.reactInstance = instance;\r\n\t\t\t} else {\r\n\t\t\t\tconsole.log('created时为', name, '没有对应react实例');\r\n\t\t\t\twxInstances.push(this);\r\n\t\t\t}\r\n\t\t},\r\n\t\tfunction attached() {\r\n                        if(appType == \"ali\"){\r\n                            created.call(this)\r\n                        }\r\n\t\t\tif (this.reactInstance) {\r\n\t\t\t\tupdateMiniApp(this.reactInstance);\r\n\t\t\t\tconsole.log('attached时更新', name);\r\n\t\t\t} else {\r\n\t\t\t\tconsole.log('attached时无法更新', name);\r\n\t\t\t}\r\n\t\t},\r\n\t\tfunction detached() {\r\n\t\t\tthis.reactInstance = null;\r\n\t\t},\r\n\t];\r\n\tvar data = {\r\n\t\tprops: {},\r\n\t\tstate: {},\r\n\t\tcontext: {},\r\n\t};\r\n\tvar config = {\r\n\t\tdata: data,\r\n\t\tpublic: data,\r\n\t\tdispatchEvent: eventSystem.dispatchEvent,\r\n\t\tmethods: {\r\n\t\t\tdispatchEvent: eventSystem.dispatchEvent,\r\n\t\t},\r\n\t};\r\n\thooksName[appType].forEach(function(name, index) {\r\n\t\tconfig[name] = hooks[index];\r\n\t});\r\n\r\n\treturn config;\r\n}"}
{"title": "当微信小程序遇上 TensorFlow：接收 base64 编码图像数据 ", "author": "Rolan", "pub_time": "2018-10-18 00:21", "content": "这是 当微信小程序遇上TensorFlow 系列文章的第四篇文章，阅读本文，你将了解到：如何查看tensorflow SavedModel的签名如何加载tensorflow SavedModel如何修改现有的TensorFlow模型，增加输入层如果你想要了解更多关于本项目，可以参考这个系列的前三篇文章：当微信小程序遇上TensorFlow：Server端实现当微信小程序遇上TensorFlow：Server端实现补充当微信小程序遇上TensorFlow：小程序实现关于Tensorflow SavedModel格式模型的处理，可以参考前面的文章：Tensorflow SavedModel模型的保存与加载如何查看tensorflow SavedModel格式模型的信息如何合并两个TensorFlow模型问题截至到目前为止，我们实现了一个简单的微信小程序，使用开源的Simple TensorFlow Serving部署了服务端。但这种实现方案还存在一个重大问题：小程序和服务端通信传递的图像数据是(299, 299, 3)二进制数组的JSON化表示，这种二进制数据JSON化的最大缺点是数据量太大，一个简单的299 x 299的图像，这样表示大约有3 ～ 4 M。其实HTTP传输二进制数据常用的方案是对二进制数据进行base64编码，经过base64编码，虽然数据量比二进制也会大一些，但相比JSON化的表示，还是小很多。所以现在的问题是，如何让服务器端接收base64编码的图像数据？查看模型的签名为了解决这一问题，我们还是先看看模型的输入输出，看看其签名是怎样的？这里的签名，并非是为了保证模型不被修改的那种电子签名。我的理解是类似于编程语言中模块的输入输出信息，比如函数名，输入参数类型，输出参数类型等等。借助于Tensorflow提供的saved_model_cli.py工具，我们可以清楚的查看模型的签名：python ./tensorflow/python/tools/saved_model_cli.py show --dir /data/ai/workspace/aiexamples/AIDog/serving/models/inception_v3/ --all\r\n\r\nMetaGraphDef with tag-set: 'serve' contains the following SignatureDefs:\r\n\r\nsignature_def['serving_default']:\r\n  The given SavedModel SignatureDef contains the following input(s):\r\n    inputs['image'] tensor_info:\r\n        dtype: DT_FLOAT\r\n        shape: (-1, 299, 299, 3)\r\n        name: Placeholder:0\r\n  The given SavedModel SignatureDef contains the following output(s):\r\n    outputs['prediction'] tensor_info:\r\n        dtype: DT_FLOAT\r\n        shape: (-1, 120)\r\n        name: final_result:0\r\n  Method name is: tensorflow/serving/predict从中我们可以看出模型的输入参数名为image，其shape为(-1, 299, 299, 3)，这里-1代表可以批量输入，通常我们只输入一张图像，所以这个维度通常是1。输出参数名为prediction，其shape为(-1, 120)，-1和输入是对应的，120代表120组狗类别的概率。现在的问题是，我们能否在模型的输入前面增加一层，进行base64及解码处理呢？也许你认为可以在服务器端编写一段代码，进行base64字符串解码，然后再转交给Simple Tensorflow Serving进行处理，或者修改Simple TensorFlow Serving的处理逻辑，但这种修改方案增加了服务器端的工作量，使得服务器部署方案不再通用，放弃！修改模型，增加输入层其实在上一篇文章《 如何合并两个TensorFlow模型 》中我们已经讲到了如何连接两个模型，这里再稍微重复一下，首先是编写一个base64解码、png解码、图像缩放的模型： base64_str = tf.placeholder(tf.string, name='input_string')\r\n  input_str = tf.decode_base64(base64_str)\r\n  decoded_image = tf.image.decode_png(input_str, channels=input_depth)\r\n  # Convert from full range of uint8 to range [0,1] of float32.\r\n  decoded_image_as_float = tf.image.convert_image_dtype(decoded_image,\r\n                                                        tf.float32)\r\n  decoded_image_4d = tf.expand_dims(decoded_image_as_float, 0)\r\n  resize_shape = tf.stack([input_height, input_width])\r\n  resize_shape_as_int = tf.cast(resize_shape, dtype=tf.int32)\r\n  resized_image = tf.image.resize_bilinear(decoded_image_4d,\r\n                                           resize_shape_as_int)\r\n  tf.identity(resized_image, name=\"DecodePNGOutput\")接下来加载retrain模型： with tf.Graph().as_default() as g2:\r\n    with tf.Session(graph=g2) as sess:\r\n      input_graph_def = saved_model_utils.get_meta_graph_def(\r\n          FLAGS.origin_model_dir, tag_constants.SERVING).graph_def\r\n\r\n      tf.saved_model.loader.load(sess, [tag_constants.SERVING], FLAGS.origin_model_dir)\r\n\r\n      g2def = graph_util.convert_variables_to_constants(\r\n          sess,\r\n          input_graph_def,\r\n          [\"final_result\"],\r\n          variable_names_whitelist=None,\r\n          variable_names_blacklist=None)这里调用了graph_util.convert_variables_to_constants将模型中的变量转化为常量，也就是所谓的冻结图(freeze graph)操作。利用tf.import_graph_def方法，我们可以导入图到现有图中，注意第二个import_graph_def，其input是第一个graph_def的输出，通过这样的操作，就将两个计算图连接起来，最后保存起来。代码如下： with tf.Graph().as_default() as g_combined:\r\n    with tf.Session(graph=g_combined) as sess:\r\n      x = tf.placeholder(tf.string, name=\"base64_string\")\r\n      y, = tf.import_graph_def(g1def, input_map={\"input_string:0\": x}, return_elements=[\"DecodePNGOutput:0\"])\r\n      z, = tf.import_graph_def(g2def, input_map={\"Placeholder:0\": y}, return_elements=[\"final_result:0\"])\r\n\r\n      tf.identity(z, \"myOutput\")\r\n\r\n      tf.saved_model.simple_save(sess,\r\n                                 FLAGS.model_dir,\r\n                                 inputs={\"image\": x},\r\n                                 outputs={\"prediction\": z})如果你不知道retrain出来的模型的input节点是啥（注意不能使用模型部署的signature信息）？可以使用如下代码遍历graph的节点名称：for n in g2def.node:\r\n  print(n.name)模型部署及测试注意，我们可以将连接之后的模型保存在./models/inception_v3/2/目录下，原来的./models/inception_v3/1/也不用删除，这样两个版本的模型可以同时提供服务，方便从V1模型平滑过渡到V2版本模型。我们修改一下原来的test_client.py代码，增加一个model_version参数，这样就可以决定与哪个版本的模型进行通信： with open(file_name, \"rb\") as image_file:\r\n    encoded_string = str(base64.urlsafe_b64encode(image_file.read()), \"utf-8\")\r\n\r\n  if enable_ssl :\r\n    endpoint = \"https://127.0.0.1:8500\"\r\n  else:\r\n    endpoint = \"http://127.0.0.1:8500\"\r\n\r\n  json_data = {\"model_name\": model_name,\r\n               \"model_version\": model_version,\r\n               \"data\": {\"image\": encoded_string}\r\n              }\r\n  result = requests.post(endpoint, json=json_data)小结经过一个多星期的研究和反复尝试，终于解决了图像数据的base64编码通信问题。难点在于虽然模型是编写retrain脚本重新训练的，但这段代码不是那么好懂，想要在retrain时增加输入层也是尝试失败。最后从Tensorflow模型转Tensorflow Lite模型时的freezing graph得到灵感，将图中的变量固化为常量，才解决了合并模型变量加载的问题。虽然网上提供了一些恢复变量的方法，但实际用起来并不管用，可能是Tensorflow发展太快，以前的一些方法已经过时了。本文的完整代码请参阅：https://github.com/mogoweb/aiexamples/tree/master/AIDog/serving点击 阅读原文 可以直达在github上的项目。到目前为止，关键的问题已经都解决，接下来就需要继续完善微信小程序的展现，以及如何提供识别率，敬请关注我的微信公众号：云水木石，获取最新动态。参考How to Show Signatures of Tensorflow Saved ModelServing Image-Based Deep Learning Models with TensorFlow-Serving’s RESTful APITensorflow: How to replace a node in a calculation graph?"}
{"title": "微信小程序图片预加载组件 wxapp-img-loader ", "author": "Rolan", "pub_time": "2018-10-18 00:25", "content": "由于微信小程序没有提供类似 Image 这样的 JS 对象，要实现图片的预加载要麻烦一些， wxapp-img-loader自定义组件可以在微信小程序中实现图片预加载功能。使用1、下载 wxapp-img-loader项目源代码（https://github.com/o2team/wxa...），将 img-loader 目录拷贝到你的项目中2、在页面的 WXML 文件中添加以下代码，将组件模板引入<import src=\"../../img-loader/img-loader.wxml\"/>\r\n<template is=\"img-loader\" data=\"{{ imgLoadList }}\"></template>\r\n3、在页面的 JS 文件中引入组件脚本const ImgLoader = require('../../img-loader/img-loader.js')\r\n\r\n4、实例化一个 ImgLoader 对象，将 this(当前 Page 对象) 传入，第二个参数可选，为默认的图片加载完成的回调方法this.imgLoader = new ImgLoader(this)\r\n\r\n5、调用 ImgLoader 实例的 load 方法进行图片加载，第一个参数为图片链接，第二个参数可选，为该张图片加载完成时的回调方法。图片加载完成的回调方法的第一个参数为错误信息（加载成功则为 null），第二个参数为图片信息（Object 类型，包括 src、width 及 height）。this.imgLoader.load(imgUrlOriginal, (err, data) => {    console.log('图片加载完成', err, data.src, data.width, data.height)\r\n})\r\nwxapp-img-loader组件可以加载单张图片、也可以加载多张图片。运行效果：其他wxapp-img-loader项目地址：https://github.com/o2team/wxa..."}
{"title": "小程序版结合promise的axios风格ajax请求函数 ", "author": "Rolan", "pub_time": "2018-10-18 00:42", "content": "建议的小程序版本的axios函数，之所以说简易，因为只是用了常用的请求方法外，然后添加了拦截器而已。具体如下：wxhttp命名为wxhttp具体的请求用法如axioswxhttp#request(config)wxhttp#get(url[,config])wxhttp#delete(url[,config])wxhttp#head(url[,config])wxhttp#options(url[,config])wxhttp#post(url[,data[,config]])wxhttp#put(url[,data[,config]])wxhttp#patch(url[,data[,config]])拦截方法：请求拦截wxhttp.interceptors.request.use(handleRequest(config),handleError(err))注意：handleRequest需要返回处理后的config返回拦截wxhttp.interceptors.response.use(handresponse(res))注意：handleResponse需要返回处理后的res例子：import $http from \"../../utils/http\"\r\nexport default {\r\n  name: 'seckillHome',\r\n  data() {\r\n    return {\r\n\r\n    }\r\n  },\r\n  onShow() {\r\n    // 请求拦截\r\n    $http.interceptors.request.use(function (config) {\r\n      console.log(`请求拦截`, config)\r\n      // 此处设置的数据将与请求的数据进行合并，如果自动同名则以拦截的为准。\r\n      config.data = {\r\n        address: \"北京市东城区\"\r\n      }\r\n      return config\r\n    })\r\n\r\n    $http.post('https://www.baidu.com', {\r\n      name: 'cdd',\r\n      age: 23\r\n    }).then(res => {\r\n      console.log(`结果是`, res)\r\n    })\r\n  }\r\n}因为使用了promise风格，所以可以使用Promise.all方法来进行并发请求。查看源码"}
{"title": "微信小程序 授权登录 41003 ", "author": "Rolan", "pub_time": "2018-9-26 00:43", "content": "最近遇到这么个坑，偶然请求己方服务器授权登录失败，百度上一堆复制黏贴的文章并不靠谱，最终在微信论坛上看到解决方案。 网上有些是说iv内空格导致解密失败，我出错的情况下并没有出现空格，排除这种情况。 有说是因为请求顺序，但是按照微信官方文档，似乎并不是最新的，至少我授权方式不完全跟文档一样。我的授权方式 通过添加一个按钮并且设置 open-type=\"getUserInfo\"<button class='wxBtn'         open-type=\"getUserInfo\"         bindgetuserinfo=\"wechatAction\">使用微信账号登录</button>在按钮点击事件里，会返回一些授权登录需要用到的字段如：iv、encryptedData、signature、rawData 这个时候再调用 wx.login() 去获取code，整合以上数据向己方服务器发送请求获取用户唯一标识 token。 通过以上的方式是可以成功登录，但是偶然会出现请求己方服务器授权登录失败，再一次就会成功。 原因在于请求顺序，这里的请求顺序是先请求 wx.getUserInfo(按钮) 再请求 wx.login()。有时候获取code后iv已经失效，所以失败。 解决方案：在请求 wx.login() 后，调用一次 wx.getUserInfo(废弃接口) ，更新iv等信息。注意：这里调用的废弃接口只是不再弹出授权请求窗口，但还是能够获取到 iv 等信息，授权接口弹窗已将在点击按钮的时候弹出，并且授权了，所以没毛病。 再总结一下，正确的顺序：wx.getUserInfo(按钮) -> wx.login() -> wx.getUserInfo(废弃接口)，整合以上操作获取到的最近数据 code、iv、encryptedData、signature、rawData 传给己方服务器，授权登录成功。以下贴上我的业务代码  // 点击微信登录  wechatAction: function(e) {      // 用户点击授权    // 先保存获取到的微信用户信息    const { nickName, avatarUrl } = JSON.parse(e.detail.rawData)     this.setData({      nickName: nickName,      avatarUrl: avatarUrl    })    // 获取微信code    this.reqWechatCode()  },  // 微信登录：获取code  reqWechatCode: function() {    // 授权接口登录接口    let that = this     // 从微信获取code    wx.showLoading({      title: '获取code',    })    wx.login({      success: function (res) {         if (res.code) {          wx.getUserInfo({            success: function (res) {              // 保存微信登录参数              const { encryptedData, iv, signature, rawData } = res              that.setData({                encryptedData: encryptedData,                iv: iv,                signature: signature,                rawData: rawData              })               that.wxLoginReq(res.code)            }          })        } else {          wx.showToast({            title: '获取code失败,请重试',            icon: 'none'          })        }        wx.hideLoading()      }    })   },  // 根据获取到的code 向服务器发送登录请求 获取token  wxLoginReq: function (code) {    let that = this     wx.showLoading({      title: '获取token中',    })    // 拿到code 再加上 encryptedData, iv, rawData, signature 等参数，请求token    let encryptedData = that.data.encryptedData    let iv = that.data.iv    let signature = that.data.signature    let rawData = that.data.rawData    var req = require('../../util/Request.js')    // 请求成功    let success = function(res) {      // console.log(res)      wx.hideLoading()      // 缓存token      const { token, user_id } = res.data.data      let userInfo = {        token: token,        user_id: user_id,        nickName: that.data.nickName,        avatarUrl: that.data.avatarUrl      }      getApp().setUserInfo(userInfo)      // 同步用户信息       getApp().loginSuccess(function () {        wx.navigateBack({})      })    }    // 请求失败    let fail = function(res) {      wx.hideLoading()      wx.showToast({        title: '获取token失败,请重试',        icon: 'none'      })    }     // 登录请求    req.reqLogin(code, encryptedData, iv, rawData, signature, success, fail)   },"}
